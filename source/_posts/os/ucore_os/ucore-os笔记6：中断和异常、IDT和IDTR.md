---
title: ucore-os笔记6：中断和异常、IDT和IDTR
date: 2019-12-19 09:31:58
tags:
- 操作系统
- ucore

category:
- 操作系统
- ucore
---
外部设备与CPU通信需要通过中断机制。例如，当按下键盘上的一个键的时候，必然要通知CPU该键被按下，一种方式是CPU一直监视键盘上有没有键按下，但是这种方式性能太低。另一种方式由设备主动通知CPU有事件发生，当键盘被按下时，键盘通知CPU有键被按下并且告知是哪一个键，这种方式就是中断方式。中断机制是系统具有响应式能力，也是进程/线程实现抢占式调度的一个重要基石（通过时钟中断）。

操作系统中有三种中断，分别是：
* 外部设备引起的：IO中断、始终中断等异步产生的，与CPU的执行无关，简称为`中断`
* CPU运行中引起的：例如除0、缺页、地址越界等等，在CPU运行时CPU检测到的异常，称为`异常`
* 用户调用引起的：例如系统调用，用户调用了INT指令，也是在CPU运行时检测到，称为`陷入`

上面的三种中断可以分为两大类，异步中断和同步中断。异步中断由外部事件产生，时间不确定。同步中断由CPU产生，可以是CPU执行时的异常，或者用户调用特定指定导致。

> 中断还可以分为可屏蔽中断和不可屏蔽中断，可屏蔽中断由NMI引脚触发，不受EFLAGS寄存器中的IF影响。普通中断硬件由INTR引脚引起，可通过IF位屏蔽

## 中断处理过程
当CPU检测到中断时，会中断当前指令的执行，调转到中断处理程序的位置执行。那如何直到中断处理程序在哪个位置呢？CPU使用IDTR和IDT和储存中断处理程序的地址。中断调用结束后会回到被中断的指令的位置继续执行，那如何直到中断前的指令的位置呢？通过堆栈来实现，CPU会自动将指令位置相关的寄存器cs、eip压入内核栈，中断结束后通过iret将栈中的数据恢复到寄存器中。

IDTR是中断描述符表寄存器，存了中断描述符（IDT）的起始地址和长度：
[IDTR](/img/IDTR.png)

每一个中断有一个中断向量号，最多有256个中断向量号。中断向量号对应IDT中的表项，IDT是中断描述符表，里面最多有256个表项与中断向量号一一对应。寻找中断程序入口的步骤是，从IDTR找到起始地址，注意这里的起始地址就是线形地址，不需要在经过GDT转化；寻找计算对应的表项的地址，计算公式是base+interrupt number * 8，乘8是因为一个表项占8个字节。找到对应的表项之后，表项中存了中断程序的逻辑地址，就是段描述符+偏移；CPU将段描述符加载到段寄存器中，偏移加载到EIP中，然后就得到中断处理程序的线形地址，描述符表项结构：
[IDT表项](/img/IDT-entry.png)

中断向量表的前32个是被CPU保留的，`[32,255]`是给用户使用的，所以ucore定义的中断都在32之后，包括IO设备中断、系统调用等等。cpu触发中断以后，会禁用中断（将EFLAGS寄存器中的IF位置0），中断处理程序中可以手动开启来实现中断嵌套，但是需要自行处理堆栈；陷入和异常不会禁用中断。

IDT中有三种描述符，在上图中有其格式，分别是：
* Task-gate descriptor
* Interrupt-gate descriptor
* Trap-gate descriptor

### 中断过程中硬件完成的工作
中断过程中的调转到中断程序和从中断程序都是硬件进行的：
* CPU在执行完每一条指令之后，都会检测中断请求，如果监测到中断请求，会从总线上读取对应的中断向量（对应计算机接口中的IO读周期）
* 用读取到的中断向量号来寻找中断向量的起始地址，通过IDT和IDTR找到描述符项
* 描述符项中有段描述符和偏移，利用它们找到GDT中的对应表项，取的中断服务程序的线形地址
* CPU会根据CPL和中断处理程序的段描述符的DPL确定是否发生了特权级的转换。因为用户程序运行在用户态，而内核程序运行在内核态。中断会陷入内核态，如果是在用户态，则需要先切换到内核态。在用户态执行int指令，会通过TSS和TR可以取得内核栈地址，切换到内核栈然后将用户态的ss和esp压栈保存下来。如果是内核态陷入中断，则不需要这些处理，栈中也没有ss和esp
* CPU会保存一些现场信息用于返回原程序执行，所以会压栈eflags、cs、eip、errorCode（有的中断有errorCode，有的中断没有，是CPU预置的）
* CPU将cs、和eip切换到中断程序的地址，然后开始执行
* 执行完中断程序以后，通过iret指定恢复原有的程序。指定iret后，CPU会将eflags、cs、eip从栈中恢复到寄存器中，cpu不会自动弹出errorCode，需要手动弹出
* 如果是有特权级切换，不管是用户态还是内核态，都会弹出ss和esp。

中断处理程序寻址过程：
[中断处理程序寻址过程](/img/idt表项寻址过程.png)

堆栈变化：
[堆栈变化](/img/堆栈变化.png)

这里需要注意堆栈变化，当有权限切换时，会压入/弹出SS和ESP，不管是从内核到用户态还是从用户态到内核态。例如，从内核触发中断的时候，没有发生切换，所以不会压栈SS和ESP，但是如果在中断程序中切换了CS到用户态的CS，那么从中断返回的时候，就会从堆栈中多弹出SS和ESP，写代码的时候要注意这一点（lab1挑战实验1）。
[堆栈变化1](/img/interrupt-stack.gif)

### 中断处理过程中的特权级转换
中断时CPU会进行特权级的检查。这个特权级的检查分成两个部分，一个是IDT中表项中的段描述符，段描述符中的DPL确定了所处段的特权级，**只有段描述符的特权级高于或等于当前特权级时，检查通过**；当触发中断和从中断程序返回都会检查，检查中断程序的段选择符和当前的CS，如果两者的DPL不相同，就发生特权级切换了，堆栈处理操作不同，看上一小节的堆栈图。

另一个是IDT表项中的DPL，如果是用户态程序触发的（例如INT n），还会检查表项中的DPL，只有当DPL更低时或相同时才通过检查，这就阻止了用户程序能够触发任意的中断，例如用户态为3，那么就只能触发DPL为3的中断。**这里需要注意只有INT指令触发的中断，才会检查DPL，由硬件触发的中断不会检查DPL，所以硬件中断的代码即使位于内核段中，也能直接被调用；但是权限切换依然会被检查，如果当前是用户态执行触发了硬件中断，那么会压入ss和esp**

如果检查失败，CPU会触发一个保护异常。
[idt-privilige-check](/img/idt-privilige-check.png)


### ucore-os对于中断的实现
ucore-os的中断向量表定义在kern/trap/vector.S中，该文件由tools/vertor.c文件生成。vector.S文件的主要内容是定义了256个中断向量处理程序的入口，在中断时的有的会自动压入errorNumber，有的不会，vector.S中的不会自动压入errorNumber的会压入一个0，以统一结构。每一个程序再压栈errorNumber（如果CPU不会自动压栈的话）和压栈中断向量号后，同一调转到`__alltraps`执行：
```S
.globl __alltraps
.globl vector0
vector0:
  pushl $0
  pushl $0
  jmp __alltraps
```

__alltraps是另一个汇编文件trapentry.S中定义的全局符号，链接后会指向trapentry.S中的`__alltraps`。trapentry.S的作用是构造trapframe的栈结构，并调用trap函数，trap函数返回后出栈trapframe的结构。因为涉及到特定寄存器的入栈出栈，这一部分代码用汇编语言描述最方便。

vector.S中定义了全局段全局符号`__vectors`，其值是一个数组的起始地址，数组的每一项是每一个入口程序的地址。因为符号`__vectors`是全局符号，所以可以在C程序中可以直接访问，因为链接后会加入到符号表中。
```s
# vector table
.data
.globl __vectors
__vectors:
  .long vector0
  .long vector1
  .long vector2
  .long vector3
  .long vector4
  ...
```

再idt_init进行idt初始化的时候，要做的事情就是构造IDT表并填充表项。`__vectors`中已经有了中断处理函数的地址，只需要在设置DPL等等其他表项的内容，就能构造出来IDT表。最后将IDT表的地址使用lidt指令加载到IDTR寄存器中，我们就完成了中断向量表的初始化。