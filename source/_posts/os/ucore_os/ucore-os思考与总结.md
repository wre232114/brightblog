---
title: ucore-os思考与总结
date: 2019-06-24 08:19:36
tags:
- 操作系统
- ucore

category:
- 操作系统
- ucore
---

## 2019.6.24
开始着手操作系统的学习和开发，需要了解的知识有很多很多，需要了解linux开发环境，包括linux命令、shell脚本、linux下的编译器gcc的使用（包括gcc的编译选项、makefile的使用、gcc混合编译——内联汇编——c和汇编），还有C语言的细节，结构、函数指针，还有算法、数据结构，还有硬件底层的知识，x86下CPU的工作模式，实模式和保护模式，mmu内存管理硬件单元，分段分页，特殊寄存器，中断处理。操作系统一般都是一个较大型的项目，能够锻炼大型项目的编程能力。一定要坚持下来，可能知识会多一点，但是学到的东西一定会更多！

接下来要一步一步来，首先要把基础学好，linux命令行和shell脚本编程以及gcc、makefile的使用，第一步首先弄清楚ucore整体的编译过程，它用到了linux和gcc makefile的细节都要搞清楚，并做好笔记。

然后开始进行操作系统内核的开发，了解操作系统的硬件基础、内核的工作原理。

然后在进行操作系统顶层的开发。

完成了这些之后，综合内核和已有的库进行扩展，进行网络协议实现等基础设施的建设，希望最终能做出一个带图形界面的完整移动操作系统！

## 问题记录
### gnu ld链接器的工作原理？
1. 如何进行链接？
2. 链接后的地址如何分配？链接指定的地址有什么用，例如0x7c00？
3. 链接后生成的文件的格式？格式各部分和操作系统的关系？
4. linux上的可执行文件和生成的在硬件上的可执行文件（例如bootloader和操作系统内核）的区别？

### 如何使用objdump、objcopy等工具？
1. objdump等工具用于什么对象？
2. 这些工具有哪些作用？

### 汇编语言的知识？
1. 代码段？数据段？和操作系统还有硬件的关系？
2. .code16和.code32的细节？
3. lgdtr的细节？
4. .long .word的细节？

### GCC下如何编译.s文件？
和编译.o文件一样，直接使用gcc命令，编译得到.o文件。将汇编得到的.o文件和c得到的.o文件进行链接，可以生成可执行文件。这样就能将C和汇编混合编译。在汇编中能够直接使用C函数名作为标签名，链接后会找到C文件中对应的函数。

### BIOS提供的功能和作用？
1. 它会被加载到内存中吗？
   会被加载到内容中，计算机加电以后会将BIOS的内容加载到内存中。CPU调转到内存中BOIS开始的位置执行。
2. 操作系统对硬件的控制和访问与BIOS有关吗？还是BIOS仅用于系统初始化阶段？
   有关，BIOS是一系列程序的集合，系统初始化的BIOS程序只是其中一个，对于不同的硬件，都有与其对应的BIOS程序。**这里还是不太懂**

### 操作系统如何提供对硬件的保护？
1. 是通过分段机制对特定指令的保护吗？
   是的，IO地址的访问也有优先级，称为IOPL，只有当前代码的优先级高于IO地址优先级时（CPL<=IOPL）才能访问。
2. 如何避免应用层程序直接访问硬件？
   应用层程序运行在特权级为3的情况下，IOPL一般是0，只有内核能访问。通过分段的优先级控制就能够防止应用层程序访问硬件。

### ELF格式的细节？
1. elf文件结构？如何解析？
2. elf内各段（segment）各节（section）的区别和联系？
   segment是将多个section放在相同的段中，便于内存管理。section是指.data、.text、.bss等不同的程序节。

### 如何编写自己的bootloader程序？
1. 相关指令、相关IO端口的作用？
2. intel 80386指令、AT&T语法汇编知识？
3. 实模式到保护模式的切换实现？
4. 操作系统的加载实现？

### 如何初始化中断、键盘、显示器等等设备？
1. 总线如何处理？
2. IO端口如何处理？
3. 中断如何处理？
4. 在i386模拟上实现并总结其原理。


### 分段模式如何识别不同的段？
1. 如何识别段栈段和数据段，指令一条指令，怎么判断指令中的寻址使用的是哪一个段选择符？
   在访问内存的时候才涉及到段选择器的问题。intel 80386有默认的使用段寄存器的方式（在intel 80386参考文档的2.5节），当只指定的偏移，没有指定段寄存器的时候，按照下面的规则使用段寄存器：
   * 指令预获取、指令调转等等指令，使用CS
   * 使用ESP、EBP作为基址寄存器访问内存的时候，使用SS
   * 栈操作命令push、pop等，使用SS
   * 字符串指令，使用ES
   * 不在上面情况中的，使用DS
2. 不同的段是不是有不同多地址空间？
   是的，一个段就是一个独立的地址空间。GDTR存储了GDT的基址，段寄存器*8+GDTR就是选择符的地址，选择符中有段的基址和偏移。段的基址是线形地址，就是说，这个基址不需要在经过分段基址的转换，直接由基址+偏移得到线形地址。
3. 段和编译器得到的.text和.data等是不是有什么关系？
   是等价的，不过.text和.data肯定分别放在CS和DS中，但是DS中不仅仅有.data。

### 如何实现不同的进程之间的内存隔离？
1. 分段基址的物理空间重叠怎么处理？


## milestone
* 2019.11.04 开始进行ucore-os的开发和学习
* 2019.11.21 完成对C语言基础知识的复习，也学习了更多的计算机基础相关的知识，例如字节对齐、大端小端、字节序、字符编码等知识。
  * 未完成1：C语言高级语法总结、GCC扩展（内联汇编等等特性）
  * 未完成2：标准库的使用，包括文件io、并发编程、内存分配等等
* 2019.11.26 完成对Makefile的分析
  * 了解了make的基本语法，ld、gcc选项。
  * 了解了ucore.img镜像的构建过程。主要学习make语法、如何编写makefile、以及gcc、ld编译的一些选项等。
  * 了解了bootloader的结构