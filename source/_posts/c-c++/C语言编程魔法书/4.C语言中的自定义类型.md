---
title: 4.C语言中的自定义类型
date: 2019-11-13 20:38:45
tags:
- 编程语言
- C语言
- 《C语言编程魔法书》

category:
- 编程语言
- C语言
---
这篇文章学习C语言中的自定义类型。自定义类型能够将一些数据抽象化，将信息组织成我们更容易理解的模型。

## 枚举类型
枚举类型用于表示离散有限个数据对象。通过枚举来表示一系列状态的集合。声明方式如下：
```c
enum Name {
  a,
  b,
  c
}

enum LIGHT;

enum TRAFFIC_LIGHT {
  TRAFFIC_LIGHT_RED, // 0
  TRAFFIC_LIGHT_GREEN, // 1
  TRAFFIC_LIGHT_YELLOW // 2
};

enum LIGHT {
  RED = -2,
  ORANGE, // -1
  YELLOW = 1,
  BLUE, // 2
  INDIGO = RED - 100, // -102
  PURPLE // -101
};
```

LIGHT称为枚举类型，RED称为枚举符或者枚举常量，枚举常量可以赋整数值，可以在任意位置赋值，如果当前枚举符没有赋值，那么其值是前一个+1。

### 声明和使用枚举
```c


enum LIGHT;

enum TRAFFIC_LIGHT {
  TRAFFIC_LIGHT_RED, // 0
  TRAFFIC_LIGHT_GREEN, // 1
  TRAFFIC_LIGHT_YELLOW // 2
} g_traffic;

static enum LIGHT {
  RED = -2,
  ORANGE, // -1
  YELLOW = 1,
  BLUE, // 2
  INDIGO = RED - 100, // -102
  PURPLE // -101
} s_light = BLUE;

// 匿名枚举
enum {
  ONE = 1,
  TWO,
  THREE,
  FOUR,
  FIVE,
  SIX
} g_dice = TWO;

int main() {
  enum TRAFFIC_LIGHT traffic = TRAFFIC_LIGHT_YELLOW;
  g_traffic = TRAFFIC_LIGHT_GREEN;

  // 枚举类型可以进行算术运算，也能赋值给整型变量
  g_traffic += 2;
}
```
要点：
* 能够在枚举定义后面直接接变量定义并初始化。
* 枚举符能够全局访问，不用加前缀
* 声明枚举变量需要添加enum
* 枚举可以先声明后定义


## 结构体类型
结构类型中可以存放任意类型的数据。

### 代码示例
```c
#include <stdio.h>
#include <stdint.h>

// 声明结构体
struct StructTest;

enum MyEnum {
  MY_NUM1,
  MY_NUM2
};

struct MyStruct {
  int32_t a;
  enum MyEnum e;
  double d;
  struct StructTest* pTest;

  _Static_assert(MY_NUM1 == 0, "NG");
};

// 定义结构体
// 注意这里的内存分布，s占两个字节，m占24个字节（4+4+8+8=24，按照8对齐，刚好），i占12个字节（4+4+4=12，按照4对齐，刚好），一共占2+24+12 = 38字节，但是StructTest中最大成员对齐是12字节，所以按照12字节对齐，对齐到48字节，所以StructTest大小是48字节。
struct StructTest {
  int16_t s;
  struct MyStruct m;

  struct {
    int32_t a,b;
    float f;
    ;
  } i;
};
```
C语言中可以定义匿名结构体。

要点：
* 可以先声明后定义
* 可以使用静态断言
* 可以定义匿名结构体声明语句
* 可以定义其他任何类型

### 对结构体的使用
```c
int main() {
  // 没有初始化，值都是不确定的，可能是内存中的任意值，包括里面的指针也可能指向不确定的地址
  // struct MyStruct m;
  struct MyStruct m = {64,MY_NUM2,64.2,NULL};

  // 非指针类型使用.访问成员，指针类型使用->访问
  printf("%d %f\n", m.a, m.d);

  // 这里将结构体m赋值给st.m，非指针的结构体能够直接赋值
  // 等价于分解为逐个成员赋值（显然，对于指针类型赋值的指针指针，并不会深拷贝，非指针类型会深拷贝）
  // 但是赋值次序不一定
  struct StructTest st = { 16, m, {32, 32, 2.00}}; // 可以嵌套大括号赋值，{}称为初始化器列表
  // 使用大括号显示初始化结构体
  struct MyStruct m2 = { 32, MY_NUM1, 1.0, &st};

  printf("%d %d %f\n", st.m.a, st.s, st.i.f);

  // 可以仅仅对部分结构体成员赋值，其与成员自动赋值为0
  struct MyStruct m = {64,MY_NUM1};
}
```
要点：
* 没有初始化结构体，可能拿到内存中的任意值
* 成员访问使用.和->
* 可以直接将非指针赋值，会自动拷贝内容
* 可以使用初始化器初始化，可以嵌套{}，初始化器中可以通过`.对象名 = 值`来指定对哪个成员进行初始化，如果没有指定按顺序赋值。
* 可以部分赋值，未赋值部分初始化为0
* 只能在初始化的时候使用{}初始化器进行初始化，如果已经定义了，那么可以考虑使用下面的复合字面量赋值，c99及以上支持。
* **如果结构体定义的匿名结构体没有声明成员对象，那么匿名成员会称为外部结构体的成员**


### 结构体复合字面量
定义:
```c
struct S s = (struct S){.a=100,.b=-50};
```
相当于结构体字面量的类型投射。

## 联合体类型
联合体和结构体的声明类似，区别是联合体的所有成员共享同一块内存区域。

### 结构体和联合体的内存分布
联合体所占的内存由其成员的最大内存决定，所有成员共享这一部分内存。

而结构体所占的总内存是字节对齐后的总大小。对于下面的struct和union，内部分布：
```c
struct {
  int8_t a;
  int16_t b;
  int32_t c;
} s = { 0, 1, 2 };

struct {
  int8_t a;
  int16_t b;
  int32_t c;
} u = {0,1,2};

// 内存分布如下：
//            c  b a
//         --------
// struct 8   4  2 0
// 未对齐前7个字节，对齐后8个字节，填充的1个字节在a上
//
//       a
//    b
// c
//  ----
// 4  210
// a占0字节，abc共享0字节，bc共享0，1字节，c独占2，3字节。
```
我们看到联合中最多对其中一个成员赋值，因为内存会相互影响。

要点：
* 联合和结构一样，其成员可以是任意内容
* 与结构不同，初始化列表只能有一个元素。可以用.成员的方式表示初始化哪一个成员。

```c
#include <stdio.h>
#include <stdint.h>

int main() {
  union MyUnion {
    int32_t a;
    struct {
      int16_t b;
      int8_t c;
    } s;

    float f;
  } un = {.s.b=0x0201, .s.c=0x03};

  union MyUnion un2 = {100};

  union MyUnion un3;

  // 存储为规格化浮点数的二进制表示
  un3 = (union MyUnion) { .f = 10.5f };

  // 输出0x**030201，前两位没有赋值，可能是任意值，这一点在linux 64，gcc 8.3下和struct不一样，不会置0
  // 因为s.b和s.c占前三个字节，所以前三个字节赋值了，a占4个字节，数组的是4个字节
  printf("un.a = 0x%.8x\n", un.a);

  printf("un2.s.b = %d\n", un2.s.b);

  // 联合体存的是浮点数的规格化二进制表示
  // 这里(int32_t)*(float*)&un3.a的意思是，用浮点指针指向un3.a的地址，该地址的内容读取的时候就会按照浮点数读取
  // 然后*对浮点指针取内容，取到的内容在转换成int32_t。
  // 相当于读取浮点数并转为整形，所以结果是10；浮点数转整数直接去掉小数
  printf("un3.a = %d un3.f = %f %d\n", (int32_t)*(float*)&un3.a, un3.f, (int32_t)*(float*)&un3);

  printf("%f == %x\n", (float*)&un3, &un3.a);

}
```

## enum、struct、union小结
* 表示自定义类型时，都需要加上enum、struct、union前缀；例如`struct MyStruct`
* 可以先声明后定义
* 可以不初始化，此时内容是不确定的脏数据
* 可以在定义后面直接声明变量并初始化，可以使用匿名定义
* 可以使用初始化列表初始化；或者使用复合字面量初始化
* struct的内存模式是成员大小叠加并字节对齐；union是所有成员共享一片内存，内存大小是最大成员的大小。
* enum的成员只能是整数

## 位域
通过位域，可以将一串比特流进行结构化描述，在通信领域用得尤为广泛。C语言的位域时在结构体或者联合体中指定位宽的成员。通常我们采用结构体来指定位域。**位域成员可以和普通成员混合**

**结构体的成员要作为位域，必须是整数类型。指定宽度的位宽表达式应该也要是一个整数常量表示式，且不能为负。**

```
<类型> <标识符> : <位宽表达式>
```
`<位宽表达式>`用于指定此位域的宽度，单位是bit。**表达式的值必须是编译时能够确定的常量，例如整数字面量、sizeof操作符的结果、枚举值等**

> 注意：sizeof后面接数据类型或者表达式的值都是编译时常量，但是接数组不是，不管数组是不是变长数组

```c
struct BitField {
  int32_t a : 5; // 5 bit，值范围[-16, 15]
  uint32_t b : 6;
  int32_t c : 7;
}
```
上例中的a和c都是带符号整数，所以a、c最高位作为符号位。上面总共是18bit，少于4字节，按照4字节对齐。编译器会自动扩充到4字节。

C语言对位域的限制：
* 不能对位域成员做取地址操作
* 位域成员不能作为sizeof的操作数
* 不能用对齐属性来修饰位域
* 指定位域宽度的常量值不能超过该类型可表示的范围，例如char类型，位域宽度不能大于8。否则编译器会报错。

### 位域的内存布局
先看一个示例：
```c
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>

int main() {
  struct {
    int32_t a:5;
    int16_t b:6;
    int32_t c:7;
  } s = { 1, 2 , -1};

  printf("%zd %d %u %d\n", sizeof(s), s.a, s.b, s.c);
  // 输出4 1 2 -1。总共18个字节，一般编译器实现会将其对齐到4字节。

  enum MyEnum {
    ENUM1,
    ENUM2,
    ENUM3
  };
  
  struct MyStruct {
    int32_t a : 6;
    int16_t b : 5;
    int8_t c : 8;

    char x : sizeof(enum MyEnum);
    bool y : 1;

    enum MyEnum e : ENUM3;
  } s2 = { 0x18, 0x0a, 0x77, '\0', true, ENUM3};
  printf("The sizeof %zu\n", sizeof(s));

  // 以16进制输出MyStruct的内存分布
  int32_t *temp = (int32_t*)&s2;
  
  printf("%x\n", *temp);
  // 输出结果是50770298，换成2进制是
  // (0)101 0000 0111 0111 (0000 0)010 1001 1000
  // 然后再查看MyStruct中的位数，分别是2 1 4 8 5 6(从高到低).
  // 二进制前6位是 011000（0x18，对于a的赋值），6-11是 01010（0x0a，对应b的赋值）
  // 后面接5个0，这5个0是填充的，然后接下来8位是0111 0111（0x77对应c的赋值），以此类推
}
```
上例中我们以二进制的形式输出了MyStrcut的内存分布，括号中的比特序列是填充的bit，如何填充bit不同的编译器不一样。**但是C语言指明，对于同一个结构体内相邻的两个成员，如果第一个位域成员仍有位置容纳第二个位域成员，那么第二个位域成员可以与第一个位域成员打包在一起**。例如上例中的a和b合起来是11个bit，存放在连续的11个bit中。

如果构成一个单元的存储空间不够，那么后一个位域放在下一个存储单元还是与之前的单元迭交存放，这是由实现自己定义的。如何字节对齐也是标准未定义的。

示例中c占8个bit，前面11个bit，如果与前面相邻就超过了16bit寻址单元（只能按照字节寻址），GCC 8.3将其移到了后一个寻址单元，填充了5个bit的0。在当前C语言的实现中，采用从低位序到高位序的排列方式。

加入我们将c改成5bit：
```c
 struct MyStruct2 {
    int32_t a : 6;
    int16_t b : 5;
    int8_t c : 5;

    char x : sizeof(enum MyEnum);
    bool y : 1;

    enum MyEnum e : ENUM3;
  } s4 = { 0x18, 0x0a, 0x09, '\0', true, ENUM3};
  printf("The sizeof %zu\n", sizeof(s));

  // 以16进制输出MyStruct的内存分布
  int32_t *temp2 = (int32_t*)&s4;
  
  printf("%x\n", *temp2);
  printf("%zu\n", sizeof(struct MyStruct2)); // 输出4
  // 输出结果是504a98，换成2进制是
  // (0000 0000 0)101 0000 0100 1010 1001 1000
  // 然后再查看MyStruct中的位数，分别是2 1 4 5 5 6(从高到低).
  // 二进制前6位是 011000（0x18，对于a的赋值），6-11是 01010（0x0a，对应b的赋值）
  // 后面接01001，是c的值（0x09），这里能够直接填充满16bit
  // 最高位填充0到4字节
}
```
6+5+5刚好凑成两字节，中间就不会再填充0了。

> 如何确定相邻的位域成员放在哪些寻址内存中呢？一般C语言实现先将第一个和第二个位域成员先拼接在一起，如果能够拼接成功，向上取满足$2^n$的最小整数。然后再看第三个位域成员，如果拼接起来不大于最小寻址单元（例如上例中的int32_t和int16_t，最小寻址单元是16bit，11+8=19超过了16），那么第三个成员也放在这个区域中，以此类推。如果大于，一般会将其放到下一个可寻址单元中，中间bit用0填充。

如何分配位域的bit分布和位域成员的类型是有关系的。如果位域成员类型能够完全容纳下所有的位域，则中间不会填充，看示例：
```c
struct MyStruct3 {
    int32_t a : 6;
    int32_t b : 5;
    int32_t c : 8;

    char x : sizeof(enum MyEnum);
    bool y : 1;

    enum MyEnum e : ENUM3;
  } s6 = { 0x18, 0x0a, 0x77, '\0', true, ENUM3};

  // 以16进制输出MyStruct的内存分布
  int32_t *temp3 = (int32_t*)&s6;
  
  printf("%x\n", *temp3);
  printf("%zu\n", sizeof(struct MyStruct3)); // 输出4
  // 输出结果是283ba98，换成2进制是
  // (0000 00)10 1000 0011 1011 1010 1001 1000
  // 然后再查看MyStruct中的位数，分别是2 1 4 8 5 6(从高到低).
  // 二进制前6位是 011000（0x18，对于a的赋值），6-11是 01010（0x0a，对应b的赋值）
  // 后面接0111 0111，是c的值（0x77）...
  // 我们看到int32_t能够放下所有的位，那么中间不会填充，只有高位填充到了4字节
```

### 匿名位域
在C11标准中，当某个位域只给出其类型和宽度，而不给出标识符名时，该位域称为匿名位域。**匿名位域一般用作比特填充（一般填充0）**

当匿名位域的宽度为0的时候，表示该位域是前面位域所组成的存储区域的末尾，即左为一个结束标识而使用。该存储区域的后续比特被填充，其下面的位域都将作为一个新的存储区域。（意味着宽度为0的匿名位域可以强制结束位域存储区域）。

```c
struct {
    int32_t a : 8;
    // 该存储单元所在的整个区域后续都将用0填充
    int32_t : 0;
    // int16_t : 0； // 存储单元缩小到2字节，后续填充0

    // 放在下一个存储单元
    int32_t b : 16;
    int16_t x : 8;
    int16_t y : 8;
  } t = { 0x10, 0x4321, 0x65, 0x76 };

  // 输出：t is 0x7665432100000010
  // 前面都是int32_t，所以第一个存储单元是4字节，除了第一个字节，后面都填充0
  // 如果将int32_t:0改成int16_t:0那么只填充一个字节，因为单元是两个字节，同理改成int8_t，不填充
  // 改成int64_t呢？发现后面4个字节也被填充0了，b、x、y被放到了后面的(a+8)byte的位置了
  // 后面4个字节完全存满，位域刚好32bit
  printf("t is 0x%16llX\n", *((uint64_t*)&t+1));
```

通过观察发现，宽度为0的匿名位域，其数据类型的宽度是多少，就会填充多大的空间。如果其宽度比前面的存储单元宽度（上例是int32_t）大，那么将前面的存储单元扩大，并在后面填充0。如果小于存储单元宽度，那么将存储单元缩小（最小是位域宽度），并将缩小后的后续填充0。


### 位域使用
在实践中，我们将需要拼接在一起的位域成员用相同类型或相同字节宽度的类型毗邻排放，这样可以避免一些不必要的比特填充。

```c
struct Student {
  uint32_t grade : 2;
  uint32_t class : 4;
  uint32_t number : 7;
  
  uint32_t weight : 7;
  uint32_t height : 8;

  uint32_t isMale : 1;
  uint32_t age : 3;
};
```
上面的示例中有两点：
1. 都是用uint32_t，这样可以将存储单元设置成32位，使用4个字节就能够存下来所有的信息
2. 因为4字节能够存下所有信息，所有bit都是相邻存放的，没有字节填充
   
这样利用位域可以做到bit控制（在计算机网络协议中尤其有用），同时节省空间。像java不支持位域，最小单位是byte，占1个字节，最少需要7个字节来存储。