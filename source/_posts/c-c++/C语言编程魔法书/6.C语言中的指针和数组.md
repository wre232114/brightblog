---
title: 6.C语言中的指针和数组
date: 2019-11-18 12:03:52
tags:
- 编程语言
- C语言
- 《C语言编程魔法书》

category:
- 编程语言
- C语言
---
本文首先学习C语言中的数组，再学习指针以及指针和数组的关系，再学习字符串字面量，最后学习C语言的完整类型和不完整类型。

数组和结构体一样，属于**聚合类型**。

## 一维数组
形式：
```c
<类型名> <标识符>[<数组元素个数>]
```
> 注意：C99之前，数组元素个数必须是一个整数常量表达式。C99之后可以是一个运行时计算的整数表达式。

如果`数组元素个数`是一个变量，那么该数组又称为变长数组。

> 注意：sizeof能正确计算数组的长度，但是是在运行时计算，不管是不是变长数组

### 访问数组元素
使用：`标识符[index]`形式，例如`arr[0]`，index从0开始，表示访问数组的第一个元素。

> 注意：C语言的数组长度没有办法从数组中知道（除非自行用数组元素记录，不像js或者java有length数组。只能自己用额外的变量记录

数组对象可以使用{}初始化列表。如果初始化列表中的数量小于数组长度，那么剩余部分填充0。C99开始可以指定数组下表来初始化数组，如果没有指定，那么按顺序赋值。

> 通过 `{ [1] = 10.5f, [3] = 6.0 }`这种形式可以对特定的下标赋值，未赋值的部分是0。这种形式和结构体还有联合体的成员赋值类似，区别是结构体使用`{ .成员名 = 值 }`的形式

初始化列表中的元素不仅仅可以是常量，还可以是运行时求值的表达式：`int32_t b[] = { c[0], c[1], c[2] }`。还注意到指定了初始化列表，可以不指定`数组元素个数`，`数组元素个数`会自动计算。

```c
#include <stdio.h>
#include <stdbool.h>
#include <complex.h>
#include <stdint.h>

int main() {
  char c[2*2+1] = { 'a', 'b', 'c', 'd', 'e' };
  for(int i = 0;i < 5;i++) {
    printf("%c ", c[i]);
    if(i==4) printf("\n");
  }

  // 可以添加额外的逗号，未赋值的部分置0
  int32_t a[4] = { 100, -1, };
  for(int i = 0;i < 4;i++) {
    printf("%d ", a[i]);
    if(i == 3) printf("\n");
  }

  // 对第二个和第四个元素赋值，其他为0
  float f[5] = { [1] = 10.5f, [3] = -0.5f };
  for(int i = 0;i < 5;i++) {
    printf("%.2f ", f[i]);
    if(i == 4) printf("\n");
  }

  // 这里注意几个点：
  // 1. 赋值默认从0开始，后面递增+1，所以s[0] = -1, s[1] = 2
  // 2. 没有指定下标的元素，序号是上一个序号+1，所以s[5] = 20
  // 赋值后的数组是[-1,2,0,10,1,50,5];
  int16_t s[] = { -1, 2 ,[3] = 10, [6] = 5, [4] = 1, 20 };
  for(int i = 0;i < 7;i++) {
    printf("%d ", s[i]);
    if(i == 6) printf("\n");
  }

  struct T {
    int32_t a, b;
  };

  // 下面是一个更复杂的赋值示例，一个结构体数组的赋值
  // 如果没有使用{}，列表中的值依次赋给结构体成员，下例中的10赋给[0].a，20赋给[0].b
  // 使用[1] = { 1, 2 }
  // 还可以结合使用[2] = { .a = -1, .b = -2 }
  // 还可以使用[3].a = 4, [3].b = 5
  struct T t[] = { 10, 20, { 1, 2 }, [2] = { .a = -1, .b = -2}, [3].b = 4, [3].a = 5 };
  for(int i = 0;i < 4;i++) {
    printf("[%d]: %d %d\n", i, t[i].a, t[i].b);
  }
}
```

### 注意点
**数组类型和其他类型不同，不能直接将一个数组对象直接赋值给另一个数组对象，即便初始化的时候也是这样。**

结构体可以直接赋值，成员会自动拷贝，但是数组不可以。如果想引用数组，使用指针。如果想拷贝数组，可以使用`<string.h>`中的`memcpy函数`。

通过**数组的字面复合量**可以表示一个匿名数组，但是不能用于初始化，gcc下会报错。

> memcpy(void* dest, void* source, size_t n)，从source地址拷贝到dest地址n个字节。看下面的例子：
```c
#include <stdio.h>
#include <stdint.h>
#include <string.h>

int main() {
  int c[10] = { 0, 1, 2, [6] = 20, [8] = 100 };
  int d[10];

  // 注意，数组的标识符d、c可以当作一个指针，指针的值是d、c数组的起始地址
  // 传给memcpy(d, c, sizeof(c))，会将指针值传过去，其值是地址，所以不需要在使用&d
  memcpy(d, c, sizeof(c));
  for(int i = 0;i < 10;i++) {
    printf("%d ", d[i]);
    if(i == 9) printf("\n");
  }

  // d的最后三位被设置成了7,9,8
  memcpy(&d[7], ((int []){7, 9, 8}), 3 * sizeof(int));
  for(int i = 0;i < 10;i++) {
    printf("%d ", d[i]);
    if(i == 9) printf("\n");
  }
}
```

## 多维数组
形式如：`int[2][3]`表示含有两个`int[3]`类型的的数组。习惯上我们也称为两行散列的int类型元素的数组。

内存模型如下：
```
                   -> 0
a -> 0 -> (int[3]) -> 1
                   -> 2

                   -> 0
  -> 1 -> (int[3]) -> 1
                   -> 2
```
在内存中二维数组也是线性存放的，例如`a[0][0] a[0][1] a[0][2] a[1][0]...`

如果是`int a[2][3][4]`，表示两个`int[3][4]`型的数组。多维数组就是数组的元素还是数组。

sizeof也可以输出多维数组的大小。
```c
#include <stdio.h>
#include <string.h>

void print_matrix(int a[][3], int n);

int main() {
  // 数组初始化列表进行初始化
  int a[2][3] = {
    { 1, 2, 3 },
    { 4, 5, 6 }
  };

  // 也可以扁平化的初始化
  int b[2][3] = { 1,2,3,4,5,6 };
  print_matrix(a, 2);
  // 2*3*4 = 24
  printf("sizeof a is %zu\n", sizeof(a));

  // 声明二维数组的时候并初始化的时候，第一个数组长度可以省略，但是第二个不行，如果想都省略，使用指针
  int c[][3] = {
    [0] = { 1, 2, 3 },
    [2] = { 4, 5 },
    [3][0] = a[1][1], [3][2] = 7
  };

  print_matrix(c, 3);

  // 不能使用匿名数组初始化，gcc下会报错
  // int e[][3] = (int[][3]) {
  //   {1,2,3},
  //   [1] = {4,5,6},
  //   {7,9,9}
  // };
  // print_matrix(e, 3);
}

void print_matrix(int a[][3], int n) {
  for(int i = 0;i < n;i++) {
    for(int j = 0;j < 3;j++) {
      printf("%d ", a[i][j]);
    }
    printf("\n");
  }
}
```

### 高维数组
除了二维数组，还可以有三维、思维等等数组。具体能到多少维是实现定义的。

声明三维数组：`int a[2][3][4]`。


## 变长数组
C99引入可变长数组。这类数组声明是不是通过常量来声明的，而是通过变量。有以下限制：
* 变长数组不能在文件作用域中声明
* 不能使用static修饰符来修饰
* 指向变长数组的指针以及变长数组统称为`可变修改类型`，该类型作为sizeof的操作数时，在运行时计算
* 变长数组声明后不能直接通过初始化列表初始化，只能通过memcpy或者逐个赋值
* gcc 中const作为数组长度，也会当作变量


```c
#include <stdio.h>

int main() {
  int a = 5;
  int b[a];

  a++;

  printf("b size is %zu\n", sizeof(b));

  int x = 0;

  int (*p)[a] = &b;
  printf("p[0] size is : %zu\n", sizeof(p[++x]));
  printf("x = %d\n", x);
  // x = 1，sizeof(p[++x])是可变类型，在运行时得到，有副作用

  // gcc 中const作为数组长度，也会当作变量
  // const int n = 10;

  // int d[n] = { 1, 2, 3 };

  // int (*q)[n] = &d;

  // x = 1，这里sizeof(b[++x])在编译时确定，没有副作用
  printf("q[0] size is : %zu\n", sizeof(b[++x]));
  printf("x = %d\n", x);
}
```
> 注意：如果sizeof是在编译时计算的，那么不会产生副作用，例如`sizeof(b[++x])`，即便b时可变类型，但是`b[index]`是int，不是可变类型，所以++x不会产生副作用。但是同样指向数组的指针会有副作用


## 一级指针与对象地址
C中只要是一个存储对象，就能取地址。

通过&来取地址，例如对于`int a;`，`&a`表示取a的地址。无论在文件作用域还是语句块作用域中，都能取到地址。

在32位系统下拿到的地址是4字节，64位系统下拿到的是8字节。**桌面程序中拿到的都是虚拟地址，而不是真实的物理地址，由操作系统和硬件负责将虚拟地址转成真实的物理地址，我们不需要关心**。一些简单的嵌入式环境中可以拿到真实的地址。

C语言用**指针**来存储地址。使用`int* p`来声明指针，在正常变量声明前加一个`*`。需要注意，指针的长度就是地址的长度，32位系统下是4字节，64位系统下是8字节。那反正指针都是8字节，`int* p`和`double* p`有什么区别呢？区别在于如何解释所在地址的内容。指针存的只是一个起始地址，`int *p`表示指针指向的地址中，存的是一个int型的值，如果对指针取值，这时编译器会取`起始地址`到`起始地址+4`内存区间中的值并将其作为int类型返回。

```c
#include <stdio.h>
#include <stdint.h>

int main(int argc, const char* argv[]) {
  int a = 10;

  int *p = &a;

  // 一个指针对象可以转为一个无符号整数类型来观察该指针对象的值
  // 不过一般用uintptr_t来表示一个对象地址的值
  printf("p value is 0x%.16tX, size is: %zu\n", (uintptr_t)p, sizeof(p));
}
```
我们指针的值是地址，但是我们只有将指针对象转为整数，一般是`uintptr_t`，才能正确看到地址的值。

### 访问指针对象所指对象的内容
通过`*`可以间接访问指针指向地址中的值，例如`*p`。

```c
#include <stdio.h>
#include <stdint.h>

int main(int argc, const char* argv[]) {
  int a = 10;
  int *p = &a;

  printf("a = %d\n", a);
  // a变成了20，因为p指向的是a的地址

  // *p表示p指向的内存中的值，可以读写该值
  *p = 20;
  short b = *p;
  *p = 10;
  // b拥有自己的地址，只是将a地址中的值赋值给了b，再改变a不影响b
  printf("b = %d\n", b);
}
```

### 指针的比较和取地址
指针的比较就是指针指向的地址值的比较，可以比较相等，比较大小。

指针类型之间的相互转换，必须强制转换，例如`(int*)p`，强制指针转换在读取值的时候可能会出现问题，例如原来是`int*`，转成`long long*`，指针取值的那么会多读内存中的4个字节，这可能导致地址空间溢出。

只能对左值取地址，而对于右值不能取地址。右值是一个表达式的值，例如sizeof返回的值，整数字面量等。

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

int main() {
  int32_t a = 10, b = 5;


  int32_t *p = &a, *q = &b, c = 0, *r = &c;

  // 指针可以比较大小
  bool e = p > q;
  printf("Is p > q? %d\n", e);

  e = p == r;
  printf("Is p equal to r? %d\n", e);
  printf("Is r equal to &c? %d\n",  r == &c);

  int16_t s = 1, *t = &s;
  t = &a; // 这里会出现警告，因为指针不会隐式转换
  t = (int16_t*)&a; // 只能强制转换
  *t = 2048;

  // 对于匿名数组，匿名结构体可以取地址
  int32_t (*pa)[3] = &(int32_t[]){1, 2, 3};
}
```

## 多级指针
多级指针用于表示指针的地址，例如：
```c
int a = 10;
int *p = &a;
int **pp = &p;
```
上例中，指针p存了a的地址，二级指针pp存了指针p的地址。那么我们取内容的时候，`*pp`拿到的是指针p的值，就是a的地址，`**pp`拿到是a的地址的值，就是10。地址指向关系如下：
```
地址  低----->高
int a---------int*p--------int**pp---->
  |              |              |
  |          =p的地址----------- 求值
  |              |
=a的地址--------- 求值
  |
求值 = 10

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

int main() {
  int32_t x = 10, y = 20;

  int32_t *p = &x, *q = &y;
  int32_t **pp = &p;

  // pp的值指向的内容是p的值也就是&x
  bool b = (uintptr_t)*pp == (uintptr_t)&x;
  printf("b = %d\n", b);

  // *pp是指针p的值，赋值q，所以p == q
  *pp = q;
  printf("p == q? %d\n", p == q);

  **pp = 30;// **pp是a的值，a的值变成了30
}
```

## 指向用户自定义类型的指针
指向用户自定义类型的指针和普通的指针差不多。只是变一下类型。需要注意的是对结构或者联合体成员的访问。

如果是指针，那么需要使用`->`来访问结构体成员。例如`(s->a)`，当然也可以使用`(*p).a`。

注意二级指针的使用，例如：
```c
struct S **pp = &p;

(*pp)->a = 10;
(**pp).a = 10;
```
不能直接使用`pp->a`。

## 数组和指针之间的关系
C语言中数组可以隐式转换成指针。

C语言规定，除了sizeof、_Alignof、单目&之外，表示数组类型的表达式会被转换成指针，而该表达式的值指向数组第一个元素的地址。

指针也能做整数加减法，但是和普通的加减法不一样，**指针的加减法表示地址偏移，而且和类型相关**。例如`int* p`，假设p指向的地址是`a`，那么`p+1`，指向地址`a+4`，因为int大小是4字节。

*(p+1)可以也写成p[1]。指针的偏移地址取值和数组类似。

## 指向数组的指针
数组可以直接赋值给一个指针，例如：
```c
int a[10];
int *p = a;
```
也可以使用指向数组的指针，如下：
```c
int a[10];
int (*pa)[10] = &a;
```
我们知道在这里数组a其实就是一个int*的指针，那么对其取地址就是指针的指针了。要访问a的元素需要通过`(*pa)[i]`或者`pa[0][i]`来访问。

那么`int (*pa)[10]`该怎么理解呢？指向数组的指针，也就是指针指向内容是一个数组，所以指针pa指向的是数组的地址，`(*pa)`是一个数组。如果要访问数组的内容，就需要使用`(*pa)[i]`

**`int (*pa)[10]`的类型是`int(*)[10]`**

```c
#include <stdio.h>

int main() {
  int a[] = { 1, 2, 3, 4, 5 };

  int *p = a;

  int (*pa)[5] = &a;
  printf("size of pa is: %zu\n", sizeof(pa));
  // 输出8，因为pa是一个指针

  printf("size of (*pa) = %zu, sizeof (*p) = %zu\n", sizeof(*pa), sizeof(*p));
  // 输出(*pa) = 20 (*p) = 4
  // 因为(*pa)是int[5]，而*p是int

  int sum = 0;

  for(int i = 0;i < 5;i++) {
    sum += (*pa)[i]; // 括号不能省略
  }
  printf("sum = %d\n", sum);

  int b[3][5] = {
    {1,2,3,4,5},
    {6,7,8,9,10},
    {11,12,13,14,15}
  };

  // pa是指向数组的指针，所以(*pa)是指向b[0]，其值是一个数组
  // *(pa+1)指向b[1]，其值也是一个数组
  pa = b;
  pa[0][0]++;
  (*(pa+1))[0]--;

  // 表示p的类型是int (*)[2][3]，即指向二维数组的指针
  int (*p)[2][3] = &a;
  // 是一个指针，大小是8字节
  int a = sizeof(int (*)[2][3]);  
  // 表示p的类型是int (*)[2]，指向一维数组的指针
  int (*p)[2];
}
```
> 三种指针：
>
> 1. 指向数组元素的指针：`int *p = a`，指针指向的是数组元素，类型是`int *`
> 2. 指向数组的指针：`int (*pa)[5] = &a`，指针指向的是数组，类型是`int (*)[5]`；指向二维数组的指针是`int (*pa)[2][3]`，类型是`int (*)[2][3]`。那么问题来了，指向数组的指针的数组呢？`int (*pa[3])[2]`，表示长度为3的成员类型为`(int*)[2]`的数组，类型是`int(*[3])[2]`
> 3. 指针的数组：`int* a[10]`，是一个输出，数组元素是指针，类型是`int*[10]`

## void类型
void一般用于函数返回类型以及空的表达式形参，**也可以作为表达式的类型**。

具有void类型的表达式称为`void表达式`，通过(void)expression，将表达式转为void类型。`void表达式`有以下规则：
* void表达式只能作为逗号表达式和三目运算符`:`左右两边的值，不能用于其他运算符
* void表达式不能再被投射到其他类型

**指向void类型的指针为`void*`，`void*`可以被隐式转换为指向任意对象的指针。指向任意对象的指针也能被隐式转换为`void*`**

NULL表示空指针。

## 字符数组和字符串字面量
C99只有ASCII字符和宽字符，宽字符的编码是根据环境来定的，可能是GB2312编码、UTF-16编码等。宽字符使用`wchar_t`，再`<wchar.h>`头文件中定义。

C11引入了UTF-8、UTF-16、UTF-32编码，通过u8、u、U字符串前缀来使用。`u"abc"`是含有三个UTF-16编码的字符串，类型是char16_t[4]。`char16_t`和`char32_t`在`<uchar.h>`中定义。

字符串字面量末尾会自动加上`'\0'`。如果"abc"占4个字节，分配空间的时候要注意多分配一个字节。

**C语言相邻的相同编码的字符串字面量会进行拼接**，例如：
```c
char* a = "aaaaa" "bbb"
          "cccc";
```
等价于`a = "aaaaabbbcccc"`。


## 完整类型和不完整类型
C语言中的类型分为：**对象类型和函数类型**。

**不完整类型**指缺乏足够的信息取判定该类型所声明对象的大小。

例如：
* void表达式就是不完整类型，因为不知道对象的大小。
* 只含有枚举、结构体、联合体的声明，没有定义也是不完整类型。定义了之后变成完整类型
* 结构体中最后不指定大小的数组对象也是不完整类型

不完整类型不能作为sizeof和_Alignof的操作数。


## 灵活的数组成员
在至少含一个对象的结构体中，最后一个成员可以是不完整类型，该成员被称为灵活的数组成员。

灵活的数组成员不计算大小，但是会影响字节填充。

```c
#include <stdio.h>
#include <stddef.h>
#include <stdint.h>
#include <stdlib.h>

int main(int argc, const char* argv[]) {
  struct Test1 {
    int8_t b;

    // 灵活的数组成员，影响字节填充
    double d[];
  };
  size_t offset = offsetof(struct Test1, d);
  // 偏移量和结构体大小一样，是8字节
  printf("offset of is : %zu\n", offset);
  printf("size of is : %zu\n", sizeof(struct Test1));

  struct Test2 {
    int a;
    int array[];
  };
  // 因为按照4字节对齐（如果是double array[]）就按照8字节对齐
  printf("size of struct2 is %zu\n", sizeof(struct Test2));

  struct Test2 ts[] = { {10}, {20}, {30} };
  
  // 灵活的数组成员没有大小，地址是结构体的结束的下一个字节
  // 这里相当于(int*)&ts[2]，(int*)&ts[3]
  // 取到的值是20和30
  int sum = ts[0].array[0] + ts[1].array[0];
  printf("sum = %d\n", sum);

  // 灵活的数组成员还有一种方式就是对结构体做动态内存分配
  // 动态分配的结构体之后的内存将给灵活数组成员
  struct Test2 *pt = malloc(sizeof(*pt) + sizeof(int[sum]));

  for(int i = 0;i < sum;i++) {
    pt->array[i] = i + 1.0;
  }
  pt->a = 100;
  int result = pt->a;

  printf("result is %d\n", result);

  for(int i = 0;i < sum;i++) {
    printf("%d ", pt->array[i]);
  }
  printf("\n");
}
```

要点：
* 灵活数组成员的起始地址是结构体结束的下一个字节
* 灵活数组成员可用于对结构体做动态内存分配
