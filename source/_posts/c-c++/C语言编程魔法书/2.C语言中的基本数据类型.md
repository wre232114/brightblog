---
title: 2.C语言中的基本数据类型
date: 2019-11-11 18:50:49
tags:
- 编程语言
- C语言
- 《C语言编程魔法书》

category:
- 编程语言
- C语言
---
C语言中的基本数据类型分成两个大类，一类是整数类型（包括整数、布尔值、字符），另一类是浮点数类型。

基础数据类型都能进行+、-、*、/。整数还能按位和移位运算、浮点数不支持。

## 整数类型
C语言中的整数类型包括char、short、int、long、long long、_Bool等。C语言没有具体规定每一种类型应占的大小，依据具体的实现来定。常见的规则是（GCC编译器、64位linux操作系统）：
* char 一个字节
* short 两个字节
* int 四个字节
* long 8个字节
* long long 8个字节

C语言规定了short<= int <= long <= long long，在不同的编译环境和系统下，int可能和short一样是16位，而long和long long都是32位。

整数类型的最大值在limits.h中定义。
```c
#include <stdio.h>
#include <limits.h>

int main(void) {
  printf("max int: %d, min int: %d\n", INT_MAX, INT_MIN);
  printf("max unsigned int: %u, max long: %lld\n", UINT_MAX, LONG_MAX);
}
```

### 整数类型字面量的表示
* int：1、2
* unsigned int：1u、2u（U也可）
* short没有特殊的字面量
* char：'A'，或者65均可
* long：100l或者1000L
* unsigned long：1000ul
* long long：1000ll或者1000LL，limits.h中对应的是LLONG_MAX

除此之外，8进制使用0开头，16进制使用0x开头，二进制(c11)使用0b开头。
```c
int a = 10;
unsigned int b = +100u;
unsigned c = -1u;
// 将-1的二进制表示赋值给无符号整数，补码表示，符号位会保留。

printf("%u+%u=%u\n", a, b, a+b);
printf("c = 0x%X\n", c); 
// 显示0xFFFFFFFF，因为-1的二进制是100...0001，除了符号位按位取反+1，1111111....0+1 = FFFFFFFF
// 上面显示的是补码。16进制显示的都是整数的补码表示。

printf("%x + %x = %x\n", a, c, a+c);
// 上面a+c，c是无符号整数、a是有带符号整数，但是+运算和带不带符号没有关系
// +会将两个数的二进制表示相加（补码），产生的结果会溢出，溢出的结果被舍弃，所以其结果是9
// 这也是补码运算的优势，可以统一正数和负数，有符号数和无符号数的运算规则。
```

### 布尔类型
使用_Bool来声明，GCC编译器使用1个字节来存储。不能用signed和unsigned来修饰。

c99标准中在stdbool.h这个有文件中使用bool这个宏来代替_Bool，true定义1，false定义0。
```c
#include <stdbool.h>
// ...
bool flag = true;
printf("%d\n", flag);
```
因为bool、true、false，定义在stdbool中，所以只有引入这个头文件才能使用。而且bool和true都是宏，分别代表_Bool和1。

_Bool虽然只占一个字节，但是如果将int型作为_Bool，不是直接截断而是计算该int型的值是否等于0；对于浮点数也是同样的处理，看该浮点数是不是==0.0

### 字符类型
char占一个字节，C语言规定至少能够放下基本ASCII字符集。一个char正好能够放下ASCII字符集。**有些编译器会默认将char设置成无符号的，我们在编写程序时，如果想使用带符号的char，必须使用signed char。C语言中的signed char、char、unsigned char是不同的**。limits.h中定义了char的最大值和最小值SCHAR_MAX等。

C语言中的转义字符：\'，\"，\?，\\，\123(八进制)，\x0A(十六进制)，\a，\b（游标向前移动一个位置），\f，\n，\r，\t，\v，\0
```c
signed char c1 = 100;
signed char c2 = -10;
// c2是负数（或者说二进制数>127），不对应任何字符，打印出来是问号
printf("%c - %c = %c\n", c1, c2, c1-c2);

// 字符字面量可以有多个字符，赋值给char会最低字节截断，赋值给int，按照最低四字节截断（一个字符一个字节），以此类推。
int c3 = '\0cba';
// '\0cba\刚好4个字节，赋值给int，\0在高字节。再将int转成char*，变成4个元素的char数组，从低到高分别是abc\0，打印出来是abc。
printf("c3 = %s\n", (char*)&c3);
```

### 宽字符和Unicode字符类型
c99引入了wchar_t类型来表示一个多字节字符。wchar_t不是关键字，而是定义在stddef.h头文件中的一个宏类型，一般长度位四个字节，有的是两个字节。

宽字符根据当前操作系统语言环境设置，可能是UTF-16编码、GB2312等，不同的环境显示出来的字样可能不同。在GCC 8.3、linux 64位、zh_CN.UTF-8编码下，宽字符使用的是UTF-16编码。对于大部分中文和所有ascii字符，直接存储的是其码点。例如：
```c
#include <stdio.h>
#include <stddef.h>
#include <string.h>

int main(void) {
  // gcc 8.3，centos7 64下为4个字节
  printf("wchar_t size is %zd \n", sizeof(wchar_t));

  // 宽字符必须使用单引号，然后加上大写的L，不能是小写的L
  wchar_t zw = L'中'; // 在当前环境下（gcc 8.3、linux 64、zh_CN.UTF-8）存的是UTF-16编码。
  wchar_t en = L'A';
  char* zw1 = (char*)&zw; // wchar_t是int，4个字节，但是只用了两个字节，另外两个字节是0，所以strlen长度是2。

  printf("%x %x\n", zw1[0], zw1[1]);
}
```
那我们怎么把'中'这个字符显示出来呢？首先我们明确，在内存中（不管是C还是其他语言，字符都存在内存中）字符都是数字，不管它如何编码。比如‘中’，用utf-8，在内存中就是3个字节；用utf-16在内存中就是两个字节。如何显示那是显示程序需要做的事情。例如我们把文档存为utf-8，那么文本编辑器使用utf-8解码才能正确显示；如果要在控制台显示，控制台如果使用的是utf-8编码，我们必须使用utf-8编码后的字节流输出到控制台，才能正确显示中文。

上面的代码示例中，L存的是UTF-16，直接使用printf或者puts输出到控制台肯定不能正确存储，只有转成UTF-8编码后（C语言中UTF-8直接使用char*来存储，而UTF-16使用unsigned short *，UTF-32使用unsigned int *，c11定义了别名，后面会提到）。

c11引入了Unicode字符类型，在C中可以以UTF-8、UTF-16、UTF-32等方式来存储，通过在字符串前面添加u8、u、U来分别表示utf-8、utf-16、utf-32，如果没有加这些前缀，那么按照默认的编码方式来存储，**不同的操作系统下不同的编译器会有不同的行为，Window下可能使用GBK**，gcc使用和文件编码相同的方式，如果c文件是utf-8形式，那么存的就是utf-8，也可以通过编译器选项来指定输入编码。

在c11中引入了`<uchar.h>`头文件，里面定义了char16_t，char32_t来表示utf-16、utf-32编码的字符（utf-8直接使用char*）。char16_t和char32_t实际上就是unsigned short *和unsigned int *的别名。
> 注意如果是四个字节的unicode码，那么utf-16会占两个字符

### size_t和ptrdiff_t类型
size_t主要用于sizeof操作符的返回类型。c11引入的_Alignof的返回类型也是size_t。size_t定义在stddef.h中。使用size_t的原因是，不同的操作系统返回的地址长度不同，有长有短，Windows下的MSVC在32位系统和64位系统下就不同，分别使用unsigned int和unsigned long long。GCC统一使用unsigned long。因为sizeof返回的数据长度不同，所以使用一个size_t来表示其类型而不是具体的int或者short等，size_t会根据系统的不同使用不同长度的数据。

ptrdiff_t类型用于**两个指针相减后的结果类型**，是带符号的，在stddef.h文件中定义。其长度和size_t相同，区别是size_t一般是不带符号的。

```c
#include <stdio.h>
#include <stddef.h>

int main(int argc, const char* argv[]) {
  printf("%d\n", argc);
  size_t a = sizeof(a);
  printf("%d\n", a);
  size_t *p = &a;

  int b = 100;

  int *q = &b;

  size_t s1 = (size_t)p;
  size_t s2 = (size_t)q;

  printf("Address of a is:0x%16zX\n", s1);
  printf("Address of b is:0x%16zX\n", s2);

  ptrdiff_t diff = (ptrdiff_t)q - (ptrdiff_t)p;
  printf("Address of a minux address of b is: %td\n", diff);
  // 上面输出的值是-4.因为p、q分别是a和b的地址（64位），a先声明，函数中变量从栈中分别，a的地址>b，所以为负。
  // 因为声明的b是int，占4个字节，所以是-4.如果将int改称long，那么返回的值将是-8.
  // 地址是64位的，但是变量长度可能是32位的。
  return 0;
}
```

### 标准整数类型
前面提到的int、short、long等等在不同的编译环境下可能长度不同，那么我们想要相同长度类型怎么办呢？c99引入了标准整数类型，定义在`<stdint.h>`中，主要包含下面几类：
* 固定长度的整数类型：int8_t、uint8_t、int16_t、uint16_t、int32_t、uint32_t、int64_t、uint64_t。写代码的时候可以优先考虑使用这些标准固定长度类型。
* 最小宽度整数类型：(u)int_least8_t,(u)int_least16_t,(u)int_least32_t,(u)int_least64_t
* 最快最小宽度的整数类型：(u)int_fast8_t...。使用该类型的数据可能让编译器适配cpu执行更快速的指令。
* 能存放对象指针的整数类型：intptr_t,uintptr_t。用于将一个对象的地址或者一个指针对象的值用一个整数存起来。**注意这里的intptr_t是一个整数类型而不是指针类型，将地址的值作为一个整数存起来。**
* 最大宽度的整数类型：intmax_t和uintmax_t。存当前c实现支持的最大整数类型的值。

上述宽度除了8,16,32,64等，可能还有24,40,48,56。但是不一定所以编译器都支持。

```c
#include <stdio.h>
#include <stdbool.h>
#include <stdint.h>

int main(int argc, const char* argv) {
  bool b = true;
  char c = 'A';

  int8_t s8 = 10;
  uint16_t u16 = 100;
  int32_t s32 = 1000;

  // 使用ull保证字面量精度不丢失
  uint64_t u64 = 10000ULL;

  int_least16_t l8 = 30;
  // 声明了至少16位的快速计算类型，在不同的系统下可能是不同的宽度，在gcc 8.3、linux 64下是long
  uint_fast16_t f16 = 40;

  // uintptr_t表示指针/地址，长度在不同系统系统中不同
  uintptr_t p = (uintptr_t)&b;
  printf("intmax_t size: %zu bytes\n", sizeof(intmax_t));
}
```

## 浮点类型
由三种浮点类型：float、double、long double。标准仅仅规定float是double类型精度的子集，double是long double类型的子集。

一般的C语言实现将float设置为32位浮点数，double为64位浮点数，使用IEEE754规格化浮点数。long double在x86架构处理器下是80位，在其他架构下可能和double相同，可能16字节。linux 64、gcc 8.3、intel i7下是16字节。

> IEEE754浮点数表示法的细节：
>
> 首先明确几个概念：**规格化数**指没有前导0且小数点左边只有一位整数的采用**科学计数法**表示的数。在计算机中使用的是`二进制规格化数`，因为通过移动二进制表示中的小数点可以很方便的找到左边为1的位置。移动的位置数可以确定幂的指数。
>
> 然后二进制的浮点数怎么表示呢？使用符号位(s)+指数(e)+尾数(f)，对于32位浮点数，使用1+8+23；对于64位浮点数，使用1+11+52；那么对应的10进制值是$(-1)^s*(1+f)*2^E$.这里需要注意的是，在IEEE754标准中隐去了前导1，所以要在尾数上加上1.
>
> 指数有可能是负数，IEEE使用带偏阶的指数，32位浮点数偏阶是127($2^{8-1}-1$)，64位是1023($2^{11-1}-1$)，最终的计算公式如下：$(-1)^s*(1+f)*2^{e+b}$
> 
> IEEE将特殊的指数和尾数的组合表示特殊对象，例如指数和尾数都为0表示0；指数是255或者2048，尾数是0表示无穷，尾数不是0表示NaN。
>
> 将10进制浮点数转成二进制规格化浮点数的步骤如下：1.整数除二取余；2.小数乘2取整，直到结果为0。然后再将规则化的整数用二进制表示，注意隐藏前导1，并给指数加上偏阶。
>
> 示例：0.1和0.2的IEEE754浮点数表示。0.1=0.000110011001100110011001100，规格化后是$1.10011001100110011001100_2 * 2^{-4}$，带偏阶的指数是$-4+127=123=01111011_2$，所以0.1的二进制表示是`0 01111011 10011001100110011001100`。
>
> $0.2_{10}=0.001100110011001100..._2$，规格化后是$1.10011001100..._2*2^{-3}$，带偏阶的指数是$-3+127=124=01111100$，0.2的二进制表示是`0 01111100 10011001100110011001100`

> 浮点数的加法：
>
> 浮点数相加的计算方法是：1.对齐：小的指数向大的指数对齐；2.尾数相加；3.结果规格化，检查指数上溢或者下溢；4.上溢或者下溢：异常；5.对尾数进行舍入，检查是否是规则化数；6.如果不是，返回第三步。
>
> 我们按照上面的规则，将0.1和0.2相加。$0.1=1.10011001100110011001100_2*2^{123}$，$0.2=1.10011001100110011001100_2*2^{124}$。1.对齐：$0.1=0.110011001100110011001100*2^{124}$；2.尾数相加：`10.011001100110011001100100`；3.规格化：$1.0011001100110011001100100*2^{125}$；4.尾数舍入：$0.1+0.2=1.00110011001100110011001*2^{-2}$，换算成10进制就是0.299999982（0.1+0.2不一定总是小于3，在不同语言环境中可能大于3，这里只要只要它可能不等于3就可以了）。
>
> 很明显0.1+0.2是不等于0.3的。这是为什么呢？实际上我们看到，有限位的浮点数是不能够精确的表示0.1、0.2还有0.3的，保存的只是其近似值。在将0.1、0.2、0.3保存时，如何近似可能在不同的系统的不一样。而且0.1+0.2会存在舍入误差，在CPU浮点运算中通过保护位、舍入位、粘贴位来实现舍入。**总之，近似表示和舍入误差让0.1+0.2!=0.3**。浮点数能够精确表示的小数是有限的，因为尾数有限，不能精确表示的保存的都是近似值。

> 扩展：C语言中的i=0.3那么0.3会怎么存储呢？内存中直接有0.3这个值吗？答案是否定的，内存中肯定不会预先有0.3这个值。C编译器读入文本字符串，拿到了0.3这个字符串，然后会将其转成浮点数0.3。这个浮点数0.3直接存储在了指令内存区域中。
>
> 浮点数怎么比较是否相等？浮点数能精确表示哪些数？将两个浮点数相减，如果其差值小于一个给定的误差值，则说明在给定的误差范围内其值相等。javascript在ES6中提供了`Number.EPSILON`，如果误差绝对值小于这个值，则说明两个相等。浮点数能精确的表示有限个小数和有限个整数，因为其采用$(1+f)*2^e$的形式，尾数始终代表小数。64位浮点数在0-1之间最多能精确表示$2^{54}$个小数，能精确表示$2^{-53}-2^{53}$之间的连续整数。除此之外还有离散的一些整数。

### C语言中的浮点数字面量
最基本的表示方法就是十进制小数的表示方法，例如1.0、2.0、-0.5等等。如果小数部分为0，也可以写成10.、-5.；如果整数部分为0，可以写成.5。后面添加f表示是float，占32位，如果添加l/L说明是long double，默认是double。

还有就是科学计数法，例如`3e5`或`6E-3`。例如`0x3.5p2`表示$0x3.5*2^2$。p的左边是16进制整数或者浮点数，右边是十进制整数。注意上例中的3.5直接就是0011.1001。

float.h中定义了最大最大最小浮点数，FLT_MIN、DBL_MAX、LDBL_MAX。

## 数据精度和类型转换
一个类型字节宽度越大，其精度越高，或者说“整数转换等级越高”。C语言有以下规定。

1. 任意两个不同类型的整数不会有相同的精度
2. 更高精度的带符号等级越高
3. 同类型无符号和带符号等级相同
4. long long > long > int > short > char
5. size_t和ptrdiff_t不应该高于long
6. _Bool等级最低

### 隐式转换
等级从低到高是一个隐式转换的过程，编译器会自动进行，例如将int赋值给long，那么int会自动转换成long。

进行运算或者赋值的时候，如果编译时整数溢出，gcc会给出一个warning，并且直接向上进位，溢出符号位部分忽略。浮点数不会有任何提示，会直接截断，如果截断的结果是ieee754的保留码，则会输出0或者inf等。如果运行时溢出，不会给出任何提示，直接进位。

### 带符号和无符号数之间的转换
两个整数类型相互转换时，如果双方精度能够容下两个的所有位（包括符号位），那么所有位都会保留。反正就是那些二进制位，符号位是否表示正负看你是使用signed还是unsigned。

如果被赋值的精度小，那么直接将大精度的值高位截断。如果被赋值的精度大，则要看符号位。如果是无符号类型，高位填充0，如果是带符号类型，高位填充符号位。

```c
#include <stdio.h>
int main(int argc, char* argv[]) {
  signed char c3 = -1;
  short s1 = c3; // 扩充1到高位
  printf("%x %d %u\n", c3, s1, s1);

  short s = -129;
  unsigned char uc = s; // 截断，取低八位
  printf("uc = %u\n", uc);

  unsigned short us = 1022;
  uc = us; // 直接截断，取低八位
  printf("uc = %u\n", uc);
  return 0;
}
```

**类型投射符，使用()+类型进行类型映射，例如(int)a表示将a转换成int型数据**

### 浮点数和浮点数的转换以及浮点数和整数之间的转换

1. 单精度到双精度
   符号位不变，尾数低位补0，指数使用源指数加上1023（偏阶）。

2. 双精度到单精度
   尾数和指数都会截断，会产生精度丢失。

3. 浮点数到除布尔外的整数
   直接丢弃小数。int x = 100.10;x的值是100，.10会被丢弃。如果转换成char，那么先到int，int截断后到char。

4. 整数到浮点数
   如果精度能够表示整数，值不变，只是变成浮点数。否则会丢失精度。