---
title: GCC内联汇编
date: 2019-12-01 09:38:36
tags:
- 编程语言
- C语言
- GCC

category:
- 编程语言
- C语言
---
GCC提供了在C语言中嵌入汇编语言的能力。在C语言中嵌入汇编，在操作系统和嵌入式软件中开发很有用，编写底层软件时能够直接访问硬件。但是编写客户端软件时有些汇编指令是不可用的，所以编写windows或者linux下的客户端软件时，使用某些指令可能会出错。因为计算机系统的保护模式会提供对特定指令的保护，这些指令只能在内核态中运行；而一般的应用运行于应用层，特权级最低，仅能通过系统调用来获取访问系统资源。

## 两种内联汇编语法
GCC有两种内联汇编语法，一种是简单内联汇编，另一种是扩展内联汇编。简单内联语法如下：
```
asm [volatile] (asm instructions);
```
例如：
```c
asm ("pushl %eax;movl $0,%eax;popl %eax;");
```
这种情况下C语言不能和汇编进行交互，而且如果使用的寄存器恰被C编译器分配给其他变量，那么这里对寄存器重新赋值就会出现问题。扩展内联汇编语法

不同的汇编指令之间要用`\t\n`或者`;`隔开，表示不同的指令。
> asm、volatile和`__asm__和__volatile__`是完全相同的，两者均可。

## 扩展内联语法
GCC下通过asm可以在C语言中嵌入汇编指令，如下例：
```c
#include <stdio.h>

int main(void) {
  int a = 40;
  int b;

  asm(
    "movl %1,%%eax;"
    "shr %%eax;"
    "movl %%eax,%0;"
    : "=r"(b)
    : "r"(a)
    : "%eax"
    );
  
  printf("a = %d, b = %d\n", a, b);
  return 0;
}
```
上面的代码通过asm嵌入了一系列汇编指令。通过asm扩展语法，这些汇编指令能够和C语言中的变量进行交互，能够将C语言中变量的值传到汇编中，也能够将汇编中计算的值赋值给C语言中的变量。上面的示例就是将变量a赋值给eax寄存器，然后将eax寄存器右移一位（相当于除2），然后将结果输出给变量b。

asm的语法如下：
```c
asm volatile (汇编语言模板
  : 输出操作数
  : 输入操作数
  : 使用的寄存器
  );
```
volatile暗示编译器不需要对这部分代码进行优化。编译器优化时可能会调整指令的位置，如果我们不希望编译器这么做，可以加上volatile让编译器不优化。

### 汇编语言模板
这个汇编语言模板起始就是汇编语言，只是指令的操作数用占位符代替。例如：`movl %eax, %0`。这里的`%0`就是一个占位符，通过占位符和C语言变量交互。

注意如下要点：
* 模板中的寄存器有两个百分号`%%eax`
* 使用%0，%1作为占位符和C语言变量交互。先输出后输入，意思就是，如果有2个输出，那么%0、%1就是输出，后面才是输入；如果有三个输出，那么%0、%1、%2是输出、后面是输出，依次类推。
* 可以通过寄存器寻址：`movb (%%eax),%al`
* 数字以`$`开头：`$3`
* 多个指令之间使用`\t\n`或者`;`隔开

### 输入输出参数
通过输入输出参数可以将C语言变量匹配到内联汇编中。例如：
```c
int array[2], i = 0;
  array[0] = 150;
  asm volatile (
    "movl %1,%%eax;"
    "shl  %%eax;"
    "movl %%eax,%0;"
    : "=r"(array[i+1])
    : "r"(array[i])
  );
  printf("array[0] = %d, array[1] = %d\n", array[0], array[1]);
```
`"=r"(array[i+1])`中，`=`表示输出操作符，`r`表示值必须放在任意一个寄存器中，输入时会将变量加载到这个寄存器中，输出时会从这个寄存器输出到变量所在的内存中。除了r之外，常用的约束字母如下：
* m、v、o：内存单元
* r：任何通用寄存器
* q：abcd四个寄存器之一
* l、h：直接操作数
* E、F：浮点数
* G：任意
* a、b、c、d：eax/ax/al、ebx...
* S、D：esi或者edi
* I：常数（0-31）

如果输入和输出时一个操作数，那么可以用下面的方式：
```c
asm("incw %0;"
: "=a"(counter)
: "0"(counter));
```
`"0"`表示引用`%0`表示的寄存器，所以输入和输出使用的是同一个寄存器。

### 使用的寄存器
最后一个冒号接的是使用的寄存器，告诉编译器我需要这些寄存器或者这些寄存器的值已经改变；编译器在分配寄存器的时候就会考虑这些因素。

如果使用`memory`，表示某些内存中的值已经改变。如果之前编译器已经将该内存的值放在了寄存器中，那么会导致数据不一致。使用memory告诉编译器这个信息，编译器会处理这些情况。


## `__attribute__`
`__attribute__`用于在函数和变量声明的时候，给编译器设置一些属性，从而实现对函数的优化和对变量声明的控制。

例如：
```c
void fatal_error() __attribute__((noreturn));

struct mong {
  char id;
  int code __attribute__((align(4)));
}
```
告诉编译器这个函数没有返回值，所以编译器编译时会进行优化，不产生函数返回相关的代码；结构体中的成员按照4字节对齐。

常用的属性值如下：
* always-inline：将函数作为inline函数，尽可能优化并放在CPU能够尽快取到的位置
* packed：用于结构体成员，表示拥有尽可能小的对齐属性；用于结构体，表示结构体的总大小尽可能小。