---
title: JavaScript(ES5)核心语法复习指南
date: 2020-02-21 09:53:49
tags:
- js
- js基础

category:
- js
- js基础
---
这篇文章覆盖JavaScript(es5)的所有语法要点，便于日后进行js基础方面的查阅和复习。参考《JavaScript权威指南》，采取编译原理结构的形式进行总结，从词法、类型、表达式、语句等方面来总结。

## 要点归纳
* 1.词法结构
  * 字符集：使用的是Unicode字符集，采用UTF-16编码，标识符区分大小写。
  * 注释：`//`或者`/**/`
  * 直接量：
    * 数字：12、1.2、1.2E-8、.33333
    * 字符串："Hello"、"\u0212"
    * 布尔值：true、false
    * 正则表达式：/javascript/gi
    * 空：null
    * 对象：{x:1, y:2}
    * 数组：[1,2,[2,4],{x:1,y:2}]
  * 标识符：包括字母、数字、下划线(_)和美元符号($)。标识符不能以数字开头。允许使用Unicode全集作为标识符，也就是使用中文变量是可以的。
    * 保留字：和java等其他编程语言的关键字类似，特殊的有：delete、function、typeof、var、debugger、default
  * 分号可选：使用分号隔开不同的语句，否则就需要使用换行
* 2.类型、值和变量
  * 6种基本数据类型：5种原始数据类型（字符串、数字、布尔值、null、undefined）和对象。原始数据类型变量存的是值，而对象变量存的是引用。数组和函数都属于特殊的对象。**js中基础类型都是不可变的，包括字符串，只有对象可变**
  * 1.数字：js不区分整数和浮点数，数字全部使用64位IEEE754浮点数（1符号位+52尾数+11指数）来表示。能表示的整数范围是$-2^{53}-2^{53}$。**但是数组索引和位运算采用的是32位。**
    * 数字的运算：+、-、*、/、%，复杂运算通过Math来实现，例如Math.sin、Math.ceil、Math.floor、Math.round等。
    * 数字溢出和下溢：溢出包括正溢出和负溢出，溢出的值用Infinity和-Infinity表示。x/0返回Infinity，但是如果x=0则报错。
    * NaN：表示不是一个数字（Not a Number），该值与任何值都不相等，包括它自己，通过isNaN()或者x!=x来判断。
    * 舍入误差：IEEE754浮点数表示法不能精确表示0.1等数字，表示的是近似值，当进行运算时会有误差，因此不能通过.3-.2==.1来判断。ES6新增了Number.EPSILON表示一个即小的数，要使用`(.3-.2)-.1 < EPSILON`这样判断。
    * 时间和日期：`Date()`构造函数用于创建时间日期对象。常用方法有：
      * var then = new Date(2020,2,20,10,27,48);
      * var now = new Date(); // 当前时间
      * now.getFullYear()
      * now.getDate() // 1-31
      * now.getDay() // 0-6，0表示周日
      * now.getMonth() // 0-11
      * now.getHours()
      * now.getMinutes()
      * now.getSeconds()
  * 2.文本
    * 字符串是UTF-16序列的数字，注意位于基本平面内的字符是一个16位值，而处于其他平面的字符需要两个16位值来表示。这在字符串遍历字符的时候需要考虑。**字符串是不可变的，所以对字符串的任何操作都是返回新字符串，而不是在原字符串上改变。**
    * 多行字符串可以使用`\`来分割。
    * 字符串的使用：
      * 通过+连接字符串
      * s.length
      * s.charAt(0)
      * s.substring(start, end)
      * s.substr(start, length)
      * s.slice(start, end)
      * s.indexOf('l')
      * s.lastIndexOf('l')
      * s.split(',')
      * s.replace('h', 'H')
      * s.toUpperCase()
    * 字符串可以使用正则表达式进行模式匹配
      * pattern.test(text)
      * text.search(pattern)
      * text.match(pattern)
      * text.replace(pattern, '#')
      * text.split(/\D+/)
  * 3.布尔值：只有两个值true和false。布尔值转成字符串会变成'true'和'false'
  * 4.null和undefined：null表示控制、undefined表示未定义或者未赋值
  * 5.全局对象：js会创建一个全局对象，未使用var声明的变量、全局属性、全局函数、全局构造函数、全局对象都绑定在全局对象上。**浏览器中的全局对象是window，nodejs中的全局对象是global。**
  * 6.包装对象：类似`"123".charAt(0)`是允许的，原因值js会将原始值转换成其包装对象，所以看起来就像原始值也有属性和方法。**创建的包装对象是临时对象，不会保存。**
  * 7.可变和不可变的值：原始类型不可变、引用类型可变。对象称为引用类型，对象的比较是引用的比较。
  * 8.类型转换：
    * 字符串到：
      * 数字：数字或者NaN，例如'1.2'=>1.2，'a'=>NaN，区别与C/C++中的char。
      * 布尔值：""=>false，其他=>true
      * 对象：new String()
    * 数字到：
      * 字符串：直接变成字符串，例如0=>'0'，Infinity=>'Infinity'
      * 布尔值：0=>false，NaN=>false，其他=>true
      * 对象：new Number()
    * 布尔值到：
      * 字符串：false=>"false"，true=>"true"
      * 数字：true=>1，false=>0
      * 对象：new Boolean()
    * null、undefined到：
      * 字符串：'null'、'undefined'
      * 数字：null=>0、undefined=>NaN
      * 对象：报错
    * 对象到：
      * 字符串：使用对象的toString方法或者valueOf方法
      * 数字：使用valueOf方法或者toString方法
      * 布尔值：true
    * 数组到：
      * 字符串：[]=>""、[9]=>"9"、[1,2]=>'1,2'，使用join方法
      * 数字:[]=>0、[9]=>9，其他=>NaN
      * 布尔值：true
    * 函数到：
      * 字符串：使用toString或者valueOf
      * 数字：NaN
      * 布尔值：true
  * 9.隐式类型转换和显式类型转换：
    * 进行运算时，如果操作数的类型不同，那么会进行隐式的类型转换。`==`会进行类型转换而`===`不会。`==`转换时原始值都会转换成数字，所以"0"==false返回true，**尽管"0"转换成布尔值时true。**
    * 显式类型转换：通过Number('1')、String(1)、Boolean(1)等方式进行
      * 还有parseInt、parseFloat将字符串转成数字
      * num.toFixed、num.toPrecision等将数字格式化成对应的字符串的方法。
  * 10.变量声明：var name1=1,name2...，var可以重复声明变量
    * 变量和函数声明会提前到作用域的最顶部，称为`变量提升`。
    * 没有使用var声明的变量将会挂载到全局对象上
    * var声明的变量不能用delete删除
  * 11.变量作用域：
    * ES5只有两种作用域，分别是函数作用域和全局作用域
    * 因为能在函数中定义函数，所以函数作用域能嵌套，嵌套的作用域连接成作用域链，变量查找的时候会查作用域链
    * 内层函数能访问到外层函数的变量，如果外层函数退出了而内层函数没有，那么外层函数中被内层函数引用的变量不会回收，称为闭包。
* 3.表达式和运算符
  * 1.原始表达式：表达式的最小单位
    * 直接量
    * 保留字：true、false、null、this等
    * 变量：i、sum、undefined
  * 2.对象和数组的初始化表达式：
    * [表达式, 表达式, ...]，这些表达式会在数组初始化时求值。表达式可以是任意表达式。
    * {name:表达式, name2:表达式}，内部的表达式会再对象初始化时求值，表达式可以是任意表达式
  * 3.函数定义表达式：
    * 函数定义表达式返回一个值为函数的对象，可视为“函数直接量”
    * 语法：`function name() {}`
    * 因为函数定义是表达式，所以可以这样赋值`var a = function () {}`
  * 4.属性访问表达式：
    * `expression.identifier`或者`expresstion[expression]`，expression可以是任意表达式，`[`之前的expression的值会先计算。
  * 5.调用表达式：
    * 语法：`expression(args)`，expression是函数表达式，在调用前求值，如果值不是可调用的，则报错。
  * 6.对象创建表达式：
    * 语法：`new identifier(args)`
    * 对象创建过程是，新建一个对象，作为构造函数中的this，如果构造函数没有返回值，那么这个对象作为对象创建表达式的值，否则使用返回的对象作为对象创建表达式的值。
  * 7.运算符：包括算术运算、逻辑运算、赋值运算、还有delete、typeof、instanceof等。
    * 优先级：单目运算（++、--最高）高于双目运算、算术运算$\lt$移位运算$\lt$比较运算，逗号最低、赋值倒数第二。
    * **通过括号可以改变优先级，推荐方式**
    * 按位运算：`&,|,^,~,>>,<<,>>>`等采用32位整形运算，会忽略超过32位的部分。
    * 比较运算：`==、>=、!=等`。对象转为原始值，两个字符串比较的是字母表顺序，至少一个不是字符串则转为数字比较。**比较操作如果包含NaN则总是返回false**
    * in：左操作数是字符串或者可以转成字符串，右操作数是一个对象。如果右对象包含左属性则返回true。
    * instanceof：左操作数是对象，右操作数是构造函数。如果构造函数的prototype在对象的原型链上，则返回true。
  * 8.逻辑表达式：&&、||、!
    * &&和||都是短路运算符，左右两边可以是任意表达式，如果短路了则不会对另一部分的表达式进行计算。
    * a && b，如果a是真值则返回b，否则返回a。常用`a = arg && arg.length`
    * a || b，如果a是真值则返回a，否则返回b。例如`a = arg1.len || arg2.len`
    * !a，先将a求值并转为布尔值，再取反。
  * 9.赋值表达式
    * a = b：a一定要是左值，返回赋值后的a的值
  * 10.eval表达式
    * eval可以动态执行代码，也就是可以在运行时构造任何代码并执行。例如eval('2+3')
    * eval表达式返回其最后一条语句的值。
    * eval的作用域和调用他的作用域一样
  * 11.其他运算符：
    * 三目运算符：a?b:c，如果a是真值，则计算b并返回其值，否则c
    * typeof运算符，能用typeof区分基础类型、函数和宿主对象：
      * undefined：返回'undefined'
      * null：返回'object'
      * 字符串：返回'string'
      * 数字：返回'number'
      * true或者false：返回'boolean'
      * 函数：返回'function'
      * 任意对象和内置对象：返回'object'
      * 宿主对象：返回编译器实现的字符串，一般也是'object'
    * delete运算符：delete a.o，删除a对象中的o属性，delete不返回值。
    * void运算符：忽略一个表达式的值，例如`void window.open()`
    * 逗号运算符：i,j=0,k，操作数可以是任意类型，返回最后一个操作数的值。