---
title: 3.关系数据模型
date: 2020-02-07 10:07:52
tags:
- 数据库
- 数据库设计

category:
- 数据库
- 数据库设计
---
前面学的E/R模型是对于现实世界进行建模的一种很好的方式，但是其不好实现。现今的数据库实现通常使用**关系数据模型**。关系模型只有一个概念：“关系”，即组织数据的一种二维表。E/R符号用于设计数据库并阐述数据之间的关系，关系数据模型用于数据的实际存储，如何将E/R符号转为关系数据模型也是本片笔记的复习重点。

## 复习要点
本章的复习要点如下，需要补充的部分在后文补充，点击连接即可跳转。

* 1.关系模型的基础：关系模型通过一种**称为`关系`的二维表**描述数据，类似于表格。
  * 属性：关系模型的"表头"称为属性。
  * 模式：**关系名和属性名集合的组成称为这个关系的模式**。例如Movie(title, year, length, filmType)。关系模式的集合称为数据库模式。
  * 元组：除"表头"(属性名所在行)之外的行称为元组。元组之中的元素的顺序要和属性顺序对应上。
  * 域：关系模型要求元组的每个分量具有原子性，必须属于某种元素类型，例如string或者integer。
  * 关系的等价：关系是集合而不是列表，可以改变元组或者属性的顺序来得到等价的关系。
  * 关系实例：一个给定关系中元组的集合称为**关系的实例**。实例会随数据库的修改而改变。
* 2.从E/R图到关系设计：数据库设计实践中，一般先设计E/R模型，再转为关系模型，会更加简单，而不是直接使用关系模型设计。
  * E/R模型到关系模型的通用转换规则：1.每一个实体集合转化为具有同一属性集合的关系。2.用关系代替联系，该关系的属性是连接的实体集的键集合和联系的属性。
  * 考虑特殊情况：1.弱实体集需要考虑支持键。2."isa"联系和子类要特殊对待。3.有时需要把两个关系合成1个，尤其是在转化多对一联系时。
  * 组合关系：有些情况下可以将多个关系合成一个关系，例如多对一联系。假设R是E到F的多对一联系，可以将R的关系合并到E的关系中，合并的属性具体是，F的主键，R的属性。
  * 处理弱实体集：核心思想——需要添加其他实体集的支持键。1.从弱实体集W得到的关系R需要添加所有的支持键作为属性。2.与W相连的**非支持联系**需要添加W的所有支持键作为属性。3.支持联系不需要转为关系，支持联系的属性作为R的属性。
  * 子类结构到关系的转化：
    * 1.E/R方式转化：每一个子类都转为关系R（包括根实体集），R的属性是子类的属性加上根实体集的`键属性`。新增实体时，子类关系和根关系都需要插入元组。
    * 2.面向对象方式：每一个子类都转为关系R（不包括根实体集），R的属性是子类的属性加上根实体集的`所有属性`；同时如果有组合的子类，例如既是卡通电影，又是恐怖电影，则新建一个关系，这个关系包含卡通、恐怖、根三个实体集的所有属性。新增实体时，只在对应的关系中插入元组。
    * 3.空值方式：只建立一个关系，将所有的子类的属性都添加到这个关系中。添加某一个子类的实体时，关系中不属于该子类的属性设置为空值。
    * 各种方式比较：1."空值"方式只使用一个关系，查询效率最高，但是会占用额外的内存空间，因为有很多空值。2.查询“范意义”时，例如仅仅针对电影，E/R方式效率比面向对象高，因为只需要查根关系。而面向对象需要查所有子类关系。3.查询跨越多个子类的关系，E/R方式效率更低。
    * 总结：三种各种各有优劣，需要根据查询的实际情况合空间情况、关系数量情况进行权衡。
* 3.函数依赖：单值依赖称为函数依赖（缩写为FD），如果属性集合A确定，那么属性集合B也确定，则说明A函数决定B，记作A->B。
  * 关系的键：能函数决定关系中其他所有属性的**最小化属性集合（即没有满足条件的集合是其真子集）**。如果能函数决定关系中其他所有属性，但是不是最小化属性集合，则称为`超键`。**关系可以有多个键，但是只有一个主键，在关系模式中画下划线表示。**
* 4.函数依赖的规则：如何从已知的函数依赖推断除其他函数依赖。
  * 1.分解结合规则：A->B1B2 => A->B1和A->B2，反过来也正确。
  * 2.平凡依赖规则：A->B，且B是A的子集。如果有A-BC，B是A的子集，可以直接去掉B，得到A->C。
  * 3.属性集合的闭包：给定一个属性集合{A1,...,An}，如果有FD：A1...Am -> B，则将B加入到集合中，重复直到没有更多属性能够假如到集合中，最终得到的属性集称为集合{A1,...,An}的闭包，记作{A1,...,An}+。**如果{A1,...,An}+ = 所有属性，那么{A1,...,An}是关系的超键，**可以根据这条规律来从FD计算关系的键。
  * 4.传递规则：如果有A1...An -> B1...Bm，B1...Bm -> C1...Ck，那么有A1...An -> C1...Ck。简记为A->B，B->C，则A->C。
  * 关系的基本FD集：如果一个FD集合能够推断出关系的所有FD，改FD集合称为关系的基本FD集。如果改集合没有真子集是基本FD集，那么其实最小化的基本FD集。
  * 函数依赖的投影：**关系的投影就是去除一部分属性后剩余属性组成的关系**，函数依赖的投影就是原关系的所有FD中，左右两边的属性都在投影的到的关系中的FD集合。
* 5.关系数据库模式设计：E/R模型转为的关系模型可能会有冗余等异常，需要进一步的设计分析消除异常。
  * 异常：1.冗余：同一数据多次存储。2.更新异常：只更新了一个元组而没有更新其他元组中的相同信息。3.删除异常：删除一个元组会导致其他不需要删除的数据丢失。
  * 分解关系：一般用分解的方式来消除异常。将{A1,...,An}分解成{B1,...,Bm}和{C1,...,Ck}且{A1,...,An}={B1,...,Bm}并{C1,...,Ck}。那么采用什么样的分解方式，能消除什么样的异常呢？下面的范式给出了分解规则。
  * **1.BCNF范式**：如果关系R满足BCNF，那么R中的每一个非平凡FD，如果左边的属性都是超键，则满足BCNF范式。如果有一个非平凡FD左边不是超键，那么该FD违反BCNF范式。分解规则是：假如{A1...An}->{B1...Bn}违反BCNF，那么求S={A1..An}+，将S的所有属性作为新的关系R，{A1..An}和除开S外的其他属性作为另一个关系，如果另一个关系违反BCNF，则继续分解。**BCNF分解后的多个关系连接后能够正确恢复。**
  * **2.第三范式**：BCNF分解后得到的关系，可能不能保持FD。例如在原关系R中有AC->B,分解得到了关系R1(A,B)和R2(B,C)。那么满足R1和R2的元组重新连接后可能不满足AC->B这个FD了，也就是分解成R1和R2会导致丢失AC->这个FD。**第三范式稍稍放松了BCNF的限制，可以解决这个问题。**`如果关系R中有A->B，那么要么A的超键，要么B是主属性（主属性是键包含的属性）`。三范式能够消除大部分的冗余，但是不是全部，如果要全部消除冗余，需要分解到BCNF范式。三范式的分解方式和BCNF相同。
  * **3.第四范式**：解决多值依赖的问题，知识点在下面。
* 6.多值依赖：是两个属性或属性集合之间相互独立的断言。是广义上的FD，每个FD也是一个多值依赖。
  * 属性独立及其冗余：例如R(a,b,c,d,e)，abcde相互独立，R中不存在FD，那么不违反BCNF范式，但是abcde可以随意组合，假设元组中a相同，bc有两个值，de有三个值，那么需要6个元组来存储这些值，bc的两个值要存储3次，de的三个值要存储2次。
  * 多值依赖的定义：给定一个属性集合的值，存在有与关系中其他属性值独立的属性值。记作A->->B。
  * 多值依赖规则：1.平凡依赖规则：如果有A->->B，且C是B的属性与A的1个或者多个属性的并，则有A->->C。相反的，去掉B中属于A的属性也成立。2.传递规则：如果有A->->B，和B->->C，那么有A->->C（去掉C中同时属于B、C的属性）。3.多值依赖不遵循分解规则，遵循合并规则。
  * **非平凡MVD（MVD=多值依赖）**：A->->B是非平凡MVD，那么，B中不含A中的任何属性且R中存在A、B之外的属性。3.互补规则：有A->->B，则有A->->C，C是不属于AB的所有属性。
  * **第四范式**：在R中，如果有非平凡MVD A->->B，那么A是超键。
  * **分阶段扫第四范式**：对于违反四范式的A->->B，分解成AB，以及A和AB外的全部属性。如果分解后的关系不满足四范式，则继续分解。