<!doctype html>
<html lang="de"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: 操作系统 - Bright的个人博客</title><meta description="前端开发的技术分享和个人笔记总结"><meta property="og:type" content="blog"><meta property="og:title" content="Bright的个人博客"><meta property="og:url" content="https://www.brightblog.cn/"><meta property="og:site_name" content="Bright的个人博客"><meta property="og:description" content="前端开发的技术分享和个人笔记总结"><meta property="og:image" content="https://www.brightblog.cn/img/og_image.png"><meta property="article:author" content="Bright"><meta property="article:tag" content="前端开发 个人博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.brightblog.cn"},"headline":"Bright的个人博客","image":["https://www.brightblog.cn/img/og_image.png"],"author":{"@type":"Person","name":"Bright"},"description":"前端开发的技术分享和个人笔记总结"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li class="is-active"><a href="#" aria-current="page">操作系统</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-19T01:31:58.000Z" title="2019-12-19T01:31:58.000Z">2019-12-19</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">17 minutes read (About 2617 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/19/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B06%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E3%80%81IDT%E5%92%8CIDTR/">ucore-os笔记6：中断和异常、IDT和IDTR</a></h1><div class="content"><p>外部设备与CPU通信需要通过中断机制。例如，当按下键盘上的一个键的时候，必然要通知CPU该键被按下，一种方式是CPU一直监视键盘上有没有键按下，但是这种方式性能太低。另一种方式由设备主动通知CPU有事件发生，当键盘被按下时，键盘通知CPU有键被按下并且告知是哪一个键，这种方式就是中断方式。中断机制是系统具有响应式能力，也是进程/线程实现抢占式调度的一个重要基石（通过时钟中断）。</p>
<p>操作系统中有三种中断，分别是：</p>
<ul>
<li>外部设备引起的：IO中断、始终中断等异步产生的，与CPU的执行无关，简称为<code>中断</code></li>
<li>CPU运行中引起的：例如除0、缺页、地址越界等等，在CPU运行时CPU检测到的异常，称为<code>异常</code></li>
<li>用户调用引起的：例如系统调用，用户调用了INT指令，也是在CPU运行时检测到，称为<code>陷入</code></li>
</ul>
<p>上面的三种中断可以分为两大类，异步中断和同步中断。异步中断由外部事件产生，时间不确定。同步中断由CPU产生，可以是CPU执行时的异常，或者用户调用特定指定导致。</p>
<blockquote>
<p>中断还可以分为可屏蔽中断和不可屏蔽中断，可屏蔽中断由NMI引脚触发，不受EFLAGS寄存器中的IF影响。普通中断硬件由INTR引脚引起，可通过IF位屏蔽</p>
</blockquote>
<h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><p>当CPU检测到中断时，会中断当前指令的执行，调转到中断处理程序的位置执行。那如何直到中断处理程序在哪个位置呢？CPU使用IDTR和IDT和储存中断处理程序的地址。中断调用结束后会回到被中断的指令的位置继续执行，那如何直到中断前的指令的位置呢？通过堆栈来实现，CPU会自动将指令位置相关的寄存器cs、eip压入内核栈，中断结束后通过iret将栈中的数据恢复到寄存器中。</p>
<p>IDTR是中断描述符表寄存器，存了中断描述符（IDT）的起始地址和长度：<br><a href="/img/IDTR.png">IDTR</a></p>
<p>每一个中断有一个中断向量号，最多有256个中断向量号。中断向量号对应IDT中的表项，IDT是中断描述符表，里面最多有256个表项与中断向量号一一对应。寻找中断程序入口的步骤是，从IDTR找到起始地址，注意这里的起始地址就是线形地址，不需要在经过GDT转化；寻找计算对应的表项的地址，计算公式是base+interrupt number * 8，乘8是因为一个表项占8个字节。找到对应的表项之后，表项中存了中断程序的逻辑地址，就是段描述符+偏移；CPU将段描述符加载到段寄存器中，偏移加载到EIP中，然后就得到中断处理程序的线形地址，描述符表项结构：<br><a href="/img/IDT-entry.png">IDT表项</a></p>
<p>中断向量表的前32个是被CPU保留的，<code>[32,255]</code>是给用户使用的，所以ucore定义的中断都在32之后，包括IO设备中断、系统调用等等。cpu触发中断以后，会禁用中断（将EFLAGS寄存器中的IF位置0），中断处理程序中可以手动开启来实现中断嵌套，但是需要自行处理堆栈；陷入和异常不会禁用中断。</p>
<p>IDT中有三种描述符，在上图中有其格式，分别是：</p>
<ul>
<li>Task-gate descriptor</li>
<li>Interrupt-gate descriptor</li>
<li>Trap-gate descriptor</li>
</ul>
<h3 id="中断过程中硬件完成的工作"><a href="#中断过程中硬件完成的工作" class="headerlink" title="中断过程中硬件完成的工作"></a>中断过程中硬件完成的工作</h3><p>中断过程中的调转到中断程序和从中断程序都是硬件进行的：</p>
<ul>
<li>CPU在执行完每一条指令之后，都会检测中断请求，如果监测到中断请求，会从总线上读取对应的中断向量（对应计算机接口中的IO读周期）</li>
<li>用读取到的中断向量号来寻找中断向量的起始地址，通过IDT和IDTR找到描述符项</li>
<li>描述符项中有段描述符和偏移，利用它们找到GDT中的对应表项，取的中断服务程序的线形地址</li>
<li>CPU会根据CPL和中断处理程序的段描述符的DPL确定是否发生了特权级的转换。因为用户程序运行在用户态，而内核程序运行在内核态。中断会陷入内核态，如果是在用户态，则需要先切换到内核态。在用户态执行int指令，会通过TSS和TR可以取得内核栈地址，切换到内核栈然后将用户态的ss和esp压栈保存下来。如果是内核态陷入中断，则不需要这些处理，栈中也没有ss和esp</li>
<li>CPU会保存一些现场信息用于返回原程序执行，所以会压栈eflags、cs、eip、errorCode（有的中断有errorCode，有的中断没有，是CPU预置的）</li>
<li>CPU将cs、和eip切换到中断程序的地址，然后开始执行</li>
<li>执行完中断程序以后，通过iret指定恢复原有的程序。指定iret后，CPU会将eflags、cs、eip从栈中恢复到寄存器中，cpu不会自动弹出errorCode，需要手动弹出</li>
<li>如果是有特权级切换，不管是用户态还是内核态，都会弹出ss和esp。</li>
</ul>
<p>中断处理程序寻址过程：<br><a href="/img/idt表项寻址过程.png">中断处理程序寻址过程</a></p>
<p>堆栈变化：<br><a href="/img/堆栈变化.png">堆栈变化</a></p>
<p>这里需要注意堆栈变化，当有权限切换时，会压入/弹出SS和ESP，不管是从内核到用户态还是从用户态到内核态。例如，从内核触发中断的时候，没有发生切换，所以不会压栈SS和ESP，但是如果在中断程序中切换了CS到用户态的CS，那么从中断返回的时候，就会从堆栈中多弹出SS和ESP，写代码的时候要注意这一点（lab1挑战实验1）。<br><a href="/img/interrupt-stack.gif">堆栈变化1</a></p>
<h3 id="中断处理过程中的特权级转换"><a href="#中断处理过程中的特权级转换" class="headerlink" title="中断处理过程中的特权级转换"></a>中断处理过程中的特权级转换</h3><p>中断时CPU会进行特权级的检查。这个特权级的检查分成两个部分，一个是IDT中表项中的段描述符，段描述符中的DPL确定了所处段的特权级，<strong>只有段描述符的特权级高于或等于当前特权级时，检查通过</strong>；当触发中断和从中断程序返回都会检查，检查中断程序的段选择符和当前的CS，如果两者的DPL不相同，就发生特权级切换了，堆栈处理操作不同，看上一小节的堆栈图。</p>
<p>另一个是IDT表项中的DPL，如果是用户态程序触发的（例如INT n），还会检查表项中的DPL，只有当DPL更低时或相同时才通过检查，这就阻止了用户程序能够触发任意的中断，例如用户态为3，那么就只能触发DPL为3的中断。<strong>这里需要注意只有INT指令触发的中断，才会检查DPL，由硬件触发的中断不会检查DPL，所以硬件中断的代码即使位于内核段中，也能直接被调用；但是权限切换依然会被检查，如果当前是用户态执行触发了硬件中断，那么会压入ss和esp</strong></p>
<p>如果检查失败，CPU会触发一个保护异常。<br><a href="/img/idt-privilige-check.png">idt-privilige-check</a></p>
<h3 id="ucore-os对于中断的实现"><a href="#ucore-os对于中断的实现" class="headerlink" title="ucore-os对于中断的实现"></a>ucore-os对于中断的实现</h3><p>ucore-os的中断向量表定义在kern/trap/vector.S中，该文件由tools/vertor.c文件生成。vector.S文件的主要内容是定义了256个中断向量处理程序的入口，在中断时的有的会自动压入errorNumber，有的不会，vector.S中的不会自动压入errorNumber的会压入一个0，以统一结构。每一个程序再压栈errorNumber（如果CPU不会自动压栈的话）和压栈中断向量号后，同一调转到<code>__alltraps</code>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl __alltraps</span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $0</span><br><span class="line">  jmp __alltraps</span><br></pre></td></tr></table></figure></p>
<p><strong>alltraps是另一个汇编文件trapentry.S中定义的全局符号，链接后会指向trapentry.S中的`</strong>alltraps`。trapentry.S的作用是构造trapframe的栈结构，并调用trap函数，trap函数返回后出栈trapframe的结构。因为涉及到特定寄存器的入栈出栈，这一部分代码用汇编语言描述最方便。</p>
<p>vector.S中定义了全局段全局符号<code>__vectors</code>，其值是一个数组的起始地址，数组的每一项是每一个入口程序的地址。因为符号<code>__vectors</code>是全局符号，所以可以在C程序中可以直接访问，因为链接后会加入到符号表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># vector table</span><br><span class="line">.data</span><br><span class="line">.globl __vectors</span><br><span class="line">__vectors:</span><br><span class="line">  .long vector0</span><br><span class="line">  .long vector1</span><br><span class="line">  .long vector2</span><br><span class="line">  .long vector3</span><br><span class="line">  .long vector4</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>再idt_init进行idt初始化的时候，要做的事情就是构造IDT表并填充表项。<code>__vectors</code>中已经有了中断处理函数的地址，只需要在设置DPL等等其他表项的内容，就能构造出来IDT表。最后将IDT表的地址使用lidt指令加载到IDTR寄存器中，我们就完成了中断向量表的初始化。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-03T03:20:50.000Z" title="2019-12-03T03:20:50.000Z">2019-12-03</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">33 minutes read (About 4944 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B04%EF%BC%9Abios%E5%92%8Cbootloader%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">ucore-os笔记4：bios和bootloader的启动过程</a></h1><div class="content"><p>这篇笔记学习BIOS和bootloader的执行过程，将详细分析机器加电后执行的第一条指令到操作系统的第一行代码中间经历的过程。</p>
<h2 id="BOIS的启动过程"><a href="#BOIS的启动过程" class="headerlink" title="BOIS的启动过程"></a>BOIS的启动过程</h2><p>计算机开机后并不是直接启动操作系统，而是先要执行一小部分初始化软件。在80386体系结构下由BIOS和BOOTLOADER组成。BOIS是存储在主板上ROM中的一个小程序，承担了最基础的输入输出功能（电脑没装系统时，我们也可以进入BOIS，BOIS中可以看到计算机的硬件信息，设置启动盘等等，其包括了对硬件最最基本的访问能力）。</p>
<p>计算机加电后，将BIOS加载内存中开始执行。会从一条特定的地址开始执行，该指令调转到BIOS程序的起始地址执行。BIOS会检测硬件并进行初始化，然后会选择一个启动设备。然后将该设备的第一个扇区（512字节）加载到内存的特定地址（0x7c00）。然后将控制权转交给0x7c00地址处的程序开始执行。</p>
<p>简单来说，当我们按下电脑的开机键后，CPU会进行如下的处理：</p>
<ol>
<li>BIOS被加载到内存中</li>
<li>CPU的第一条指令是调转到BIOS程序的第一条指令（1、2步都是硬件预先设计好的）</li>
<li>开始执行BIOS，BIOS会初始化显示器、检测计算机总线上连接的所有硬件；一切正常后将启动盘的第一个扇区（512个字节）加载到内存的0x7c00处，然后调转到0x7c00执行。所以我们的bootloader会放在磁盘的第一个扇区，大小小于512字节，BIOS执行完了就会执行bootloader的指令。</li>
<li>bootloader执行，切换执行模式，加载操作系统内核，将控制权交给操作系统。</li>
<li>操作系统初始化</li>
</ol>
<blockquote>
<p>BIOS初始化是硬件自动的。启动的时候，硬件会将BIOS映射到高位内存地址中，以保证向下兼容8086的启动模式。</p>
</blockquote>
<h2 id="bootloader的启动过程"><a href="#bootloader的启动过程" class="headerlink" title="bootloader的启动过程"></a>bootloader的启动过程</h2><p>BIOS读取硬件扇区到0x7c00的内存中，并调转到0x7c00执行。所以bootloader被放在0x7c00的位置开始执行。（<strong>所以在makefile中链接bootblock的时候，将代码段地址设置成0x7c00。目前不懂这里链接指定的地址有什么用？后面学会了回来该</strong>）</p>
<p>bootloader的主要工作是：</p>
<ul>
<li>切换到保护模式，启用分段机制</li>
<li>读取ELF执行文件格式ucore操作系统到内存中</li>
<li>显示字符串信息</li>
<li>把控制权交给ucore操作系统</li>
</ul>
<p>接下来我们详细分析下面两个部分：</p>
<ul>
<li>如何切换到保护模式？（如果不了解什么是保护模式，请先阅读<a href="#">实模式与保护模式</a>）</li>
<li>如何读取ELF执行文件格式？（如果不了解elf文件格式，请先阅读<a href="#">elf文件结构</a>）</li>
</ul>
<h3 id="如何从实模式切换到保护模式"><a href="#如何从实模式切换到保护模式" class="headerlink" title="如何从实模式切换到保护模式"></a>如何从实模式切换到保护模式</h3><p>从实模式切换到保护模式要经历两个步骤：</p>
<ol>
<li>开启a20 gate</li>
<li>启用80386的分段机制实现保护</li>
</ol>
<p>下面分别说明这两个部分：</p>
<ol>
<li>开启a20 gate<br>8086处理器是16位的，只能以实模式运行，最大只能访问1MB内存。但是通过segment:offset的形式，可以得到高于1MB的地址。在这种情况下，8086会将高于1MB的地址“回卷”（只取前20位，溢出的部分舍弃），变成低于1MB的地址。一些8086的软件用到了这样的特性。在80386中，最大内存是4GB，超过1MB就不会“回卷”了，这样就不向下兼容了。所以有了A20 gate（A0-A19是20根地址线），A20 gate默认是不启用的，这样实模式下就只能访问1MB的内存，<strong>保证向下兼容</strong>。</li>
</ol>
<p><strong>因为a20 gate只是控制第21根地址的开启和关闭</strong>。在80386下（大于1MB的内存），如果开启了a20 gate：</p>
<ul>
<li>实模式下就可以访问<code>ffff0+0ffff=10ffef=1088KB</code>的内存，超出的64KB也能访问；</li>
<li>保护模式下能够访问完整的4G内存</li>
</ul>
<p>如果没有开启a20 gate：</p>
<ul>
<li>实模式下只能访问1MB的内存</li>
<li>保护模式下，<strong>a20始终位0</strong>，那么只能访问奇数兆的内存0-1M，2-3M…</li>
</ul>
<p>计算机开机以后是以实模式运行，我们的操作系统是面向32位CPU设计的，所以在bootloader中要启用全部的32根地址线。从实模式切换到保护模式的第一步就是开启a20 gate。</p>
<p>a20 gate的开启和关闭使用<strong>通过键盘控制器8042来控制</strong>的（需要通过一种方式来控制a20的开启和关闭，工程师们为了<strong>节省硬件设计成本</strong>将其集成到了键盘控制器中，a20 gate和键盘没有关系），所以我们需要通过io指令向键盘控制器8042发出控制命令，启用a20。bootasm.S中相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60</span><br></pre></td></tr></table></figure><br><img src="/img/8042键盘控制器.png" alt="8042键盘控制器"><br>8042对外暴露了两个端口：0x60和0x64，下面是对8042的简单介绍：</p>
<ul>
<li>键盘控制器的端口是0x60-0x6f，但是只使用了0x60和0x64两个端口。通过这两个端口给键盘控制器发送命令或者读取状态</li>
<li><p>8042有两个寄存器，一个是状态寄存器，保存了控制器当前的状态信息（键盘使用启用，buffer中是否有数据等），另一个是控制寄存器。状态寄存器各位信息如下：<br>  | bit  | meaning  |<br>  |—|—|<br>  |0 |output    register    (60h)    中有数据|<br>  |1 |input    register    (60h/64h)    有数据|<br>  |2 |系统标志(上电复位后被置为0)|<br>  |3 |data    in    input    register    is    command    (1)    or    data    (0)|<br>  |4 |1=keyboard    enabled,    0=keyboard    disabled    (via    switch)|<br>  |5 |1=transmit    timeout    (data    transmit    not    complete|)<br>  |6 |1=receive    timeout    (data    transmit    not    complete)|<br>  |7 |1=even    parity    rec’d,    0=odd    parity    rec’d    (should    be    odd)|</p>
</li>
<li><p>0x64端口用于写入命令，读取状态信息。0x60用于写入和读取数据。在0x64端口状态信息；写0x64端口写入命令。</p>
</li>
<li>8042有两个内部端口（上图中有），这两个内部端口在内部电路中使用，程序员不可见，但是通过向0x64端口写入特定的命令可以改变这两个端口的数据。我们本次要改的a20控制就在内部输出端口的p21，这个信号控制a20的开启和关闭。</li>
</ul>
<p>设置键盘控制器的步骤是：</p>
<ol>
<li>等待8042的输入缓存为空。等待上一条IO命令结束，结束后会清空标识寄存器。因为CPU的速度远快于IO设备的速度，所以一定要加这个判断。</li>
<li>向0x64写入设置内部输出端口的命令</li>
<li>等待输入缓存为空</li>
<li>向0x60写入要设置的值</li>
</ol>
<p>在代码中，<code>inb $0x64,%al</code>和<code>testb 0x2,%al</code>用于判断键盘控制器的输入缓存是否为空。0x2=00000010，对照上面状态寄存器的第二位，1表示input register中有数据，当有数据时，重复，直到没有数据为止。</p>
<p>然后向0x64写入命令0xd1，表示写内部输出端口，然后写入0xdf(11011111)，将p21置高电平，其他的位可以不管，是键盘控制器细节相关的，我们这里只了解一下就可以了。</p>
<blockquote>
<p>计算机接口技术课程的相关知识：一个IO设备控制器一般会占用多个端口，分别是状态端口、数据端口、控制端口，一般都是通过控制端口输入控制字，控制字可以设置要对IO控制器进行的操作，如读取IO设备状态、向设备写入数据等等；控制寄存器用于写入IO设备控制器的操作命令，通过改变控制寄存器的相关位，就可以改变控制器的工作模式，例如从写数据切换到读数据。通过地址总线或者IO总线来寻址到特定设备端口，通过数据总线向控制器端口写入或者读取数据，通过控制总线发出一些特定的控制信号。一般来说IO操作的步骤是：</p>
<p>1.向IO设备控制器的控制端口写入控制字<br>2.根据控制字的设置向数据端口写入或者从数据端口读取数据</p>
<p>Intel 80386相关知识：通过out指令寻址的IO设备使用的是IO地址空间，该地址空间和内存地址空间独立。</p>
</blockquote>
<ol start="2">
<li>开启分段机制进入保护模式<blockquote>
<p>这里需要了解保护模式的知识（请学习<a href="#">GDT与保护模式</a>）</p>
</blockquote>
</li>
</ol>
<p>先看bootasm.S中的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure><br>80386及之后的CPU提供了保护模式，主要通过GDTR寄存器和GDT（全局描述符表）来实现。GDTR中存了GDT的入口地址。第一步我们将GDT的地址加载到GDTR寄存器中，使用<code>lgdt gdtdesc</code>从内存中加载GDT的大小和地址到GDTR寄存器中。注意这个时候cr0寄存器中的PE位没有打开，所以CPU还没有启用分段机制，所以此时的内存访问就不涉及到分段的问题。</p>
<p>接下来设置cr0中的PE位，开启了CPU的保护模式。这时候就要设置段寄存器的值了，因为接下来的内存访问就会从GDT中取找对应的段了。所以接下来通过ljmp设置CS寄存器的值，因为CS寄存器的值只能通过调转指令间接设置。然后通过mov指令设置其他段寄存器的值。这样我们就开启了CPU的保护模式。</p>
<h3 id="如何加载操作系统"><a href="#如何加载操作系统" class="headerlink" title="如何加载操作系统"></a>如何加载操作系统</h3><p>前面提到了操作系统的加载由bootloader来实现，bootloader是放在硬盘第一个扇区、大小小于512字节的一段程序，bootloader主要做了两部分的工作，一个是<code>从实模式切换到保护模式</code>，另一个是<code>加载操作系统到ram中并移交控制权</code>。前面我们讨论了如何从实模式切换到保护模式，这里如何加载操作系统。</p>
<p>要理解如何加载操作系统，需要直到两方面的知识，第一个是操作系统的格式细节，这里我们使用的操作系统是ELF格式；另一个如何访问硬盘。下面我们先分别介绍这两方面的知识，因为只有直到ELF文件的格式之后，才能直到如何去读取操作系统并运行。</p>
<h4 id="ELF文件格式介绍"><a href="#ELF文件格式介绍" class="headerlink" title="ELF文件格式介绍"></a>ELF文件格式介绍</h4><p>ELF(Executable    and    linking    format)文件格式是Linux系统下的一种常用目标文件(object file)格<br>式，有三种主要类型:</p>
<ul>
<li>用于执行的可执行文件(executable file),用于提供程序的进程映像,加载的内存执行。<br>这也是本实验的OS文件类型。</li>
<li>用于连接的可重定位文件(relocatable file),可与其它目标文件一起创建可执行文件和共<br>享目标文件。</li>
<li>共享目标文件(shared object file),连接器可将它与其它可重定位文件和共享目标文件连接<br>成其它的目标文件,动态连接器又可将它与可执行文件和其它共享目标文件结合起来创<br>建一个进程映像。</li>
</ul>
<blockquote>
<p>参考资料：<img src="http://www.skyfree.org/linux/references/ELF_Format.pdf" alt="ELF_format"><br>这里只介绍第一种，也就是可执行文件的格式。</p>
</blockquote>
<p><a href="/img/elf-overview.png">elf-overview</a></p>
<p>可以看到ELF文件最开始的部分是ELF header，header包含了elf文件的所有信息，包括程序的每一部分大小、位置等等。对于可执行文件，其次最重要的就是<code>program header table(pht)</code>，pht包含了如何创建一个进程映像的信息，可执行文件必须含有pht。pht并不一定就紧跟在header后面，除了elf header以外的其他部分的顺序是不确定的。</p>
<h5 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_magic;     <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> e_type;      <span class="comment">// 1=relocatable, 2=executable, 3=shared object, 4=core image</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_machine;   <span class="comment">// 3=x86, 4=68K, etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_version;   <span class="comment">// file version, always 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_entry;     <span class="comment">// entry point if executable</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_phoff;     <span class="comment">// file position of program header or 0，程序头表在文件中的字节偏移。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_shoff;     <span class="comment">// file position of section header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_flags;     <span class="comment">// architecture-specific flags, usually 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_ehsize;    <span class="comment">// size of this elf header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phentsize; <span class="comment">// size of an entry in program header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phnum;     <span class="comment">// number of entries in program header or 0，程序头表的项数。</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shentsize; <span class="comment">// size of an entry in section header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shnum;     <span class="comment">// number of entries in section header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shstrndx;  <span class="comment">// section number that contains section name strings</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>elf header的前16个字节用于标识一个elf文件，前四个字节是magic number，表示这个文件是一个elf文件，后面的12个字节表示elf文件类别，平台等等，这里没有用到，所以我们用<code>uchar elf[12]</code>表示了。其他重要的有entry——程序入口的虚拟地址、program header和phnum。</p>
<p>对于可执行文件其次最重要的是program header，program header是一个特定结构的数组，数组中的每一个元素代表一个section。结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_type;   <span class="comment">// loadable code or data, dynamic linking info,etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_offset; <span class="comment">// file offset of segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_va;     <span class="comment">// virtual address to map segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_pa;     <span class="comment">// physical address, not used</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_filesz; <span class="comment">// size of segment in file</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_memsz;  <span class="comment">// size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_flags;  <span class="comment">// read/write/execute bits</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_align;  <span class="comment">// required alignment, invariably hardware page size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>包含section的偏移，虚拟地址、物理地址、大小等等信息。ucore-os的加载将会利用这些信息，将每一个段加载到指定的内存地址中。</p>
<blockquote>
<p>elf其他格式的解析，会结合操作系统程序的链接、加载一起学习，请看<a href="#">操作系统程序的链接、加载</a></p>
</blockquote>
<h4 id="硬盘访问概述"><a href="#硬盘访问概述" class="headerlink" title="硬盘访问概述"></a>硬盘访问概述</h4><p>当前硬盘数据是储存到硬盘扇区中,一个扇区大小为512字节。读一个扇区的流程(可参看<br>boot/bootmain.c中的readsect函数实现)大致如下:</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p>硬盘访问的具体细节，我们在其他的文章中学习，因为涉及到计算机接口、计算机组成原理等的知识，请看<a href="#">x86下的IO访问详解</a></p>
<h4 id="操作系统加载"><a href="#操作系统加载" class="headerlink" title="操作系统加载"></a>操作系统加载</h4><p>前面我们了解了基础知识，接下来分析操作系统的加载过程，首先分析代码中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the 1st page off disk</span></span><br><span class="line"><span class="comment">// 读取磁盘的第一页到内存中的ELFHRD（0x10000）位置，1页是4K，8个扇区。</span></span><br><span class="line"><span class="comment">// ELF可执行文件的ELF头在最开始的位置，这里将头读出来，然后根据头中的信息去读程序信息</span></span><br><span class="line">readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is this a valid ELF?</span></span><br><span class="line"><span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line"><span class="comment">// ph是程序头段的开始地址</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line"><span class="comment">// eph是程序头段的结束地址（指针+数字的值是：指针值+数据类型大小*数字）</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">    <span class="comment">// 这里p_offset按照扇区对齐去读</span></span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return</span></span><br><span class="line"><span class="comment">// 将ELF文件读入之后，到elf程序的开始地址执行</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br></pre></td></tr></table></figure><br>最开始直接将硬盘的第一页读取到设定的内核起始位置0x10000，注意这个是从第二个扇区开始读，因为第一个扇区是bootloader，所以有<code>offset / SECSIZE + 1</code>。读取的第一页中可能也包含了其他的段，但是这里我们只关心elf header，其他的段后段会再读，读的时候可能会覆盖本次读的段，这些都没有问题。事实上我们也可以按照扇区大小和header的大小向上取整读若干个扇区，但是这里为了方便就直接读一页了。</p>
<p>硬盘读取是一次读取一个扇区，所以我们的硬盘访问分为两个方面：</p>
<p>第一个是按照段来解析，从program header中读取每一个段的虚拟地址、大小和偏移，虚拟地址是加载到内存中的地址，虚拟地址+大小就能确定这个段的范围；这里要注意偏移是指段在文件中的偏移位置，不一定按照扇区对齐了，而读取硬盘却是按照一个一个扇区读取的，所以我们要按照扇区来对齐进行读取，<code>offset / SECSIZE + 1</code>就是扇区号（从1开始，因为0是bootloader），而且这里将硬盘中的内容加载到<strong>连续的内存中</strong>，offset向下取整了，所以其映射到内存位置也要向下调整，所以有<code>va -= offset % SECSIZE</code>。</p>
<p>第二个是按照扇区来读，前面我们已经得到了段的范围和偏移，由偏移可以确定起始扇区，范围可以确定扇区的个数。先按照扇区对齐，然后逐个读入扇区到内存中，就将对应的段加载到了内存中。</p>
<p>最后调用<code>((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))()</code>，将入口地址作为一个没有返回值没有参数的函数指针调用，就将控制权交给了操作系统，后面执行的就是操作系统内核代码了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-03T01:41:03.000Z" title="2019-12-03T01:41:03.000Z">2019-12-03</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">9 minutes read (About 1395 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B03%EF%BC%9Aqemu%E5%92%8Cgdb%E8%B0%83%E8%AF%95/">ucore-os笔记4：qemu和gdb调试</a></h1><div class="content"><p>本篇笔记我们学习qemu和gdb调试，这是调试操作系统内核代码必备的技能。</p>
<p>qemu是通用开源的硬件模拟器，可以模拟完整计算机系统，包括多种CPU架构（x86、x86_61、MIPS、ARM等）、系统总线（PCI、ISA桥等）、VGA显示、PS/2键鼠、PCI和ISA网络适配器、串行端口、USB。这里我们不详细讨论所有的相关知识，只学习我们目前使用到的这一部分。</p>
<p>gdb是gnu调试工具，可以调试编译后的程序。我们在编译操作系统时，要使用GCC的-g选项生成调试信息才能使用gdb调试。gdb提供了单步调试，指令单步调试，调用栈显示等等功能。</p>
<h2 id="qemu基础知识"><a href="#qemu基础知识" class="headerlink" title="qemu基础知识"></a>qemu基础知识</h2><p>通过qemu命令就可以启动qemu模拟器，通过qemu命令的参数可以指令模拟的硬件的参数，例如指定硬盘、串行端口、CPU核心数等等。一个基础示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;</span><br></pre></td></tr></table></figure><br>该命令会启动一个PC系统模拟器，并指定了其并行端口、串行端口、和硬盘镜像。模拟器会模拟一台计算机的启动过程，从硬盘镜像中加载BIOS和bootloader，然后将控制权交给bootloader。</p>
<p>部分命令行参数说明：</p>
<ul>
<li>-no-reboot：退出不重启</li>
<li>-parallel stdio：将模拟器的并行端口重定向为stdio。stdio是unix系统下的标准输入输出，标准输入一般指键盘输入，标准输出和程序执行的进程相关，从shell启动的程序输出到控制台</li>
<li>-hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像。模拟PC启动的时候会从该镜像加载bootloader和操作系统</li>
<li>-serial null：将模拟器的串行端口重新向为null</li>
<li>-monitor stdio：将显示器重定向到stdio</li>
<li>-S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作</li>
<li>-s：-gdb::1234的缩写，等待连接到端口1234。通过-s选项启动远程调试功能，gdb连接到1234端口就可以实现gdb调试qemu中执行的操作系统。</li>
</ul>
<h2 id="gdb基础知识"><a href="#gdb基础知识" class="headerlink" title="gdb基础知识"></a>gdb基础知识</h2><p>gdb是gnu调试器，通过gdb可以调试gcc通过-g选项生成的可执行文件。</p>
<p>gdb的使用很简单，在命令行输入gdb即可进入gdb命令行。-q表示不输出copyright信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bright@localhost ~]$ gdb -q</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><br>在gdb命令行中输入help，可查看可使用的gdb命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type "help" followed by a class name for a list of commands in that class.</span><br><span class="line">Type "help all" for the list of all commands.</span><br><span class="line">Type "help" followed by command name for full documentation.</span><br><span class="line">Type "apropos word" to search for commands related to "word".</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><br>我们看到通过gdb可以设置断点、查看数据、指定文件、查看堆栈、调试源程序等等。当我们要使用某一个功能时，可以通过help来查看，例如我想看调试相关的命令，输入<code>help running</code>，就会有很多调试相关的命令。要锻炼自己看工具说明文档的能力，授人以鱼不如授人以渔。</p>
<p>下面是一些常用命令的总结：</p>
<ul>
<li>run：启动调试程序</li>
<li>break breakpoint：打断点，breakpoint可以是地址或者符号名或者文件名加行号</li>
<li>continue：执行到下一个断点</li>
<li>next：执行下一条语句，调过函数。这个是C代码级的调试，调试汇编的使用需要使用nexti或者stepi。（例如调试bootloader的时候就要用nexti或者stepi）</li>
<li>nexti：执行下一条指令</li>
<li>step：执行下一条语句，进入函数。</li>
<li>stepi</li>
<li>file filename：加载filename文件中的调试信息。这一个指令在执行远程调试的时候必须有，因为远程调试不会加载调试的符号表，需要手动加载。</li>
<li>target remote address：远程调试address，利用这个功能来调试qemu中的操作系统。</li>
</ul>
<h2 id="qemu和gdb实现操作系统源码级调试"><a href="#qemu和gdb实现操作系统源码级调试" class="headerlink" title="qemu和gdb实现操作系统源码级调试"></a>qemu和gdb实现操作系统源码级调试</h2><p>实现源码级调试我们要用到上面提供的两个功能，一个是开启qemu的远程调试端口，另一个是用gdb远程连接qemu的调试端口。</p>
<p>所以我们要做的是，在启动qemu的时候通过-s选项启动:1234端口，通过-S暂停执行（等待gdb连接后在继续执行）:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;</span><br></pre></td></tr></table></figure></p>
<p>然后在gdb中加载符号表、远程连接、设置断点等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file bin&#x2F;kernel</span><br><span class="line">target remote :1234</span><br><span class="line">break *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure></p>
<p>接下来我们在gdb中就可以输入调试命令来调试操作系统内核了。有下面两点要注意：</p>
<ul>
<li>如果是调试bootloader，可以切换到8086调试实模式代码：<code>set arch i8086</code></li>
<li>调试汇编代码要使用stepi或者nexti</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-02T09:27:21.000Z" title="2019-12-02T09:27:21.000Z">2019-12-02</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">8 minutes read (About 1256 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/02/os/ucore_os/ucore-os%E5%AD%A6%E4%B9%A0%E5%89%8D%E8%A8%80/">ucore-os学习前言</a></h1><div class="content"><p>大四了，复习大学四年所学过的专业基础知识。操作系统是复习的第一门课，希望通过操作系统的学习，深入掌握计算机底层的工作原理、串联其他课程（计算机组成原理、计算机接口技术）、学习linux下C/C++的开发，希望能够将整个大学学的大部分知识串联起来。深入了解底层硬件的工作机制以及操作系统的原理和实现。（先不关注IO设备的访问这些，实验代码中都有，等完成所有操作系统实验后有时间再深入这部分细节）</p>
<p>这一系列笔记主要记录了ucore-os操作系统开发和学习的笔记。ucore-os是北大操作系统课程用的实验系统，基于MIT6.828，之前操作系统课程用的就是6.828，这次换成ucore-os，靠自己完整理解并实现操作系统的核心功能。</p>
<p>跟随本笔记的学习的过程是：直接从实验开始，从实验1开始，实验1的笔记中会有该次实验所需要的基础知识链接，先阅读基础知识，然后开始独立完成练<br>习，独立完成后再与笔记中的练习解析对照。基础知识可以先粗略的过一遍，之后遇到的时候不懂再回过来看。<strong>实验最难的部分是实验1和实验2，因为实验1和实验2涉及到大量的硬件知识、编译工具知识，花的时间也最多，但是独立完成实验1实验2并掌握相关的知识后，后面的实验结合操作系统原理知识将一马平川。万事开头难，贵在坚持！</strong></p>
<p>参考资料下载：</p>
<ul>
<li><a href="#">ucore-os-labdoc</a>：ucore-os开发的文档，有练习的要求和一些基础知识，<strong>需要结合该文档才能完成完整的实验</strong></li>
<li><a href="https://css.csail.mit.edu/6.858/2014/readings/i386/toc.htm">80386 refenrence manual</a>：ucore-os基于i386架构开发，所以一定要知道一些cpu硬件相关的知识，如果对于中断、分段、分页、IO、任务切换、保护等硬件机制方面有不理解，<strong>虽然笔记和ucore-os文档中有一些介绍，但是可能有不全或者让你不理解的地方，所以不明白的时候一定要看这个手册！！！贵在坚持！</strong></li>
<li><a href="#">现代操作系统</a>：操作系统原理教材</li>
</ul>
<p>笔记会完整记录：</p>
<ul>
<li>ucore-os开发所需的基础知识，包括基础的硬件知识（段页机制等）</li>
<li>相关开发工具的使用（GCC、make、GDB、qemu、ld等）；</li>
<li>ucore-os的8个实验每一个练习的解析，包括相关原理和代码解析；</li>
<li>ucore-os开发中相关的操作系统原理知识，例如进程调度算法的实现等；</li>
<li>elf文件格式、链接原理等相关知识；</li>
</ul>
<p>这系列笔记的最终目标是帮助能够希望学习和实现操作系统的同学无障碍的完成完整操作系统功能的开发。所以这一系列笔记会有大量的相关前置知识的学习，例如相关硬件知识（段页相关的硬件原理、IO设备访问等等）、软件知识（make工具、elf文件格式、链接器），希望能够解决没有基础的同学开发中的大量疑问。当然这些都是我自己的看的一些书和资料的总结，完全没基础也不行，只是希望能够尽量帮助自己了解相关知识。</p>
<p>我觉得在进行操作系统开发之前需要掌握的基础知识：</p>
<ul>
<li>C语言：C语言语法，尤其是对各种指针（数组指针、指针数组、函数指针）了解。还有结构体的内存分配、字节对齐等。可以参考我的<a href="#">C语言学习笔记</a></li>
<li>汇编语言：32位x86汇编，AT&amp;T语法</li>
<li>英语能力：intel 80386、gcc、make等的文档都是英文的，能够较为流畅的看这些文档。一些博客上有中文的使用教程，但是没有源文档那么详细，建议直接看源文档。</li>
</ul>
<p>其他的相关知识我的笔记里都有。在每一个实验的开头都会给出参考学习资料，里面有前置知识和相关的os原理。</p>
<p>希望通过这一系列的学习，将大学所学的知识融会贯通。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-02T09:24:08.000Z" title="2019-12-02T09:24:08.000Z">2019-12-02</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">7 minutes read (About 1114 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/02/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B05%EF%BC%9A%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">ucore-os笔记5：实模式与保护模式</a></h1><div class="content"><p>这一次笔记学习X86的实模式和保护模式，主要内容是实模式和保护模式的介绍，相关硬件机制的介绍（GDTR寄存器，GDT等），保护模式在内核中的作用，以及如何从实模式切换到保护模式。</p>
<h2 id="实模式与保护模式"><a href="#实模式与保护模式" class="headerlink" title="实模式与保护模式"></a>实模式与保护模式</h2><p>接下来开始实模式与保护模式的学习。在intel 80386以前的CPU，例如8086，使用的都是实模式。实模式下，CPU没有提供保护机制，可以寻址到任意的内存空间，通过segment:offset的形式可以访问任意的物理空间（segment*16+offset=物理空间地址）。而保护模式在CPU层面提供了对内存空间的保护。保护模式通过分段机制来实现对内存的保护，这个分段机制和8086等实模式CPU下的segment不同，实模式下的segment仅仅只是将内存分片，而保护模式下的分段机制，不仅仅将内存分段，并且CPU对各段内存的访问进行权限的检查，实现内存访问的保护。</p>
<p>保护模式为地址空间提供了抽象，实模式直接访问物理空间，那意味者所有的程序都可以访问所有的物理空间，一个程序可以篡改其他程序的数据，这就存在巨大的安全问题；而且直接访问物理内存，程序的并发运行也存在困难，如何确定多个程序的运行地址？如何进行内存的分配和回收？</p>
<p>所以CPU对物理内存空间进行了抽象：所有的进程拥有独立的内存空间，并且对进程的内存空间提供保护。CPU通过<code>重定向</code>来实现分离不同的内存空间，对于应用程序而言，其使用的地址会进行CPU的<code>重定向</code>来映射到真实的物理地址。CPU利用段寄存器GDTR和GDT来实现<code>重定向</code>的功能，程序员看到的地址到达CPU后，会经过GDTR和GDT的重定向，生成另一个地址；同时CPU也会检查GDT中描述符的保护位和当前保护位，来确定当前程序是否有权限访问指定的内存，而且会判断段基地址和段界限，确定访问的内存是否在该段内。由此实现了不同进程的内存之间的隔离、内存权限访问的分级。</p>
<p>CPU中进行内存管理的硬件称为MMU（Memory Management Unit），程序员设置的地址会经过MMU的转化后才会变成真实的物理地址送达地址总线。MMU提供了分段和分页机制来实现内存隔离、内存保护、虚拟内存等等功能。详情请看<a href="#">内存管理基础：分段和分页机制</a></p>
<h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p>BIOS将bootloader加载进内存以后，在实模式下执行，实模式下CPU运行在16位模式，最大访问1MB的内存。内存地址访问地址真实物理地址，不提供任何抽象和保护机制。通过开启A20，设置CRO寄存器中的使能位，可以切换到保护模式，请看<a href="#">bios和bootloader的加载过程</a>。</p>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>保护模式下能够访问所有的物理内存，同时对物理内存进行隔离和保护。通过CPU硬件检查特权位来实现保护，通过分段来进行地址空间的抽象和进程隔离。通过分页可以实现虚拟内存，允许地址空间比实际的物理空间大，通过在内存和磁盘之间进行交换实现。</p>
<p>保护模式下涉及到分段和分页两种机制，这两种机制对应的原理和相关的硬件介绍在<a href="#">内存管理基础：分段和分页机制</a>中学习。</p>
<p>在保护模式下，地址经历的转化过程是：逻辑地址-&gt;分段机制-&gt;线形地址-&gt;分页机制-&gt;物理地址。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-30T02:10:02.000Z" title="2019-11-30T02:10:02.000Z">2019-11-30</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">13 minutes read (About 1952 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/30/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A02/">ucore-os实验1：lab1练习2</a></h1><div class="content"><p>练习1我们已经学习了make的基本语法，ucore-os是如何编译生成的。这个练习我们我们来学习ucore-os是如何启动的。包括内核如何被加载到内存中，内核加载后执行了哪些操作。重点详细学习启动过程中涉及到的硬件知识。部分汇编语言细节不深究，只了解操作系统宏观一些的概念和过程，以及各部分所起到的作用。汇编细节后续有时间再深入学习。</p>
<h2 id="练习2：使用qemu执行并调试lab1中的软件"><a href="#练习2：使用qemu执行并调试lab1中的软件" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件"></a>练习2：使用qemu执行并调试lab1中的软件</h2><p>重点是熟悉qemu和gdb的调试，进行如下练习：</p>
<ol>
<li>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行</li>
<li>在初始化位置0x7c00设置实地址断点，测试断点正常</li>
<li>从0x7c00开始跟踪代码运行，将单步跟踪反汇编得到的代码于bootasm.S和bootblock.asm进行比较</li>
<li>自己找一个bootloader或内核中的代码位置，设置断点并进行测试</li>
</ol>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>答：先对实验过程进行分析和记录，最后给出练习体的到答案</p>
<h3 id="启动qemu并于gdb联调"><a href="#启动qemu并于gdb联调" class="headerlink" title="启动qemu并于gdb联调"></a>启动qemu并于gdb联调</h3><p>首先我们学习硬件模拟器的一些命令和调试方法。通过qemu的命令行参数，可以指定模拟硬件的参数，例如硬盘、显示器等等属性信息。下面首先分析一些命令行参数信息。</p>
<p>Makefile中有：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">qemu-mon: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU)  -no-reboot -monitor stdio -hda $&lt; -serial null</span></span><br><span class="line">qemu: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU) -no-reboot -parallel stdio -hda $&lt; -serial null</span></span><br><span class="line">qemu-nox: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU)   -no-reboot -serial mon:stdio -hda $&lt; -nographic</span></span><br><span class="line">TERMINAL        :=gnome-terminal</span><br><span class="line">debug: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU) -S -s -parallel stdio -hda $&lt; -serial null &amp;</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)sleep 2</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(TERMINAL) -e <span class="string">"gdb -q -tui -x tools/gdbinit"</span></span></span><br><span class="line">debug-nox: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU) -S -s -serial mon:stdio -hda $&lt; -nographic &amp;</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)sleep 2</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(TERMINAL) -e <span class="string">"gdb -q -x tools/gdbinit"</span></span></span><br></pre></td></tr></table></figure><br>选项分析如下：</p>
<ul>
<li>-no-reboot：退出不重启</li>
<li>-parallel stdio：将模拟器的并行端口重定向为stdio</li>
<li>-hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像</li>
<li>-serial null：将模拟器的串行端口重新向为null</li>
<li>-monitor stdio：将显示器重定向到stdio</li>
<li>-S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作</li>
<li>-s：-gdb::1234的缩写，等待连接到端口1234</li>
</ul>
<p>相关命令分析如下：</p>
<ul>
<li>gnome-terminal -e command：启动一个新的gnome-terminal终端，-e command表示在该终端中将command字符串作为命令执行</li>
<li>gdb：运行gnu调试器，可以调试C程序<ul>
<li>-q：不打印copyright信息</li>
<li>-x file：从文件中执行gdb命令</li>
</ul>
</li>
<li>sleep 2：延迟两秒</li>
</ul>
<p>gdbinit中的内容如下（通过命令行输入gdb进行gdb命令模式，然后输入help file等查看命令详情）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel # 表示调试bin/kernel文件，会读取文件中的符号表。该文件要使用-g选项生成才包含调试使用的信息。</span><br><span class="line">target remote :1234 # 连接到目标机器或者进程</span><br><span class="line">break kern_init # 在函数或者行数打断点</span><br><span class="line">continue # 继续执行</span><br></pre></td></tr></table></figure></p>
<p>学习上面的命令行参数，我们得到两个问题的答案：</p>
<ul>
<li>如何在qemu中启动我们生成的ucore.img镜像？使用-hda命令行参数，将ucore.img作为qemu的启动硬盘。启动后qemu模拟硬件会直接开始执行，通过-S参数可以暂停执行。</li>
<li>如何实现源码级调试？通过-s参数，开放qemu的1234端口，让gdb通过target remote命令来连接qemu开发的1234端口。连接以后就可以在gdb窗口中源码级远程调试qemu。</li>
</ul>
<blockquote>
<p>注意：远程调试必须在gdb中手动加载可执行文件，例如<code>file bin/kernel</code>。生成可执行文件的时候必须使用-g参数添加调试信息。调试bootloader时，只能使用逐指令调试（nexti）。调试内核时才能使用逐语句调试（next），推测可能bootloader是用汇编写的。</p>
</blockquote>
<h3 id="实验的预备知识"><a href="#实验的预备知识" class="headerlink" title="实验的预备知识"></a>实验的预备知识</h3><p>这里学习一下计算机开机以后经历的过程。包括BIOS启动、BOOTLOADER执行、操作系统启动等过程。</p>
<h4 id="保护模式和分段机制"><a href="#保护模式和分段机制" class="headerlink" title="保护模式和分段机制"></a>保护模式和分段机制</h4><p>bootloader执行的时候，还处于实模式运行状态，此时是16位的运行状态，只能访问1MB的内存（这些都是由硬件控制的，在硬件层面提供保护）。</p>
<p>实模式将内存分段，代码和数据位于不同的区域（和保护模式的分段不同）。每段最大$2^{16}$字节。通过段地址*16+偏移直接访问物理地址。且不区分操作系统内存和用户程序内存。程序指针能任意改变内存中的任意地址中的内容。</p>
<p>保护模式启用32位运行状态，能够访问4G的线性地址空间和物理地址空间。通过分段存储机制和分页管理机制提供保护。不同的段有不同的特权优先级（硬件层面进行），访问没有优先级的内存CPU将会触发异常。</p>
<blockquote>
<p>保护模式下有两个段表，GDT和LDT。ucore中只用了GDT。GDTR和LDTR两个48位寄存器分别存储了GDT和LDT的起始地址。</p>
</blockquote>
<p>GDTR，GDTR图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">47              16        0</span><br><span class="line">|-----基址-------|-段表长度-|</span><br></pre></td></tr></table></figure><br>LDT是GDT的下一级，如果段寄存器（cs、ds、ss、es、gs、fs等）中的GDT描述符的TL位是1，则说明存在LDT中，此时会先找GDT，GDT对应项的内容时LDT的索引，然后找LDT中的对应项。LDT中的段地址+偏移地址=线性地址。</p>
<p>如果TI=0，则直接从GDT中找。（硬件进行的）</p>
<blockquote>
<p>逻辑地址、线性地址、物理地址：</p>
<p>逻辑地址由段地址和偏移地址组成，段地址存在段寄存器中，偏移地址存在EIP中。逻辑地址也叫虚拟地址，程序中使用的是虚拟地址（指针中的只是逻辑地址中的偏移，还要加上段地址才能得到线性地址。不同程序的段地址不同，这就是硬件提供的保护机制）；段地址和偏移地址的地址表示形式就是逻辑地址。段地址+偏移地址=线性地址。线性地址在页处理机制处理后，就得到了物理地址。如果不启动分页机制，线性地址就是物理地址。</p>
</blockquote>
<p>GDTR存的是GDT的起始地址和长度。GDT表的表项是64位，其中包括段基地址32位，段界限20位，各种段属性。段寄存器中存的是选择子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段选择子</span><br><span class="line">15          3  2   0</span><br><span class="line">|----索引---|TI|RPL|</span><br></pre></td></tr></table></figure></p>
<ul>
<li>索引：表示第几个描述符（0开始），在转成地址的时候要*8（因为一个描述符8个字节）</li>
<li>TI：1则表示在LDT中，0表示在GDT中</li>
<li>RPL：请求优先级，0最高3最低。ucore是使用了0和3。在段选择符被加载进寄存器时就会触发特权检查，只有当前代码段以及段选择符特权均小于等于GDT中描述符中的特权位时，才允许访问，否则CPU会出现保护异常。（硬件判断）</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-08-05T14:13:23.000Z" title="2019-08-05T14:13:23.000Z">2019-08-05</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/">shell</a></span><span class="level-item">12 minutes read (About 1740 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/08/05/os/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8Cshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/Linux%E4%B8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/">Linux下的基本命令</a></h1><div class="content"><p>这篇文章总结了linux下常用的命令，包括文件处理、进程处理、网络通信等等。主要基于《linux shell和脚本编程》的第三章和第四章。</p>
<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><p>linux系统下提供了完整的文件操作的命令，包括新建、删除、移动、赋值、压缩文件和目录。这里我们列举一下linux文件系统下的各目录的作用，常用的文件操作命令。</p>
<h3 id="linux文件目录名称和作用"><a href="#linux文件目录名称和作用" class="headerlink" title="linux文件目录名称和作用"></a>linux文件目录名称和作用</h3><table>
<thead>
<tr>
<th style="text-align:center">目录</th>
<th style="text-align:center">用途</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>/|系统的根目录，所有目录都是其子目录<br>/bin|二进制目录，存放很多用户级的GNU工具，一些系统常用的shell命令的二进制文件会放在这里<br>/boot|启动目录，操作系统启动的配置文件会放在这里，这里的文件丢失或者损坏可能会导致不能开机<br>/dev|设备目录，计算机上挂载的设备（例如USB磁盘）都会在该目录下创建一个设备节点<br>/home|主目录，各非root用户的用户根目录是其子目录<br>/lib|库目录，存放系统和应用程序的库文件<br>/media|媒体目录，可移动设备的常用挂载点（没有挂载的目录时该目录是空的，磁盘挂载的时候可以可以挂载到任意目录，可移动设备挂载到这里只是常用的方式）<br>/mnt|挂载目录，另一个可移动设备的常用挂载点<br>/opt|可选目录，常用于存放第三方软件包<br>/proc|进程目录，存放现有硬件及当前进程的相关信息<br>/root|root用户的主目录<br>/sbin|系统二进制目录，存放许多系统GNU管理员工具<br>/run|运行目录，存放系统运作时的数据<br>/sys|系统目录，存放系统硬件信息的相关文件<br>/tmp|临时目录，在该目录中创建和删除临时工作文件<br>/usr|用户二进制目录，存放用户GNU工具和数据文件<br>/var|可变目录，用以存放经常变化的文件比如日志文件</p>
<h3 id="linux文件目录"><a href="#linux文件目录" class="headerlink" title="linux文件目录"></a>linux文件目录</h3><p>linux中提供了文件链接，分为符号链接和硬链接。如果需要在系统上维护同一个文件的多分副本，除了保存多分单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。</p>
<p>符号链接就是一个实实在在的文件，它指向存放在目录中的某一个地方的另一个文件</p>
<p>硬链接会会创建独立的虚拟文件。其中包含了原始文件的位置和信息</p>
<p>符号链接和硬链接的区别是，符号链接类似与windows下的快捷方式，通过一个独立的文件指向被符号链接的文件，访问链接文件就等于访问源文件，当源文件被删除后，再访问链接文件会报错。硬链接是对文件的一个虚拟拷贝，相当于多个指针指向同一个文件，删除其中一个硬链接不会影响其他的硬链接，硬链接不会创建新的文件，他们都共享同一个文件inode，本质上是同一个文件，只是创建了多个指针指向同一个文件，只要有一个文件指针在，文件就不会被删除。</p>
<p>文件遍历：</p>
<ul>
<li>cd：遍历目录，.代表当前目录，..代表父目录</li>
<li>ls：输出当前目录下的文件列表，-R选项显示子目录，-F选项区分目录和文件</li>
</ul>
<p>文件操作:</p>
<ul>
<li>touch：新建文件</li>
<li>cp [source] [destination]：复制文件，通过-R选项可复制目录</li>
<li>ln：-s选项创建符号链接，不带选项就是创建硬链接</li>
<li>mv：移动或者重命名文件。mv只会影响文件名，不会影响时间戳和其他的文件属性。</li>
<li>rm：删除文件，-i提示，-f强制删除，-r递归删除子目录</li>
<li>vim [file]：使用vim编辑器修改文件</li>
</ul>
<p>目录操作：</p>
<ul>
<li>mkdir：创建目录，要同时创建目录和子目录，需要使用-p参数</li>
<li>rmdir：删除目录，但是只能删除空目录，要删除非空目录，需要使用rm -r</li>
</ul>
<p>文件查看：</p>
<ul>
<li>file：查看文件类型</li>
<li>cat：查看整个文件</li>
<li>more：分页查看</li>
<li>less：more命令的升级版</li>
<li>tail：查看文件尾部</li>
<li>head：查看文件头部</li>
</ul>
<h2 id="进程管理"><a href="#进程管理" class="headerlink" title="进程管理"></a>进程管理</h2><h3 id="探查进程——ps"><a href="#探查进程——ps" class="headerlink" title="探查进程——ps"></a>探查进程——ps</h3><p>ps命令能够探查进程，ps默认情况下不会输出很多信息，需要自己携带选项来获取更多的信息。例如，使用<code>ps -ef</code>来输出所有进程的详细格式。</p>
<p>ps只能显示某个特定时间点的信息，给出的是系统某一个时间点的进程信息片段，如果想观察进程的动态变化，ps命令就力不从心了。</p>
<h3 id="实时检测进程——top"><a href="#实时检测进程——top" class="headerlink" title="实时检测进程——top"></a>实时检测进程——top</h3><p>直接在控制台中输入top，会打印动态变化的进程信息，大概每隔一秒钟变化一次。</p>
<p>其中注意几个特殊的结果参数：</p>
<ul>
<li>%CPU：进程使用的CPU比例</li>
<li>%MEM：进程使用的内存占可用内粗年的比例</li>
<li>PR：优先级</li>
<li>NI：进程的谦让度</li>
<li>VIRT：进程占用的虚拟内存总量</li>
<li>RES：进程占用的物理内存总量</li>
<li>SHR：进程和其他进程共享的内存总量</li>
<li>S：进程的状态（D：可中断的休眠状态，R：运行状态，S：休眠状态，T：跟踪状态或停止状态，Z：僵化状态）</li>
</ul>
<h3 id="结束进程"><a href="#结束进程" class="headerlink" title="结束进程"></a>结束进程</h3><p>当进程挂起时，如果重新激活进程，如何强制关闭进程。</p>
<p>linux采用信号来进行通信。进程如何处理信号是由开发人员通过编程来决定的。linux有两个命令可以向运行中的进程发出进程信号。</p>
<ol>
<li>kill命令<br>kill命令可通过进程ID（PID）给进程发信号。常用的方式是，使用ps -ef|grep &lt;名称&gt;找到进程id，然后通过kill pid来发出关闭进程的信号（一个TERM信号，表示尽可能终止）</li>
</ol>
<h2 id="用户管理"><a href="#用户管理" class="headerlink" title="用户管理"></a>用户管理</h2><h2 id="查看系统信息"><a href="#查看系统信息" class="headerlink" title="查看系统信息"></a>查看系统信息</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">lsb_release -b</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-06-24T00:19:36.000Z" title="2019-06-24T00:19:36.000Z">2019-06-24</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">12 minutes read (About 1836 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/24/os/ucore_os/ucore-os%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/">ucore-os思考与总结</a></h1><div class="content"><h2 id="2019-6-24"><a href="#2019-6-24" class="headerlink" title="2019.6.24"></a>2019.6.24</h2><p>开始着手操作系统的学习和开发，需要了解的知识有很多很多，需要了解linux开发环境，包括linux命令、shell脚本、linux下的编译器gcc的使用（包括gcc的编译选项、makefile的使用、gcc混合编译——内联汇编——c和汇编），还有C语言的细节，结构、函数指针，还有算法、数据结构，还有硬件底层的知识，x86下CPU的工作模式，实模式和保护模式，mmu内存管理硬件单元，分段分页，特殊寄存器，中断处理。操作系统一般都是一个较大型的项目，能够锻炼大型项目的编程能力。一定要坚持下来，可能知识会多一点，但是学到的东西一定会更多！</p>
<p>接下来要一步一步来，首先要把基础学好，linux命令行和shell脚本编程以及gcc、makefile的使用，第一步首先弄清楚ucore整体的编译过程，它用到了linux和gcc makefile的细节都要搞清楚，并做好笔记。</p>
<p>然后开始进行操作系统内核的开发，了解操作系统的硬件基础、内核的工作原理。</p>
<p>然后在进行操作系统顶层的开发。</p>
<p>完成了这些之后，综合内核和已有的库进行扩展，进行网络协议实现等基础设施的建设，希望最终能做出一个带图形界面的完整移动操作系统！</p>
<h2 id="问题记录"><a href="#问题记录" class="headerlink" title="问题记录"></a>问题记录</h2><h3 id="gnu-ld链接器的工作原理？"><a href="#gnu-ld链接器的工作原理？" class="headerlink" title="gnu ld链接器的工作原理？"></a>gnu ld链接器的工作原理？</h3><ol>
<li>如何进行链接？</li>
<li>链接后的地址如何分配？链接指定的地址有什么用，例如0x7c00？</li>
<li>链接后生成的文件的格式？格式各部分和操作系统的关系？</li>
<li>linux上的可执行文件和生成的在硬件上的可执行文件（例如bootloader和操作系统内核）的区别？</li>
</ol>
<h3 id="如何使用objdump、objcopy等工具？"><a href="#如何使用objdump、objcopy等工具？" class="headerlink" title="如何使用objdump、objcopy等工具？"></a>如何使用objdump、objcopy等工具？</h3><ol>
<li>objdump等工具用于什么对象？</li>
<li>这些工具有哪些作用？</li>
</ol>
<h3 id="汇编语言的知识？"><a href="#汇编语言的知识？" class="headerlink" title="汇编语言的知识？"></a>汇编语言的知识？</h3><ol>
<li>代码段？数据段？和操作系统还有硬件的关系？</li>
<li>.code16和.code32的细节？</li>
<li>lgdtr的细节？</li>
<li>.long .word的细节？</li>
</ol>
<h3 id="GCC下如何编译-s文件？"><a href="#GCC下如何编译-s文件？" class="headerlink" title="GCC下如何编译.s文件？"></a>GCC下如何编译.s文件？</h3><p>和编译.o文件一样，直接使用gcc命令，编译得到.o文件。将汇编得到的.o文件和c得到的.o文件进行链接，可以生成可执行文件。这样就能将C和汇编混合编译。在汇编中能够直接使用C函数名作为标签名，链接后会找到C文件中对应的函数。</p>
<h3 id="BIOS提供的功能和作用？"><a href="#BIOS提供的功能和作用？" class="headerlink" title="BIOS提供的功能和作用？"></a>BIOS提供的功能和作用？</h3><ol>
<li>它会被加载到内存中吗？<br>会被加载到内容中，计算机加电以后会将BIOS的内容加载到内存中。CPU调转到内存中BOIS开始的位置执行。</li>
<li>操作系统对硬件的控制和访问与BIOS有关吗？还是BIOS仅用于系统初始化阶段？<br>有关，BIOS是一系列程序的集合，系统初始化的BIOS程序只是其中一个，对于不同的硬件，都有与其对应的BIOS程序。<strong>这里还是不太懂</strong></li>
</ol>
<h3 id="操作系统如何提供对硬件的保护？"><a href="#操作系统如何提供对硬件的保护？" class="headerlink" title="操作系统如何提供对硬件的保护？"></a>操作系统如何提供对硬件的保护？</h3><ol>
<li>是通过分段机制对特定指令的保护吗？<br>是的，IO地址的访问也有优先级，称为IOPL，只有当前代码的优先级高于IO地址优先级时（CPL&lt;=IOPL）才能访问。</li>
<li>如何避免应用层程序直接访问硬件？<br>应用层程序运行在特权级为3的情况下，IOPL一般是0，只有内核能访问。通过分段的优先级控制就能够防止应用层程序访问硬件。</li>
</ol>
<h3 id="ELF格式的细节？"><a href="#ELF格式的细节？" class="headerlink" title="ELF格式的细节？"></a>ELF格式的细节？</h3><ol>
<li>elf文件结构？如何解析？</li>
<li>elf内各段（segment）各节（section）的区别和联系？<br>segment是将多个section放在相同的段中，便于内存管理。section是指.data、.text、.bss等不同的程序节。</li>
</ol>
<h3 id="如何编写自己的bootloader程序？"><a href="#如何编写自己的bootloader程序？" class="headerlink" title="如何编写自己的bootloader程序？"></a>如何编写自己的bootloader程序？</h3><ol>
<li>相关指令、相关IO端口的作用？</li>
<li>intel 80386指令、AT&amp;T语法汇编知识？</li>
<li>实模式到保护模式的切换实现？</li>
<li>操作系统的加载实现？</li>
</ol>
<h3 id="如何初始化中断、键盘、显示器等等设备？"><a href="#如何初始化中断、键盘、显示器等等设备？" class="headerlink" title="如何初始化中断、键盘、显示器等等设备？"></a>如何初始化中断、键盘、显示器等等设备？</h3><ol>
<li>总线如何处理？</li>
<li>IO端口如何处理？</li>
<li>中断如何处理？</li>
<li>在i386模拟上实现并总结其原理。</li>
</ol>
<h3 id="分段模式如何识别不同的段？"><a href="#分段模式如何识别不同的段？" class="headerlink" title="分段模式如何识别不同的段？"></a>分段模式如何识别不同的段？</h3><ol>
<li>如何识别段栈段和数据段，指令一条指令，怎么判断指令中的寻址使用的是哪一个段选择符？<br>在访问内存的时候才涉及到段选择器的问题。intel 80386有默认的使用段寄存器的方式（在intel 80386参考文档的2.5节），当只指定的偏移，没有指定段寄存器的时候，按照下面的规则使用段寄存器：<ul>
<li>指令预获取、指令调转等等指令，使用CS</li>
<li>使用ESP、EBP作为基址寄存器访问内存的时候，使用SS</li>
<li>栈操作命令push、pop等，使用SS</li>
<li>字符串指令，使用ES</li>
<li>不在上面情况中的，使用DS</li>
</ul>
</li>
<li>不同的段是不是有不同多地址空间？<br>是的，一个段就是一个独立的地址空间。GDTR存储了GDT的基址，段寄存器*8+GDTR就是选择符的地址，选择符中有段的基址和偏移。段的基址是线形地址，就是说，这个基址不需要在经过分段基址的转换，直接由基址+偏移得到线形地址。</li>
<li>段和编译器得到的.text和.data等是不是有什么关系？<br>是等价的，不过.text和.data肯定分别放在CS和DS中，但是DS中不仅仅有.data。</li>
</ol>
<h3 id="如何实现不同的进程之间的内存隔离？"><a href="#如何实现不同的进程之间的内存隔离？" class="headerlink" title="如何实现不同的进程之间的内存隔离？"></a>如何实现不同的进程之间的内存隔离？</h3><ol>
<li>分段基址的物理空间重叠怎么处理？</li>
</ol>
<h2 id="milestone"><a href="#milestone" class="headerlink" title="milestone"></a>milestone</h2><ul>
<li>2019.11.04 开始进行ucore-os的开发和学习</li>
<li>2019.11.21 完成对C语言基础知识的复习，也学习了更多的计算机基础相关的知识，例如字节对齐、大端小端、字节序、字符编码等知识。<ul>
<li>未完成1：C语言高级语法总结、GCC扩展（内联汇编等等特性）</li>
<li>未完成2：标准库的使用，包括文件io、并发编程、内存分配等等</li>
</ul>
</li>
<li>2019.11.26 完成对Makefile的分析<ul>
<li>了解了make的基本语法，ld、gcc选项。</li>
<li>了解了ucore.img镜像的构建过程。主要学习make语法、如何编写makefile、以及gcc、ld编译的一些选项等。</li>
<li>了解了bootloader的结构</li>
</ul>
</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-06-18T23:19:08.000Z" title="2019-06-18T23:19:08.000Z">2019-06-19</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/">shell</a></span><span class="level-item">11 minutes read (About 1659 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/19/os/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8Cshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/shell-script%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/">shell script基础</a></h1><div class="content"><p>这里总结shell的基本语法，包括了shell中的一些基本元素/变量，shell脚本语法。</p>
<h2 id="使用多个命令"><a href="#使用多个命令" class="headerlink" title="使用多个命令"></a>使用多个命令</h2><p>之前在命令行中都是输入一个命令，那么如果输入多个命令呢？很简单，将多个命令用分号“;”隔开就可以了，例如：</p>
<blockquote>
<p>date; who</p>
</blockquote>
<h2 id="创建shell文件"><a href="#创建shell文件" class="headerlink" title="创建shell文件"></a>创建shell文件</h2><p>通过分号的方式，我们可以一次性执行多条命令，但是如果下一次我还想执行相同的命令序列怎么办呢？这时候我们可以将命令存到一个文本文件中，然后赋予该包含了shell脚本的文件可执行的权限。</p>
<p>创建shell文件的步骤如下：</p>
<ol>
<li>创建一个文本文件，输入shell命令，例如<blockquote>
<p>touch test.sh<br>vim test.sh<br>然后输入:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#!bin&#x2F;bash</span><br><span class="line"> date</span><br><span class="line"> who</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li>赋予该文本文件可执行的权限<blockquote>
<p>chmod u+x test.sh</p>
</blockquote>
</li>
<li>执行该文件<blockquote>
<p>./test.sh</p>
</blockquote>
</li>
</ol>
<p>注意shell脚本文件的第一行用于指定脚本使用的shell程序，在示例中是<code>#!bin/bash</code>，这一行是必须的。</p>
<h2 id="显示消息"><a href="#显示消息" class="headerlink" title="显示消息"></a>显示消息</h2><p>在shell中输出消息，使用echo命令，例如：</p>
<blockquote>
<p>echo $PATH</p>
</blockquote>
<p>输出当前系统环境变量，当第三方命令需要被配置到path中才能够只能从命令行或者shell脚本中执行。</p>
<h2 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h2><p>变量可以存储临时性的信息，在shell中我们也可以使用变量，变量有自定义变量和环境变量，环境变量是系统定义的，通过环境变量我们可以访问到特定的系统信息，例如$HOME可以访问当前用户的目录，$USER是当前已登陆的用户名，$PATH是shell查找程序的搜索路径。</p>
<p>在shell中可以自定义变量，语法是:varname=value，这三者之间不允许出现空格，例如：</p>
<blockquote>
<p>var1=10;echo $var1;</p>
</blockquote>
<p>注意，在定义var1的时候没有$，使用变量的时候才有$。</p>
<p>如果我想在一条命令中引用另一条命令的输出怎么办呢？有两种方式：</p>
<ol>
<li>使用反引号<code></code></li>
<li>使用$()</li>
</ol>
<p>例如，我想定位到当前工作目录下子目录bin下，可以这样写：</p>
<blockquote>
<p>cd $(pwd)/bin #或者是 cd <code>pwd</code>/bin</p>
</blockquote>
<h2 id="重定向输入和输出"><a href="#重定向输入和输出" class="headerlink" title="重定向输入和输出"></a>重定向输入和输出</h2><p>使用&gt;、&gt;&gt;、&lt;、&lt;&lt;可以重定向输入和输出。原来我们的输出例如，echo $PATH，直接将path输出到了屏幕上，我们要向将它重定向到文件中怎么办呢？使用echo $PATH &gt; path.log，”&gt;”创建一个新的文件path.log，如果该文件已存在，则会擦去该文件的所有内容而填充新的内容。如果希望能够将输出添加到文件的尾部，使用&gt;&gt;。下面对四种重定向进行一下总结：</p>
<ol>
<li>>重定义输出到文件，覆盖文件</li>
<li>>&gt;重定向输出到文件，添加到文件尾部</li>
<li>&lt;将输出重定向到文件。原来我们输入内容可能是从键盘输出，使用重定向可以将输入定位到文件，例如，我想统计某一段文字中的字数，该怎么处理呢？wc &lt; _config.yml</li>
<li>&lt;&lt;是内联重定向符，不是从文件读入，而是从命令行读入，可以执行结束的标志位，例如：<blockquote>
<p>wc &lt;&lt; EOF<br>string1<br>strgin2<br>EOF</p>
</blockquote>
</li>
</ol>
<h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>一个命令的输出可以作为另一个命令的输入，这种叫做管道，使用|，例如netstat -anp|grep :8080，将netstat的结果——网络端口情况的输出，作为grep的输入，从中查找”:8080”。</p>
<h2 id="执行数学表达式"><a href="#执行数学表达式" class="headerlink" title="执行数学表达式"></a>执行数学表达式</h2><p>shell中不能直接写数学运算表达式，要进行数学运算有下面两种方式。</p>
<h3 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h3><blockquote>
<p>expr 1 + 5</p>
</blockquote>
<p>expr只能执行一些简单的运算，例如：+,-,*,/,%,&gt;,&lt;,&gt;=,&lt;=,!,|,&amp;。如果要在shell脚本文件中使用：</p>
<blockquote>
<p>result=$(expr 1 + 5)</p>
</blockquote>
<p>需要把expr命令执行的结果赋值给result。</p>
<h3 id="使用方括号"><a href="#使用方括号" class="headerlink" title="使用方括号"></a>使用方括号</h3><p>bash shell中可以使用$+方括号将数学表达式包裹起来。</p>
<blockquote>
<p>result=$[1+5]</p>
</blockquote>
<h3 id="浮点运算"><a href="#浮点运算" class="headerlink" title="浮点运算"></a>浮点运算</h3><p>上面的两种方式只适用与整数运算，如果要进行浮点运算，需要考虑下面的解决方案，使用bc：</p>
<ol>
<li>bc基本用法<br>bc是内建的bash计算器，允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。能够识别数字（整数和浮点数）、变量、注释、表达式、结构语句（比如if else）、函数。<br>输入bc访问bash计算器：<blockquote>
<p>bc</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bc 1.06.95</span><br><span class="line">Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.</span><br><span class="line">This is free software with ABSOLUTELY NO WARRANTY.</span><br><span class="line">For details type &#96;warranty&#39;. </span><br><span class="line">12*5.4 #输入的表达式</span><br><span class="line">64.8 #计算结果</span><br><span class="line">3.1456*(3 + 5)</span><br><span class="line">25.1648</span><br><span class="line">quit #quit命令退出</span><br></pre></td></tr></table></figure>
<p>浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数位数。print语句允许你打印变量和数字。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">3.44 &#x2F; 5</span><br><span class="line">0</span><br><span class="line">scale&#x3D;4</span><br><span class="line">var1&#x3D;3.44 &#x2F;5</span><br><span class="line">print var1</span><br><span class="line">.6880</span><br></pre></td></tr></table></figure></blockquote>
</li>
<li><p>在脚本中使用bc<br>可以使用变量替换，将某一个命令的输出赋值给其他变量:</p>
<blockquote>
<p>variable=$(echo “options; expression” | bc)</p>
</blockquote>
<p>options部分允许设置变量，expression参数定义通过bc执行的数学表达式。也可以使用脚本中定义好的变量。</p>
<p>如果计算表达式比较长的话上面这种写法就不太好了，可以使用内联输入重定向：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">varible&#x3D;$(bc &lt;&lt; EOF</span><br><span class="line">options</span><br><span class="line">statements</span><br><span class="line">expresstions</span><br><span class="line">EOF</span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>这样可以让表达式放在不同的行中，增加可读性。</p>
</li>
</ol>
<h2 id="退出脚本"><a href="#退出脚本" class="headerlink" title="退出脚本"></a>退出脚本</h2><p>如果我们想要在脚本中中途退出怎么办呢？有时候由于一些特殊的情况，我们不希望继续执行下面的脚本了，这时候我们可以使用exit命令，exit命令后面可以接一个数字，表示退出状态码，正常退出为0，使用$?可以常看上一次的退出状态码。</p>
<h2 id="综合演练"><a href="#综合演练" class="headerlink" title="综合演练"></a>综合演练</h2><p>接下来我们用到这一篇里面的所有知识，来创建一个能够从文件读取计算表达式，然后将计算结果输出到文件的shell脚本。</p>
<ol>
<li>创建shell.sh，并赋予执行权限</li>
<li>编辑shell.sh<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">result&#x3D;$(bc &lt; input)</span><br><span class="line">echo $result &gt;&gt; output</span><br></pre></td></tr></table></figure></li>
<li>编辑input<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">scale&#x3D;4</span><br><span class="line">var1&#x3D;3.14*2</span><br><span class="line">scale&#x3D;0</span><br><span class="line">var2&#x3D;11%10</span><br><span class="line">var1+var2</span><br></pre></td></tr></table></figure>
</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-06-17T00:13:51.000Z" title="2019-06-17T00:13:51.000Z">2019-06-17</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">21 minutes read (About 3099 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/06/17/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A01/">ucore-os实验1：lab1练习1</a></h1><div class="content"><h2 id="练习1：理解通过make生成执行文件的过程"><a href="#练习1：理解通过make生成执行文件的过程" class="headerlink" title="练习1：理解通过make生成执行文件的过程"></a>练习1：理解通过make生成执行文件的过程</h2><p>要求如下：</p>
<ol>
<li>操作系统镜像文件ucore.img是如何一步一步生成的？（需要详细解释Makefile中每一条相关命令和命令参数的含义，以及说明命令参数导致的结果）</li>
<li>一个被系统认为符合规范的硬盘主引导扇区的特征是什么？</li>
</ol>
<p>答：先分析Makefile的整体结构，整个Makefile大概分成下面几个部分（从前到后）：</p>
<ul>
<li>变量定义：定义大量和编译、链接、linux命令、环境变量定义等相关的变量</li>
<li>include：包含了function.mk，function.mk中定义了很多和编译相关的工具函数</li>
<li>函数定义：基于function.mk中的函数再封装了一些函数，用于生成规则并修改前面定义的变量等</li>
<li>规则生成：使用前面定义的函数生成规则，分别生成lib、kernel、bootblock、sign等的规则</li>
<li>ucore.img生成：定义ucore.img生成的规则</li>
<li>通用规则定义：定义了清楚、打分、qemu调试等等规则</li>
</ul>
<p>然后我们从make默认的入口开始——TARGETS。在makefile中有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGETS: $(TARGETS)</span><br><span class="line">.DEFAULT_GOAL: TARGETS</span><br></pre></td></tr></table></figure><br>上面说明了输入make，找的是TARGETS规则，而TARGETS规则依赖的是变量TARGETS扩展后的值。</p>
<p>然后我们找TARGETS变量，发现TARGETS是一个全局变量，其值在function.mk中定义的函数中改变。当调用<code>create_target</code>时，就会向TARGETS后面添加内容。Makefile中对create_target包装了一层<code>create_target_cc</code>，将最后两个参数设置成CC和CFLAGS。我们看看<code>create_target</code>的实现：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> add packets and objs to target (target, <span class="comment">#packes, #objs[, cc, flags])</span></span></span><br><span class="line">define do_create_target</span><br><span class="line">__temp_target__ = $(call totarget,$(1))</span><br><span class="line">__temp_objs__ = $$(foreach p,$(call packetname,$(2)),$$($$(p))) $(3)</span><br><span class="line">TARGETS += $$(__temp_target__)</span><br><span class="line">ifneq ($(4),)</span><br><span class="line"><span class="meta">$</span><span class="bash">$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$<span class="variable">$@</span>)</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(4) $(5) $$^ -o $<span class="variable">$@</span></span></span><br><span class="line">else</span><br><span class="line"><span class="meta">$</span><span class="bash">$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$<span class="variable">$@</span>)</span></span><br><span class="line">endif</span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add packets and objs to target (target, <span class="comment">#packes, #objs, cc, [, flags])</span></span></span><br><span class="line">create_target = $(eval $(call do_create_target,$(1),$(2),$(3),$(4),$(5)))</span><br><span class="line"></span><br><span class="line">create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS))</span><br></pre></td></tr></table></figure>
<p>该函数的作用就是由传进来的参数构建出一个规则。规则生成的方式是：将传进来的target参数扩展成target，packs+objs参数扩展成prerequisites。然后如果有第四个参数，添加编译的recipe，否则使用默认的。</p>
<p>接着我们分析用到了<code>create_target</code>的代码，看看有什么效果，例如：<code>$(call create_target,kernel)</code>。这里只传了target为kernel，那么得到的结果是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TARGETS +&#x3D; bin&#x2F;kernel</span><br><span class="line">bin&#x2F;kernel: | bin</span><br></pre></td></tr></table></figure><br>然后我们看到代码中总共有四次使用到了<code>create_target</code>，分别是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(call create_target,kernel)</span><br><span class="line">$(call create_target,bootblock)</span><br><span class="line">$(call create_target_host,sign,sign)</span><br><span class="line">$(call create_target,ucore.img)</span><br></pre></td></tr></table></figure><br>根据上面的分析，我们得到运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">TARGETS &#x3D; bin&#x2F;kernel bin&#x2F;bootblock bin&#x2F;sign bin&#x2F;ucore.img</span><br><span class="line">bin&#x2F;kernel: | bin</span><br><span class="line">bin&#x2F;bootblock: | bin</span><br><span class="line">bin&#x2F;sign: __objs_sign | bin</span><br><span class="line">  @gcc -g -Wall -O2 __objs_sign -o bin&#x2F;sign</span><br><span class="line">bin&#x2F;ucore.img: | bin</span><br></pre></td></tr></table></figure><br>上面的<code>-g -Wall -O2</code>分别表示输出调试信息，输出警告，采用二级代码优化。-o指定输出的文件名。</p>
<p>所以对于入口<code>TARGETS: $(TARGETS)</code>我们可以得到<code>TARGETS: bin/kernel bin/bootblock bin/sign bin/core.img</code>。接下来我们找kernel和bootblock等为target的规则。</p>
<p>对于kernel，有：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">KOBJS	= $(call read_packet,kernel libs)</span><br><span class="line">kernel = $(call totarget,kernel)</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(kernel): tools/kernel.ld</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(kernel): $(KOBJS)</span></span><br><span class="line">	@echo + ld $@</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o <span class="variable">$@</span> $(KOBJS)</span></span><br><span class="line"><span class="meta">	@$</span><span class="bash">(OBJDUMP) -S <span class="variable">$@</span> &gt; $(call asmfile,kernel)</span></span><br><span class="line"><span class="meta">	@$</span><span class="bash">(OBJDUMP) -t <span class="variable">$@</span> | $(SED) <span class="string">'1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d'</span> &gt; $(call symfile,kernel)</span></span><br></pre></td></tr></table></figure><br>扩展变量之后的结果是：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">kernel = bin/kernel</span><br><span class="line"></span><br><span class="line">bin/kernel: tools/kernel.ld</span><br><span class="line"></span><br><span class="line">bin/kernel: $(__objs_kernel) $(__objs_libs)</span><br><span class="line">  @echo + ld bin/kernel</span><br><span class="line">  @ld -nostdlib -T tools/kernel.ld -o bin/kernel $(__objs_kernel) $(__objs_libs)</span><br><span class="line">  @objdump -S bin/kernel &gt; kernel.asm</span><br><span class="line">  @objdump -t bin/kernel | sed '1,/SYBOL TABLE/d; s/ .* / /; /^$$/d' &gt; kernel.sym</span><br></pre></td></tr></table></figure><br>通过这里我们知道了kernel的编译规则（这里其实是链接），依赖于<code>$(__objs_kernl)</code>和<code>$(__objs_libs)</code>(待会儿说这个是啥)。recipe中的第一行说明当前链接的文件。第二行指定<code>tools/kernel.ld</code>脚本链接，链接<code>$(__objs_kernel)</code>和<code>$(__objs_lbs)</code>，生成bin/kernel。后面的objdump反编译bin/kernel，提取出汇编代码和符号表中的内容。</p>
<p>接下来我们看看这个<code>__objs_kernel</code>的内容是什么。看function.mk中，第一行就是：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OBJPREFIX	:&#x3D; __objs_</span><br></pre></td></tr></table></figure><br>然后发现于下面的几个函数有关：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">packetname = $(if $(1),$(addprefix $(OBJPREFIX),$(1)),$(OBJPREFIX))</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add files to packet: (<span class="comment">#files, cc[, flags, packet, dir])</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> define定义了一个多行变量，作为一个自定义函数。$$是因为<span class="built_in">eval</span>扩展一次，作为make语法解析的时候扩展一次</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果想在作为make解析的时候扩展，使用$$</span></span><br><span class="line">define do_add_files_to_packet</span><br><span class="line">__temp_packet__ := $(call packetname,$(4))</span><br><span class="line">ifeq ($$(origin $$(__temp_packet__)),undefined)</span><br><span class="line"><span class="meta">$</span><span class="bash">$(__temp_packet__) :=</span></span><br><span class="line">endif</span><br><span class="line">__temp_objs__ := $(call toobj,$(1),$(5))</span><br><span class="line"><span class="meta">$</span><span class="bash">$(foreach f,$(1),$$(<span class="built_in">eval</span> $$(call cc_template,$$(f),$(2),$(3),$(5))))</span></span><br><span class="line"><span class="meta">$</span><span class="bash">$(__temp_packet__) += $$(__temp_objs__)</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> add objs to packet: (<span class="comment">#objs, packet)</span></span></span><br><span class="line">define do_add_objs_to_packet</span><br><span class="line"><span class="meta">#</span><span class="bash"> __temp_packet值为__objs_$(2)</span></span><br><span class="line">__temp_packet__ := $(call packetname,$(2))</span><br><span class="line">ifeq ($$(origin $$(__temp_packet__)),undefined)</span><br><span class="line"><span class="meta">$</span><span class="bash">$(__temp_packet__) :=</span></span><br><span class="line">endif</span><br><span class="line"><span class="meta">$</span><span class="bash">$(__temp_packet__) += $(1)</span></span><br><span class="line">endef</span><br><span class="line"></span><br><span class="line">add_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))</span><br></pre></td></tr></table></figure><br>分析代码知道，<code>$(__temp_packet) = __objs_$(4)</code>，<code>__temp_objs</code>值为<code>$(1)</code>将后缀改为<code>.o</code>的文件名。如果是<code>do_add_files_to_packet</code>则还有一个将files编译的过程。</p>
<p>大致知道了<code>__objs_xxx</code>是从哪设置的，接下来具体分析，从Makefile中调用的位置开始：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)</span></span><br></pre></td></tr></table></figure><br>会得到（不是最终结果，稍微扩展了一下便于分析）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">__temp_packet = __objs_libs</span><br><span class="line"></span><br><span class="line">obj/libs/*.d: libs/*.c | obj/libs/</span><br><span class="line">  @cc -Ilibs ...</span><br><span class="line"></span><br><span class="line">obj/libs/*.o: libs/*.c | obj/libs/</span><br><span class="line">  @echo + cc $&lt;</span><br><span class="line">  @cc -I/libs ...</span><br><span class="line"></span><br><span class="line">__objs_libs += obj/libs/*.o</span><br></pre></td></tr></table></figure></p>
<p>这下我们知道<code>__objs_libs</code>的来源及其值了。可以理解了整个项目的构建过程：</p>
<ol>
<li>从<code>TARGET: $(TARGETS)</code>作为入口的rule</li>
<li>TARGETS的值通过<code>create_target</code>函数改变，最后的结果是<code>TARGETS: bin/kernel bin/bootblock bin/sign bin/ucore.img</code>。targets总共有四个依赖</li>
<li>四个依赖分别扩展成：<ul>
<li><code>bin/kernel: __objs_kernel __objs_libs</code>：<code>__objs_kernel</code>和<code>__objs_libs</code>分别是kernel和libs文件夹下c文件编译后得到的.o文件。生成.o文件的规则通过<code>add_files_cc</code>添加。</li>
<li><code>bin/bootblock: obj/boot/*.o | bin/sign</code>：其中，obj/boot/*.o，通过<code>$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))</code>生成规则。注意<code>bin/bootblock</code>的recipe中只是生成了obj/bootblock.out，在脚本中执行了bin/sign，sign将obj/bootblock.out作为输入，输出了bin/bootblock</li>
<li><code>bin/sign</code>：<code>$(call add_files_host,tools/sign.c,sign,sign)</code>生成如何生成.o文件的规则。<code>$(call create_target_host,sign,sign)</code>生成<code>bin/sign: __objs_sign | bin</code>这里的<code>__objs_sign</code>也是在前面add_files_host的时候设置，其值是sign依赖的.o文件</li>
<li><code>bin/ucore.img</code>：到了最关键的ucore.img的生成了，规则是：<code>$(UCOREIMG): $(kernel) $(bootblock)</code>依赖于上面的kernel和bootblock的结果。其recipe脚本为dd命令，拷贝一个文件并转换格式到目标文件。有三条dd命令，第一条是<code>$(V)dd if=/dev/zero of=$@ count=10000</code>拷贝仅仅10000个block。后面两条使用相同的形式将bootblock拷贝到第一个块，kernel拷贝到后面的块，生成了ucore.img</li>
</ul>
</li>
</ol>
<p>再次总结一下，ucore.img的编译过程是：</p>
<ol>
<li>分别设置bin/kernel、bin/sign、bin/bootblock、bin/ucore.img四个文件的规则。kernel和sign的prerequisites都被设置成临时变量<strong>objs_xxx。生成过程就是就</strong>objs_xxx表示的.o文件链接成可执行文件。</li>
<li>临时变量__objs_xxx和全局变量TARGETS在add_files、add_target等工具函数中设置和改变；add_files函数还有从.c到.o文件的编译规则。</li>
<li>bootblock只生成obj/bootblock.out，在bin/sign脚本执行下才会生成bin/bootblock。所以在bootblock的依赖中添加了bin/target作为前置依赖，保证先生成bin/target。</li>
<li>当kernel和bootblock都生成好了以后在生成ucore.img。ucore.img其实只是将bootblock放在了第一个block，kernel放在了后面的block</li>
</ol>
<p>接下来我们分析编译和链接中的选项的意义。包括从.c到.o以及.o链接成结果中使用的选项。首先是gcc：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CFLAGS	:= -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)</span><br><span class="line"></span><br><span class="line">CFLAGS	+= $(shell $(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector)</span><br></pre></td></tr></table></figure></p>
<ul>
<li>-march=i686：生成对应i686指令集的机器码</li>
<li>-fno-builtin：不使用内置函数，除非是使用__builtin_开头的函数</li>
<li>-fno-PIC：<strong>跟硬件有关，暂时没有找到其用处</strong></li>
<li>-Wall：输出警告信息</li>
<li>-ggdb：产生用于gdb的调试信息</li>
<li>-m32：生成32位环境下的代码，此时int和long都视为32bit</li>
<li>-gstabs：使用stabs格式产生调试信息，不需要GDB扩展</li>
<li>-nostdinc：不在系统目录中查找header文件，只有-I等指令指定的目录被搜索（<strong>在操作系统开发中不使用标准库，而自己编写适应目标处理器架构的标准库，此时需要这个指令，将对标准库的搜索重定向到自定义的目录</strong>）</li>
<li>-fno-stacl-protector：-fstack-protector的作用是生成额外的代码用于buffer溢出检查。no的意思应该是不生成额外检查的代码。</li>
<li>-I添加头文件检索目录</li>
</ul>
<p>然后是ld：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">LDFLAGS	:= -m $(shell $(LD) -V | grep elf_i386 2&gt;/dev/null | head -n 1) # 结果是elf_i386</span><br><span class="line">LDFLAGS	+= -nostdlib</span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o <span class="variable">$@</span> $(KOBJS)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">$</span><span class="bash">(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock)</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>-m elf_i386：仿真仿真链接器</li>
<li>-nostdlib：链接的时候仅仅只搜索命令行指定的目录（因为操作系统不使用标准库）</li>
<li>-T：使用链接脚本，指定的链接脚本将替换默认的链接脚本</li>
<li>-N：将代码段和数据段设置成可读和可写的。同时不将数据段按页对齐，同时仅用共享库的链接。</li>
<li>-e start：将start这个明确的符号作为程序开始执行的入口，而不是使用默认的入口。如果没有名字位start的符号，将会视图将entry翻译成数字，并作为入口地址。</li>
<li>-Ttext：将<code>.bss</code>、<code>.data</code>、<code>.text</code>放到指定的绝对地址，例如0x7C00</li>
</ul>
<p>ucore-os的Makefile还是比较复杂的，定义了很多自定义函数，层层嵌套。而且在没有接触过make等相关gcc编译工具的基础上，更加困难了。但是通过产看make、gcc、ld等工具的文档，一边分析，一边学习。通过一周的努力，终于弄清楚了ucore-os内核和bootloader的编译链接并生成img文件的过程。里程碑！</p>
<p>第二问：<br>分析构建bootblock的sign.c源码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span></span><br><span class="line">main(<span class="keyword">int</span> argc, <span class="keyword">char</span> *argv[]) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">st</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Usage: &lt;input filename&gt; &lt;output filename&gt;\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (stat(argv[<span class="number">1</span>], &amp;st) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error opening file '%s': %s\n"</span>, argv[<span class="number">1</span>], strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"'%s' size: %lld bytes\n"</span>, argv[<span class="number">1</span>], (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">    <span class="keyword">if</span> (st.st_size &gt; <span class="number">510</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"%lld &gt;&gt; 510!!\n"</span>, (<span class="keyword">long</span> <span class="keyword">long</span>)st.st_size);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">char</span> buf[<span class="number">512</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buf, <span class="number">0</span>, <span class="keyword">sizeof</span>(buf));</span><br><span class="line">    FILE *ifp = fopen(argv[<span class="number">1</span>], <span class="string">"rb"</span>);</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">size</span> = fread(buf, <span class="number">1</span>, st.st_size, ifp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != st.st_size) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"read '%s' error, size is %d.\n"</span>, argv[<span class="number">1</span>], <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ifp);</span><br><span class="line">    buf[<span class="number">510</span>] = <span class="number">0x55</span>;</span><br><span class="line">    buf[<span class="number">511</span>] = <span class="number">0xAA</span>;</span><br><span class="line">    FILE *ofp = fopen(argv[<span class="number">2</span>], <span class="string">"wb+"</span>);</span><br><span class="line">    <span class="built_in">size</span> = fwrite(buf, <span class="number">1</span>, <span class="number">512</span>, ofp);</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">size</span> != <span class="number">512</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"write '%s' error, size is %d.\n"</span>, argv[<span class="number">2</span>], <span class="built_in">size</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    fclose(ofp);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"build 512 bytes boot sector: '%s' success!\n"</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>sign.c从main接收两个参数，一个是输入文件名argv[1]，另一个是输出文件名argv[2]。首先从获取argv[1]文件的文件信息，通过struct stat获得。然后输出argv[1]的大小并进行判断。如果size &gt; 510则过大，报错退出。然后从读出argv[1]中的内容，并判断读出的内容的大小是不是和stat中st_size属性值一致。如果不是，报错退出。再把前512个字节中的最后两个字节设置成0x55和0xAA。然后把这512个字节写入到argv[2]。</p>
<p>从上面的流程可以看出，规则是：</p>
<ol>
<li>总大小为512字节</li>
<li>最后两个字节空出来填充0x55和0xAA，bootloader的内容必须小于510字节。</li>
</ol>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">Previous</a></div><div class="pagination-next"><a href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/page/3/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">1</a></li><li><a class="pagination-link is-current" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/page/2/">2</a></li><li><a class="pagination-link" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/page/3/">3</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Bright Wu"></figure><p class="title is-size-4 is-block line-height-inherit">Bright Wu</p><p class="is-size-6 is-block">working harder to be better</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing Chaoyang</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">154</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">84</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">115</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wre232114" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wre232114"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://brightblog.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">brightblog.cn</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/spring%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">spring实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/"><span class="level-start"><span class="level-item">Open Source</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/Huaxu/"><span class="level-start"><span class="level-item">Huaxu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/"><span class="level-start"><span class="level-item">Webpack</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Webpack基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">Webpack实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">css基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">css工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/less/"><span class="level-start"><span class="level-item">less</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/sass/"><span class="level-start"><span class="level-item">sass</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/docker/docker-swarm/"><span class="level-start"><span class="level-item">docker swarm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/docker/docker%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">docker基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/"><span class="level-start"><span class="level-item">html5</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/html5/dom/"><span class="level-start"><span class="level-item">dom</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5-API/"><span class="level-start"><span class="level-item">html5 API</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="level-start"><span class="level-item">html5标签和属性</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/svg/"><span class="level-start"><span class="level-item">svg</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/js/js%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">js基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="level-start"><span class="level-item">正则表达式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/linux/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/"><span class="level-start"><span class="level-item">node.js</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/node-js/npm/"><span class="level-start"><span class="level-item">npm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">命令行工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/php/"><span class="level-start"><span class="level-item">php</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/"><span class="level-start"><span class="level-item">spring-boot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/typescript/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">踩坑指南</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vue/cli/"><span class="level-start"><span class="level-item">cli</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue-router/"><span class="level-start"><span class="level-item">vue-router</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">vue实战</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">vue组件开发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/xml/"><span class="level-start"><span class="level-item">xml</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/xml/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/"><span class="level-start"><span class="level-item">学习打卡</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">密码技术</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/"><span class="level-start"><span class="level-item">shell</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/"><span class="level-start"><span class="level-item">ucore</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">操作系统原理</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%AF%AD%E5%8F%A5/"><span class="level-start"><span class="level-item">sql语句</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AF%BC%E8%AE%BA/"><span class="level-start"><span class="level-item">导论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">数据库编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">数据库设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"><span class="level-start"><span class="level-item">图</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="level-start"><span class="level-item">树莓派</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%AF%95%E8%AE%BE/"><span class="level-start"><span class="level-item">毕设</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="level-start"><span class="level-item">模式匹配</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="level-start"><span class="level-item">深度优先搜索</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C语言</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/%E7%94%9F%E8%AF%8D/"><span class="level-start"><span class="level-item">生词</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wireshark/"><span class="level-start"><span class="level-item">wireshark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">问题记录</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="level-start"><span class="level-item">交给子类</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="level-start"><span class="level-item">生成实例</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">适应设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-27T13:07:22.000Z">2020-06-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE3-5%E5%AF%B8%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A5%97%E8%A3%85%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">树莓派3.5寸显示器套装安装操作系统</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:21:47.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/opensource/%E8%B7%A8%E6%A1%86%E6%9E%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%8E%9F%E5%9E%8B%E6%A6%82%E8%A7%88/">跨框架、自定义主题的静态博客系统原型概览</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Open-Source/">Open Source</a> / <a class="link-muted" href="/categories/Open-Source/Huaxu/">Huaxu</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:18:37.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/webpack/webpack%E5%AE%9E%E6%88%98%EF%BC%9A%E6%89%93%E9%80%A0%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%91react%E5%92%8Cvue%E7%9A%84%E6%9E%84%E5%BB%BA%E5%BC%95%E6%93%8E/">webpack实战：打造同时编译react和vue的构建引擎</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Webpack/">Webpack</a> / <a class="link-muted" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/">Webpack实战</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.142Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/php/Smarty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Smarty块度入门</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/php/">php</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.122Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/git/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93/">在centos上搭建git服务器仓库</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/git/">git</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Adapter%E6%A8%A1%E5%BC%8F/"><span class="tag">Adapter模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC/"><span class="tag">GCC</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Huaxu/"><span class="tag">Huaxu</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iterator%E6%A8%A1%E5%BC%8F/"><span class="tag">Iterator模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"><span class="tag">Linux命令行与shell脚本编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Maven/"><span class="tag">Maven</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Open-Source/"><span class="tag">Open Source</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Template-Method%E6%A8%A1%E5%BC%8F/"><span class="tag">Template Method模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%9F%BA%E7%A1%80/"><span class="tag">Webpack基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%AE%9E%E6%88%98/"><span class="tag">Webpack实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/autoprefixer/"><span class="tag">autoprefixer</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/browserslist/"><span class="tag">browserslist</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos7%E5%B7%A5%E5%85%B7/"><span class="tag">centos7工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%8D%95%E4%BD%8D/"><span class="tag">css单位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%9F%BA%E7%A1%80/"><span class="tag">css基础</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B7%A5%E5%85%B7/"><span class="tag">css工具</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B8%83%E5%B1%80/"><span class="tag">css布局</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker-swarm/"><span class="tag">docker swarm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker%E5%9F%BA%E7%A1%80/"><span class="tag">docker基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom/"><span class="tag">dom</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom%E5%9F%BA%E7%A1%80/"><span class="tag">dom基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html-Permission-API/"><span class="tag">html Permission API</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5/"><span class="tag">html5</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5-API/"><span class="tag">html5 API</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="tag">html5标签和属性</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%9F%BA%E7%A1%80/"><span class="tag">js基础</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1/"><span class="tag">js对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"><span class="tag">js对象类型判断</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E6%95%B0%E7%BB%84/"><span class="tag">js数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less/"><span class="tag">less</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E5%91%BD%E4%BB%A4/"><span class="tag">linux命令</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"><span class="tag">linux远程连接</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node-js/"><span class="tag">node.js</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npm/"><span class="tag">npm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postcss/"><span class="tag">postcss</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-boot/"><span class="tag">spring-boot</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring%E5%AE%9E%E6%88%98/"><span class="tag">spring实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E8%AF%AD%E5%8F%A5/"><span class="tag">sql语句</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg/"><span class="tag">svg</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%9F%BA%E7%A1%80/"><span class="tag">svg基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%AE%9A%E4%BD%8D/"><span class="tag">svg定位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tips/"><span class="tag">tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tslint%E5%9F%BA%E7%A1%80/"><span class="tag">tslint基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typescript/"><span class="tag">typescript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore/"><span class="tag">ucore</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore-os/"><span class="tag">ucore-os</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-cli/"><span class="tag">vue-cli</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-router/"><span class="tag">vue-router</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-tips/"><span class="tag">vue-tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"><span class="tag">vue博客后台开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%9F%BA%E7%A1%80/"><span class="tag">vue基础</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%AE%9E%E6%88%98/"><span class="tag">vue实战</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="tag">vue组件开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E8%BF%9B%E9%98%B6/"><span class="tag">vue进阶</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wireshark/"><span class="tag">wireshark</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xml/"><span class="tag">xml</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC-Primer%E3%80%8B/"><span class="tag">《C Primer》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E3%80%8B/"><span class="tag">《C语言编程魔法书》</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8CShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E3%80%8B/"><span class="tag">《Linux命令行和Shell脚本编程》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B/"><span class="tag">《图解密码技术》</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"><span class="tag">二叉树</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="tag">交给子类</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E6%B2%BB/"><span class="tag">分治</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%AF%8D/"><span class="tag">单词</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="tag">命令行工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE/"><span class="tag">图</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%88%98/"><span class="tag">实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="tag">密码技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%BC%E8%AE%BA/"><span class="tag">导论</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><span class="tag">异步编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="tag">操作系统原理</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="tag">数据库编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="tag">数据库设计</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%83%E9%99%90/"><span class="tag">权限</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="tag">模式匹配</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="tag">正则表达式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%95%E8%AE%BE/"><span class="tag">毕设</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="tag">深度优先搜索</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="tag">生成实例</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="tag">踩坑指南</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">适应设计模式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="tag">问题记录</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%95%B01/"><span class="tag">高数1</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 Bright</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("default");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.brightblog.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>