<!doctype html>
<html lang="de"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Category: C语言 - Bright的个人博客</title><meta description="前端开发的技术分享和个人笔记总结"><meta property="og:type" content="blog"><meta property="og:title" content="Bright的个人博客"><meta property="og:url" content="https://www.brightblog.cn/"><meta property="og:site_name" content="Bright的个人博客"><meta property="og:description" content="前端开发的技术分享和个人笔记总结"><meta property="og:image" content="https://www.brightblog.cn/img/og_image.png"><meta property="article:author" content="Bright"><meta property="article:tag" content="前端开发 个人博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.brightblog.cn"},"headline":"Bright的个人博客","image":["https://www.brightblog.cn/img/og_image.png"],"author":{"@type":"Person","name":"Bright"},"description":"前端开发的技术分享和个人笔记总结"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/categories">Categories</a></li><li><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a></li><li class="is-active"><a href="#" aria-current="page">C语言</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-01T01:38:36.000Z" title="2019-12-01T01:38:36.000Z">2019-12-01</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">10 minutes read (About 1492 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/01/c-c++/GCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">GCC内联汇编</a></h1><div class="content"><p>GCC提供了在C语言中嵌入汇编语言的能力。在C语言中嵌入汇编，在操作系统和嵌入式软件中开发很有用，编写底层软件时能够直接访问硬件。但是编写客户端软件时有些汇编指令是不可用的，所以编写windows或者linux下的客户端软件时，使用某些指令可能会出错。因为计算机系统的保护模式会提供对特定指令的保护，这些指令只能在内核态中运行；而一般的应用运行于应用层，特权级最低，仅能通过系统调用来获取访问系统资源。</p>
<h2 id="两种内联汇编语法"><a href="#两种内联汇编语法" class="headerlink" title="两种内联汇编语法"></a>两种内联汇编语法</h2><p>GCC有两种内联汇编语法，一种是简单内联汇编，另一种是扩展内联汇编。简单内联语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asm [volatile] (asm instructions);</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">"pushl %eax;movl $0,%eax;popl %eax;"</span>);</span><br></pre></td></tr></table></figure><br>这种情况下C语言不能和汇编进行交互，而且如果使用的寄存器恰被C编译器分配给其他变量，那么这里对寄存器重新赋值就会出现问题。扩展内联汇编语法</p>
<p>不同的汇编指令之间要用<code>\t\n</code>或者<code>;</code>隔开，表示不同的指令。</p>
<blockquote>
<p>asm、volatile和<code>__asm__和__volatile__</code>是完全相同的，两者均可。</p>
</blockquote>
<h2 id="扩展内联语法"><a href="#扩展内联语法" class="headerlink" title="扩展内联语法"></a>扩展内联语法</h2><p>GCC下通过asm可以在C语言中嵌入汇编指令，如下例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">"movl %1,%%eax;"</span></span><br><span class="line">    <span class="string">"shr %%eax;"</span></span><br><span class="line">    <span class="string">"movl %%eax,%0;"</span></span><br><span class="line">    : <span class="string">"=r"</span>(b)</span><br><span class="line">    : <span class="string">"r"</span>(a)</span><br><span class="line">    : <span class="string">"%eax"</span></span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码通过asm嵌入了一系列汇编指令。通过asm扩展语法，这些汇编指令能够和C语言中的变量进行交互，能够将C语言中变量的值传到汇编中，也能够将汇编中计算的值赋值给C语言中的变量。上面的示例就是将变量a赋值给eax寄存器，然后将eax寄存器右移一位（相当于除2），然后将结果输出给变量b。</p>
<p>asm的语法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(汇编语言模板</span></span></span><br><span class="line"><span class="function"><span class="params">  : 输出操作数</span></span></span><br><span class="line"><span class="function"><span class="params">  : 输入操作数</span></span></span><br><span class="line"><span class="function"><span class="params">  : 使用的寄存器</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br></pre></td></tr></table></figure><br>volatile暗示编译器不需要对这部分代码进行优化。编译器优化时可能会调整指令的位置，如果我们不希望编译器这么做，可以加上volatile让编译器不优化。</p>
<h3 id="汇编语言模板"><a href="#汇编语言模板" class="headerlink" title="汇编语言模板"></a>汇编语言模板</h3><p>这个汇编语言模板起始就是汇编语言，只是指令的操作数用占位符代替。例如：<code>movl %eax, %0</code>。这里的<code>%0</code>就是一个占位符，通过占位符和C语言变量交互。</p>
<p>注意如下要点：</p>
<ul>
<li>模板中的寄存器有两个百分号<code>%%eax</code></li>
<li>使用%0，%1作为占位符和C语言变量交互。先输出后输入，意思就是，如果有2个输出，那么%0、%1就是输出，后面才是输入；如果有三个输出，那么%0、%1、%2是输出、后面是输出，依次类推。</li>
<li>可以通过寄存器寻址：<code>movb (%%eax),%al</code></li>
<li>数字以<code>$</code>开头：<code>$3</code></li>
<li>多个指令之间使用<code>\t\n</code>或者<code>;</code>隔开</li>
</ul>
<h3 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h3><p>通过输入输出参数可以将C语言变量匹配到内联汇编中。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>], i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">150</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl %1,%%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"shl  %%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl %%eax,%0;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">"=r"</span>(<span class="built_in">array</span>[i+<span class="number">1</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">"r"</span>(<span class="built_in">array</span>[i])</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"array[0] = %d, array[1] = %d\n"</span>, <span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><br><code>&quot;=r&quot;(array[i+1])</code>中，<code>=</code>表示输出操作符，<code>r</code>表示值必须放在任意一个寄存器中，输入时会将变量加载到这个寄存器中，输出时会从这个寄存器输出到变量所在的内存中。除了r之外，常用的约束字母如下：</p>
<ul>
<li>m、v、o：内存单元</li>
<li>r：任何通用寄存器</li>
<li>q：abcd四个寄存器之一</li>
<li>l、h：直接操作数</li>
<li>E、F：浮点数</li>
<li>G：任意</li>
<li>a、b、c、d：eax/ax/al、ebx…</li>
<li>S、D：esi或者edi</li>
<li>I：常数（0-31）</li>
</ul>
<p>如果输入和输出时一个操作数，那么可以用下面的方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">"incw %0;"</span></span><br><span class="line">: <span class="string">"=a"</span>(counter)</span><br><span class="line">: <span class="string">"0"</span>(counter));</span><br></pre></td></tr></table></figure><br><code>&quot;0&quot;</code>表示引用<code>%0</code>表示的寄存器，所以输入和输出使用的是同一个寄存器。</p>
<h3 id="使用的寄存器"><a href="#使用的寄存器" class="headerlink" title="使用的寄存器"></a>使用的寄存器</h3><p>最后一个冒号接的是使用的寄存器，告诉编译器我需要这些寄存器或者这些寄存器的值已经改变；编译器在分配寄存器的时候就会考虑这些因素。</p>
<p>如果使用<code>memory</code>，表示某些内存中的值已经改变。如果之前编译器已经将该内存的值放在了寄存器中，那么会导致数据不一致。使用memory告诉编译器这个信息，编译器会处理这些情况。</p>
<h2 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a><code>__attribute__</code></h2><p><code>__attribute__</code>用于在函数和变量声明的时候，给编译器设置一些属性，从而实现对函数的优化和对变量声明的控制。</p>
<p>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fatal_error</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mong</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> id;</span><br><span class="line">  <span class="keyword">int</span> code __attribute__((align(<span class="number">4</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>告诉编译器这个函数没有返回值，所以编译器编译时会进行优化，不产生函数返回相关的代码；结构体中的成员按照4字节对齐。</p>
<p>常用的属性值如下：</p>
<ul>
<li>always-inline：将函数作为inline函数，尽可能优化并放在CPU能够尽快取到的位置</li>
<li>packed：用于结构体成员，表示拥有尽可能小的对齐属性；用于结构体，表示结构体的总大小尽可能小。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-23T07:28:06.000Z" title="2019-11-23T07:28:06.000Z">2019-11-23</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">a minute read (About 180 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/23/c-c++/GCC%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/">GCC常用选项</a></h1><div class="content"><p>这篇文章学习GCC中的常用选项。</p>
<h2 id="I-dir"><a href="#I-dir" class="headerlink" title="-I dir"></a>-I dir</h2><p>将dir目录添加到预处理过程中搜索include头文件的目录中。通过-isyatem和-idirafter可以指定<code>include &lt;file&gt;</code>和<code>include &quot;file&quot;</code>的搜索路径。</p>
<h2 id="M"><a href="#M" class="headerlink" title="-M"></a>-M</h2><p>输出一个适用于make的规则，而不是输出预处理的结果。该规则描述了主要源文件的依赖关系。</p>
<h2 id="MM"><a href="#MM" class="headerlink" title="-MM"></a>-MM</h2><p>和-M类似，但是不mention在系统头文件目录中找到的头文件。不能是直接还是间接的都不会从这样的头中包含。</p>
<h2 id="MT"><a href="#MT" class="headerlink" title="-MT"></a>-MT</h2><p>改变被依赖生成发射的rule的target。-MT选项将target设置成你指定的字符串。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-20T14:37:38.000Z" title="2019-11-20T14:37:38.000Z">2019-11-20</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">9 minutes read (About 1318 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/20/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/C%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E7%AF%871%EF%BC%9A%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/">C语言深入篇1：指向数组和函数的指针</a></h1><div class="content"><p>前面我们学习过指针、数组、函数的概念，也了解了指向数组和函数的指针。这里深入理解和学习指向数组和函数的指针。</p>
<p>首先我们从类型的概念入手，每一种指针都有自己的类型，要了解指向数组和函数的指针，首先需要理解这两种指针指向的数据类型。</p>
<p>然后了解这两种类型的变量的声明方式以及理解。</p>
<p>然后学习这两种类型复合类型，例如：指向数组的指针的数组怎么表示？指向函数的指针的数组怎么表示？如果作为函数的参数类型和返回类型？</p>
<h2 id="如何理解指针的类型"><a href="#如何理解指针的类型" class="headerlink" title="如何理解指针的类型"></a>如何理解指针的类型</h2><p>C语言中的指针的值是一个地址，在64位系统中，始终是8个字节，那么<code>int *</code>和<code>double *</code>有什么区别呢？前面的学习文章也提到过，区别在于，如何解释指针的值，也就是指向的地址，中的内容。</p>
<p>如果是<code>int *</code>，则将指针指向的地址作为起始地址，到其后4个字节的内容解释为1个int型的整数。</p>
<p>指向数组和函数的指针也是指针，自然也有上面的结论，所以我们知道：</p>
<ol>
<li>指向数组的指针的值，是一个数组的地址</li>
<li>指向函数的指针的值，是一个函数的地址</li>
</ol>
<p>学习数组的时候，我们知道<code>int *</code>可以指向一个数组，那和指向数组的指针有什么区别呢？</p>
<p><code>int *p = &amp;a</code>表示的是指向数组的起始地址，并将起始地址之后的4字节字节作为int解释。<strong>所以一种解释是，<code>int*</code>指向的是数组的元素，通过移动<code>int*</code>指针可以访问数组元素</strong></p>
<p><code>int(*pa)[n] = &amp;a</code>表示的是指向数组的起始地址，并将起始地址之后的4<em>n个字节作为<strong>数组</strong>解释。<strong>所以指针pa指向的是数组</strong>，`</em>pa<code>取到是数组，我们要取数组元素怎么办？</code>(<em>pa)[i]<code>，</code>(</em>pa)<code>是数组，加括号是因为运算符优先级的原因。因为</code>*pa<code>和</code>p[0]<code>是等同的，我们也可以写成</code>pa[0][i]`</p>
<p>如果指向数组的指针指向了二维数组呢？例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> aa[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;;</span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">3</span>] = &amp;a;</span><br></pre></td></tr></table></figure><br>和上面一样理解，pa指向二维数组a的地址；这里我们首先要了解一个概念，二维数组元素也是连续存放的，假设是<code>[1,2,3,4,5,6]</code>，那么<code>(*pa)</code>或<code>pa[0]</code>取到的就是一个数组，其值是<code>[1,2,3]</code>，<code>*(pa+1)</code>或者<code>pa[1]</code>值是<code>[4,5,6]</code></p>
<p>由此我们也能知道<code>int **p</code>的含义，指针的值还是一个指针。</p>
<h2 id="两种指针的类型和变量声明方式"><a href="#两种指针的类型和变量声明方式" class="headerlink" title="两种指针的类型和变量声明方式"></a>两种指针的类型和变量声明方式</h2><h3 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><p>指向数组的指针的类型是：<code>类型 (*)[n]</code>，这是指向一维数组的。指向二维数组的呢？<code>类型 (*)[n][m]</code>。依次类推。</p>
<blockquote>
<p>这里要注意类型很重要，在这两种指针类型作为函数返回类型以及作为形参类型的时候，需要正确书写类型，后面会详细说明</p>
</blockquote>
<p>如何声明指针变量呢？<code>类型 (*标识符)[n][m]...</code>，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了一个类型为int(*)[3]的指针</span></span><br><span class="line"><span class="keyword">int</span> (*p)[<span class="number">3</span>];</span><br><span class="line"><span class="comment">// 声明了一个类型为int(*)[3][3]的指针</span></span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">3</span>][<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<p>如何声明指向数组的指针的数组呢？<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明含两个元素的数组，数组成员是int(*)[3]</span></span><br><span class="line"><span class="keyword">int</span> (*pa[<span class="number">2</span>])[<span class="number">3</span>];</span><br></pre></td></tr></table></figure></p>
<h3 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h3><p>类型：<code>类型 (*)(形参列表)</code>。</p>
<p>声明：<code>类型 (*标识符)(形参列表)</code>，<code>类型 (*标识符[n])(形参列表)</code>。</p>
<p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 声明了指向 一个返回类型为int，只有一个int参数的函数 指针</span></span><br><span class="line"><span class="keyword">int</span> (*func)(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个元素的数组，成员是函数指针</span></span><br><span class="line"><span class="keyword">int</span> (*func[<span class="number">2</span>])(<span class="keyword">int</span>);</span><br></pre></td></tr></table></figure></p>
<h2 id="作为函数的参数和返回值"><a href="#作为函数的参数和返回值" class="headerlink" title="作为函数的参数和返回值"></a>作为函数的参数和返回值</h2><h3 id="指向数组的指针-1"><a href="#指向数组的指针-1" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h3><ol>
<li>作为函数返回值类型</li>
</ol>
<pre><code>形式：`类型 (* 标识符(型数列表))[n]`，例如`int (*f(int))[2]`，示例中的`int (* xxx)[2]`表示返回类型为`int(*)[2]`，`f(int)`表示函数名和形参列表的声明。
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> (*func1(<span class="keyword">int</span> n))[<span class="number">3</span>] &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;(<span class="keyword">int</span>[])&#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span> &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</code></pre><ol start="2">
<li><p>作为函数参数类型</p>
<p> 形式：<code>int main(int(*p)[10]);</code></p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数为int(*)[10]类型的函数声明</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span>(*)[<span class="number">10</span>])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func2</span><span class="params">(<span class="keyword">int</span>(*p)[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">sizeof</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 两者结合起来：</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">int</span> (* func3(<span class="keyword">int</span>(*pp)[<span class="number">10</span>]))[<span class="number">10</span>] &#123;</span><br><span class="line">     <span class="keyword">return</span> pp;</span><br><span class="line">    &#125;   </span><br><span class="line">### 指向函数的指针</span><br><span class="line">指向函数的指针和指向数组的指针是类似的。将指针类型换一下就行了，我们直接上代码：</span><br><span class="line">```c</span><br><span class="line"><span class="comment">// 函数指针作为返回类型</span></span><br><span class="line"><span class="comment">// int(* xxx)(int)，表示返回类型为int(*)(int)，xxx是：函数名(形参列表)</span></span><br><span class="line"><span class="keyword">int</span> (* func4(<span class="keyword">int</span>))(<span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数指针作为形参</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func5</span><span class="params">(<span class="keyword">int</span>(*p)(<span class="keyword">int</span> a))</span> </span>&#123;</span><br><span class="line">  p(<span class="number">10</span>);</span><br><span class="line">  <span class="keyword">return</span> (*p)(<span class="number">20</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两者结合</span></span><br><span class="line"><span class="comment">// 返回类型是int(*)(int)</span></span><br><span class="line"><span class="comment">// 参数有两个，一个是int(*)(float)，一个是int(*)[10]</span></span><br><span class="line"><span class="keyword">int</span> (* func6(<span class="keyword">int</span>(* f1)(<span class="keyword">float</span>), <span class="keyword">int</span>(*pa)[<span class="number">10</span>]))(<span class="keyword">int</span>) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-20T08:48:25.000Z" title="2019-11-20T08:48:25.000Z">2019-11-20</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">20 minutes read (About 2977 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/20/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/10.C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8A%E4%B8%8B%E6%96%87/">10.C语言程序的编译上下文</a></h1><div class="content"><p>这篇文章学习C语言编译上下文相关话题。包括对象、函数以及类型标识符的作用域和名字空间，对象和函数的连接以及对象的生命周期。</p>
<h2 id="作用域和名字空间"><a href="#作用域和名字空间" class="headerlink" title="作用域和名字空间"></a>作用域和名字空间</h2><p><code>标识符</code>可以表示一个对象、函数、自定义类型及其成员、typdef名、调转标签名、宏名、宏形参。</p>
<p><strong>C语言允许标识符被覆盖</strong>，允许真子集作用域覆盖父作用域中的标识符。</p>
<p><code>标识符</code>代表的实体可访问的范围称为<code>作用域</code>。C语言一共有4中作用域：</p>
<ul>
<li>函数作用域</li>
<li>文件作用域</li>
<li>语句块作用域</li>
<li>函数原型作用域</li>
</ul>
<h3 id="文件作用域"><a href="#文件作用域" class="headerlink" title="文件作用域"></a>文件作用域</h3><p>文件作用域从当前源文件开始直到文件结束。</p>
<p>文件作用域内只能含有声明语句（包括函数和变量声明），不能含有其他语句。</p>
<p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// OutStruct定义在文件作用域中</span></span><br><span class="line"><span class="comment">// OutStruct这个标识符在其定义后的文件中都可用</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">OutStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="comment">// 嵌套定义的InnerStruct也有文件作用域</span></span><br><span class="line">  <span class="comment">// InnerStruct这个标识符在其后的文件中也都可见</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">InnerStruct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  &#125; inner;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 同上，定义的枚举常量M1，M2也在文件作用域中，可以直接访问</span></span><br><span class="line">  <span class="keyword">enum</span> MY_ENUM &#123;</span><br><span class="line">    M1,</span><br><span class="line">    M2</span><br><span class="line">  &#125; e;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// sa也具有文件作用域</span></span><br><span class="line"><span class="comment">// 这里能够直接访问嵌套定义的InnerStruct</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa = <span class="keyword">sizeof</span>(struct InnerStruct);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 宏定义是文件作用域</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> M 100</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">OutStruct</span> <span class="title">out</span> = &#123;</span> <span class="number">10</span>, &#123; <span class="number">100</span> &#125;, M2 &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">InnerStruct</span> <span class="title">inner</span> = &#123;</span> <span class="number">20</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The value is %d\n"</span>, out.a + out.inner.i + inner.i + sa - M);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要点：</p>
<ul>
<li>嵌套定义的自定义类型有文件作用域，为了避免命名污染可以使用匿名自定义类型</li>
<li>宏定义有文件作用域</li>
</ul>
<h3 id="函数作用域"><a href="#函数作用域" class="headerlink" title="函数作用域"></a>函数作用域</h3><p><code>调转标签</code>是仅有的具有函数作用域的标识符。而且仅具有函数作用域，不受其他语句块作用域的影响。</p>
<p><strong>goto和标签只能在函数中使用。</strong></p>
<h3 id="函数原型作用域"><a href="#函数原型作用域" class="headerlink" title="函数原型作用域"></a>函数原型作用域</h3><p>简单来说，就是函数原型的形参列表。例如：<br><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回类型为int(*)[4]，参数列表为int a, int (*)[4]</span></span><br><span class="line"><span class="comment">// 这里定义的a，只在形参列表中可用</span></span><br><span class="line">static int (*Foo(int a, int (*pArray)[sizeof(a)]))[sizeof(int)]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果改成这样，就不行了，提示a未定义，因为超出了作用域</span></span><br><span class="line">static int (*Foo(int a, int (*pArray)[sizeof(a)]))[sizeof(a)]</span><br></pre></td></tr></table></figure></p>
<h3 id="语句块作用域"><a href="#语句块作用域" class="headerlink" title="语句块作用域"></a>语句块作用域</h3><p>如果一个标识符出现在语句块内，或者在<strong>函数定义</strong>的形参内，则具有语句块作用域。语句块是<code>{}</code>内的内容。</p>
<p>这里的<code>{}</code>不包括结构体联合体声明时的<code>{}</code>，它们属于声明语句，而不是语句块。</p>
<p>代码和注意事项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="comment">// 报错，a未定义，因为a未定义在任何作用域中，它是结构体的一部分</span></span><br><span class="line">  <span class="keyword">int</span> b[<span class="keyword">sizeof</span>(a)];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// struct InnerStruct具有文件作用域</span></span><br><span class="line">  <span class="comment">// 但是inner不是</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">InnerStruct</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">  &#125; inner;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里能访问strcut InnerStruct</span></span><br><span class="line">  <span class="keyword">int</span> c[<span class="keyword">sizeof</span>(struct InnerStruct)];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 这里的argc和argv都是语句块作用域</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 这里的i在for语句块中有效</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="标识符的重定义和叠加"><a href="#标识符的重定义和叠加" class="headerlink" title="标识符的重定义和叠加"></a>标识符的重定义和叠加</h3><p>如果内部作用域是外部作用域的真子集，那么内部作用域会覆盖外部作用域中的同名变量。</p>
<h3 id="标识符的名字空间"><a href="#标识符的名字空间" class="headerlink" title="标识符的名字空间"></a>标识符的名字空间</h3><p>前面提到了不同作用域中的标识符覆盖，这里学习<strong>同一作用域</strong>下的同名标识符的识别——名字空间。</p>
<p>C语言的名字空间和C++的命名空间(namespace)不是一回事。这里的名字空间用于区别同一作用域下不同类别的相同标识符。</p>
<p>有4类名字空间：</p>
<ul>
<li>调转标签名</li>
<li>自定义类型</li>
<li>结构体成员，通过.或者-&gt;访问的标识符</li>
<li>其他标识符</li>
</ul>
<p>同一类的标识符无法区分，如果重复定义编译器会报错。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="comment">// 下面会报错，重复定义a</span></span><br><span class="line"><span class="keyword">int</span> a;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面不会报错，因为struct属于不同的命名空间</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">a</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 下面会报错，struct和enum属于相同的命名空间</span></span><br><span class="line"><span class="keyword">enum</span> a &#123;</span><br><span class="line">  A</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="全局对象和函数"><a href="#全局对象和函数" class="headerlink" title="全局对象和函数"></a>全局对象和函数</h2><p>前面学习了作用域和名字空间，下面学习对象和函数的连接，以及全局对象，静态对象等等。</p>
<p>C语言中函数和对象的连接指：<strong>一个对象或者函数标识符可以在不同作用域或者同一作用域内进行多次声明，而这些重复声明的作用域可以通过连接来引用同一对象或者函数。</strong></p>
<p>C语言有三种连接：外部连接、内部连接和无连接。后面会分别介绍。</p>
<blockquote>
<p>简单来说，连接就是确定不同标识符指向的实体之间的关系。如果是无连接，那么不同作用域内的标识符代表的就是不同的实体，相同作用域内声明相同标识符会报错。如果是外部连接，那么在不同的文件中可以引用同一个实体，只要有一个文件定义了，其他文件引用的都是这个实体，如果多个文件都定义了外部连接的同一标识符，则会报重定义的错误。如果是内部连接，那么该标识符只在该文件中可访问，如果一个函数声明为static，那么其他文件访问不到这个函数（仅只链接的时候，其他文件#include这个文件除外）</p>
</blockquote>
<h3 id="外部连接"><a href="#外部连接" class="headerlink" title="外部连接"></a>外部连接</h3><p>使用extern声明的对象和函数具有外部连接。</p>
<p>当在文件作用域中不使用extern进行定义，extern对象才有实体，并作为一个<strong>全局对象</strong>。简单来说，使用extern声明，在文件作用域的定义实体是全局对象。可以重复声明，但是只能定义一次。</p>
<p>函数默认有外部连接，也就是对于函数，extern和缺省都表示函数有外部连接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ga;</span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ga;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  ga = <span class="number">100</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// linkage.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 对全局对象ga的定义，ga的外部连接声明在test.c中</span></span><br><span class="line"><span class="keyword">int</span> ga;</span><br><span class="line"><span class="comment">// 可以重复定义</span></span><br><span class="line"><span class="keyword">int</span> ga;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 声明为外部连接的全局对象</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">int</span> ma;</span><br><span class="line"><span class="comment">// ma的定义</span></span><br><span class="line"><span class="keyword">int</span> ma = <span class="number">10</span>;</span><br><span class="line"><span class="comment">// 可以重复声明</span></span><br><span class="line"><span class="keyword">int</span> ma;</span><br><span class="line"><span class="comment">// 重复定义会报错</span></span><br><span class="line"><span class="comment">// int ma = 20;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 可以重复声明，声明在该作用域可见</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line">  <span class="comment">// 语句块作用中声明必须带有extern关键字，否则不具有连接</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">  test();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result is %d\n"</span>, ga + ma);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="静态对象和函数"><a href="#静态对象和函数" class="headerlink" title="静态对象和函数"></a>静态对象和函数</h2><p>用static修饰的对象和函数称为<strong>静态对象与函数</strong>。</p>
<p><strong>static声明的<code>文件作用域对象或函数</code>具有内部连接</strong>。定义在语句块作用域中的静态对象没有连接。</p>
<p>内部连接是什么意思呢？就是说明该标识符表示的对象只在该文件中有效。如果我们在多个文件中定义非static的同名对象或者函数，那么会报重复定义的错误。多文件中的static对象是相互独立的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// test.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa = <span class="number">-10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SFoo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  sa++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sa in %s = %d\n"</span>, __FILE__, sa);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  SFoo();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// static.c</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> sa;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">SFoo</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 声明静态对象，只会初始化一次</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> inner = <span class="number">100</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 报错，重复定义</span></span><br><span class="line">  <span class="comment">// static int inner</span></span><br><span class="line"></span><br><span class="line">  inner++;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"inner = %d, sa = %d\n"</span>, inner, sa);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>*argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 报错，非文件作用域内不允许声明静态函数</span></span><br><span class="line">  <span class="comment">// static void SFoo(void);</span></span><br><span class="line">  SFoo();</span><br><span class="line"></span><br><span class="line">  SFoo();</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">  test();</span><br><span class="line">  test();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> sa = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"inner sa = %d\n"</span>, sa);</span><br><span class="line">  SFoo();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> inner = <span class="number">120</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">while</span>(i++ &lt; <span class="number">5</span>) &#123;</span><br><span class="line">    <span class="comment">// 语句块作用域内的static不具有连接，但是在当前作用域及子作用域内是静态对象</span></span><br><span class="line">    <span class="comment">// 静态对象的生命周期是整个程序，作用域是其声明的作用域</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">int</span> inner1 = <span class="number">130</span>;</span><br><span class="line">    inner++;</span><br><span class="line">    inner1++;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"main while inner = %d，inner1 = %d\n"</span>, inner, inner1);</span><br><span class="line">    <span class="comment">// 输出131,132,133,134,135</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"main inner = %d\n"</span>,inner);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：语句块作用域中的static不具有连接，但是具有静态对象的特性。静态对象的生命周期是全局的，同一作用域内只会被初始化一次。</p>
</blockquote>
<h2 id="局部对象"><a href="#局部对象" class="headerlink" title="局部对象"></a>局部对象</h2><p>函数形参，或者语句块作用域内没有用extern或者static声明的变量是局部变量。</p>
<p><strong>局部变量不具有连接</strong>。</p>
<p>之间提到连接是对相同或者不同作用域内同一标识符对同一实体的引用。没有连接就是，没有引用关系，每个标识符代表的内容都是相互独立的。</p>
<p>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">func</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部连接</span></span><br><span class="line">  <span class="keyword">extern</span> <span class="keyword">int</span> ma;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面都是无连接</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> ma1；</span><br><span class="line">  <span class="keyword">int</span> ma2；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的<code>ma</code>具有外部连接，表示他指向的是全局对象<code>ma</code>的实体，对<code>ma</code>的定义可能在其他文件中。</p>
<p>ma1和ma2都是无连接，他们不会去引用其他实体，他们有自己的内存空间。</p>
<blockquote>
<p>扩展：C语言的auto和register，auto告诉编译器该变量自动销毁（C++中的auto用于自动类型推导），C90以后已经废弃。register暗示编译器将该变量放到寄存器中，对于register变量不能取地址，具体存放在哪有编译器决定。</p>
</blockquote>
<h2 id="对象的存储和生命周期"><a href="#对象的存储和生命周期" class="headerlink" title="对象的存储和生命周期"></a>对象的存储和生命周期</h2><p>C语言中的存储区域：</p>
<ul>
<li>全局数据存放区</li>
<li>栈存储区</li>
<li>动态分配的堆存储区</li>
</ul>
<p>代码被放到指令存储区；全局变量被放在全局数据区，这里的全局变量是extern或者static在文件作用域中声明的变量；局部对象和函数形参存储在栈存储区；malloc等分配的内存在堆存储区。</p>
<h2 id="Thread-local对象"><a href="#Thread-local对象" class="headerlink" title="_Thread_local对象"></a>_Thread_local对象</h2><p>C11添加了_Thread_local，是一个存储类说明符，表示该对象在任意线程中是私有的。</p>
<p>_Thread_local要么具有外部连接，要么具有内部连接。_Thread_local对象具有线程存储周期，从线程开始，到线程结束。</p>
<p><code>_Thread_local</code>对象称为线程私有对象。那为什么有线程私有对象呢？因为线程间是共享内存空间的，对于程序的全局地址空间或者堆空间，内存是共享的。使用<code>_Thread_local</code>可以保证不同线程中使用的是独立的对象，不会相互影响。</p>
<p>注意需要使用编译时<code>-l pthread</code>来手动链接pthread库。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pthread.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程私有的对象ta</span></span><br><span class="line"><span class="keyword">static</span> _Thread_local <span class="keyword">volatile</span> <span class="keyword">int</span> ta = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程共有的对象isComplete</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">bool</span> isComplete = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 线程调度函数</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">MyThreadProcedure</span><span class="params">(<span class="keyword">void</span>* param)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Firstly, ta in user thread is %d\n"</span>, ta);</span><br><span class="line">  <span class="comment">// 因为_Thread_local是线程私有对象，所以这里ta和主线程中的ta是独立的</span></span><br><span class="line">  ta = <span class="number">100</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ta in user thread is %d\n"</span>, ta);</span><br><span class="line">  <span class="comment">// isComplete是共享的</span></span><br><span class="line">  isComplete = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ta = %d\n"</span>,ta);</span><br><span class="line">  ta = <span class="number">20</span>;</span><br><span class="line">  <span class="keyword">pthread_t</span> thread = <span class="literal">NULL</span>;</span><br><span class="line">  pthread_create(&amp;thread, <span class="literal">NULL</span>, &amp;MyThreadProcedure, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (!isComplete) ;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ta in main thread is %d\n"</span>, ta);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-19T03:17:56.000Z" title="2019-11-19T03:17:56.000Z">2019-11-19</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">19 minutes read (About 2883 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/19/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/8.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/">8.C语言中的函数</a></h1><div class="content"><p>借助函数可以写出更良好的结构化、模块化代码。</p>
<p>函数调用者传递参数给被调用函数，控制权交给被调用函数（入栈），被调用函数执行完成以后（出栈），返回到函数调用者。</p>
<h2 id="函数的声明和定义"><a href="#函数的声明和定义" class="headerlink" title="函数的声明和定义"></a>函数的声明和定义</h2><ol>
<li><p>声明：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 函数名(类型1 形参1, 类型2 形参2, ...);</span><br></pre></td></tr></table></figure>
<p>形参可为空。函数给明给出了函数原型。原型中可以给出不完整类型，例如<code>(int[])</code>。</p>
</li>
<li><p>定义</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(extern or static) 返回类型 函数名 (参数列表) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数定义如果缺省extern或在static，则默认为extern。</p>
</li>
</ol>
<p>如果函数调用的位置没有发现原型或者函数定义，编译器会警告。最好给函数在最前面声明原型。</p>
<p>函数只能在文件作用域中定义。</p>
<h2 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h2><p>形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">funcName(<span class="keyword">int</span> aa, <span class="keyword">int</span> bb) &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">funcName(a, b);</span><br></pre></td></tr></table></figure><br>a、b称为实参，aa、bb称为形参，形参和实参是相互独立的。调用的时候，会将实参的值赋值给形参。如果是指针，赋值的是指针的值，但是两个指针是相互独立的。如果是结构体，那么会将结构体的所有成员复制到形参对象中。</p>
<h3 id="调用表达式的执行顺序"><a href="#调用表达式的执行顺序" class="headerlink" title="调用表达式的执行顺序"></a>调用表达式的执行顺序</h3><p>C语言标准没有说函数标识的计算对于实参的计算之间有顺序，因此对于函数标识的计算和实参的计算谁先谁后是不确定的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="keyword">static</span> <span class="title">Func1</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"f1 a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"f2 a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"f3 b - a = %d\n"</span>, b - a);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span> (*pFunc[<span class="number">2</span>])(<span class="keyword">int</span>) = &#123; &amp;Func1, &amp;Func2 &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 输出f1 a = 1</span></span><br><span class="line">  pFunc[i++](i);</span><br><span class="line">  <span class="comment">// 输出f2 a = 2</span></span><br><span class="line">  pFunc[i](++i);</span><br><span class="line">  <span class="comment">// 输出f3 b - a = 1</span></span><br><span class="line">  Func3(i++, i);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// gcc下，先计算标识符的表达式，再计算实参表达式</span></span><br><span class="line">  <span class="comment">// 函数调用的时候，先计算前面的实参表达式，再计算后面的实参表达式</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>不同的编译器的表达式计算顺序情况可能不一样。根本原因是为了再多核心处理器下并行。</p>
<p>对一个函数的调用要经历三个步骤：</p>
<ul>
<li>对函数标识表达式计算</li>
<li>函数实参的计算</li>
<li>函数调用</li>
</ul>
<h3 id="函数的栈空间"><a href="#函数的栈空间" class="headerlink" title="函数的栈空间"></a>函数的栈空间</h3><p>每个函数都有自己独立的上下文存储空间，此存储空间是栈式的。</p>
<p>函数中定义的局部对象在函数调用结束后从栈中弹出。</p>
<p>函数调用的的参数传递和返回结果都存储在栈空间中。</p>
<h3 id="通过形参改变实参的值"><a href="#通过形参改变实参的值" class="headerlink" title="通过形参改变实参的值"></a>通过形参改变实参的值</h3><p>使用指针（C++中可以使用引用类型）。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> *a, <span class="keyword">int</span> *b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> temp = *a;</span><br><span class="line">  *a = *b;</span><br><span class="line">  *b = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="数组类型作为函数形参"><a href="#数组类型作为函数形参" class="headerlink" title="数组类型作为函数形参"></a>数组类型作为函数形参</h2><p>如果一个函数的形参是一个数组类型，那么它会被调整为指向该数组元素类型的指针。如果类型还有限定符，在[]中添加，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[<span class="keyword">const</span>])</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>当然，写成下面的形式也是可以的：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>对于函数声明，可以具有不完整类型，例如<code>int[]</code>或者<code>int[*]</code>（表示变长数组类型）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">(<span class="keyword">int</span> a[*])</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义的时候不能在使用int[*]了</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func1</span><span class="params">(<span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a != <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a[0] = %d\n"</span>, a[<span class="number">0</span>]);</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of a = %zu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定a[10]没有作用，因为a会被转为int*</span></span><br><span class="line"><span class="comment">// int a[10]和int a[]没有区别</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> a[<span class="number">10</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(a == <span class="literal">NULL</span>)</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Nil!"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of a = %zu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// GCC下，会被转为const int *，5没有作用</span></span><br><span class="line"><span class="comment">// 实参可以传任意长度的数组</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func3</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="keyword">const</span> <span class="number">5</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++)</span><br><span class="line">    sum += a[i];</span><br><span class="line"></span><br><span class="line">  a[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line">  <span class="comment">// a = NULL; // 报错，a是const，不能被指定为其他值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sizeof a = %zu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func4</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="keyword">const</span> <span class="number">2</span>][*])</span></span>;</span><br><span class="line"><span class="comment">// 这里a的类型是，const int(*)[3]</span></span><br><span class="line"><span class="comment">// 所以输出其长度是12字节</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Func4</span><span class="params">(<span class="keyword">int</span> a[<span class="keyword">static</span> <span class="keyword">const</span> <span class="number">2</span>][<span class="number">3</span>])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of a[0] = %zu\n"</span>, <span class="keyword">sizeof</span>(*a));</span><br><span class="line">  a[<span class="number">1</span>][<span class="number">2</span>] = <span class="number">20</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  Func1((<span class="keyword">int</span>[])&#123;<span class="number">1</span>,<span class="number">2</span>&#125;);</span><br><span class="line">  Func2(<span class="literal">NULL</span>);</span><br><span class="line">  <span class="keyword">int</span> <span class="built_in">array</span>[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"></span><br><span class="line">  Func3(<span class="built_in">array</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"array[0] = %d\n"</span>, <span class="built_in">array</span>[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> darray[][<span class="number">3</span>] = &#123;</span><br><span class="line">    <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span></span><br><span class="line">  &#125;;</span><br><span class="line">  Func4(darray);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"darray[1][2] = %d\n"</span>, darray[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>对于形参，声明数组的长度没有作用，数组形参都被被转为相应的指针</strong></p>
<h2 id="函数的不定参数"><a href="#函数的不定参数" class="headerlink" title="函数的不定参数"></a>函数的不定参数</h2><p>C语言函数形参列表的最后可以使用<code>...</code>表示不定长度的参数。</p>
<p>形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, ...)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 错误，前面至少有一个参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(...)</span></span>;</span><br><span class="line"><span class="comment">// 错误，后面不能再有参数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">func1</span><span class="params">(<span class="keyword">int</span> a, ..., <span class="keyword">int</span> b)</span></span>;</span><br></pre></td></tr></table></figure></p>
<p><strong>因为不定参数的类型不确定，编译器会将精度小于int的实参转为int，float转为double</strong></p>
<p>需要借助<code>&lt;stdarg.h&gt;</code>宏来获取不定形参。涉及到如下宏：</p>
<ul>
<li>va_list：是一个完整类型，保存下面几个宏的状态信息</li>
<li>va_start：初始化va_list对象</li>
<li>va_arg：获取形参，会自动向后移动</li>
<li>va_end：无效化va_list对象</li>
<li>va_copy(dest, src)：src和dest都是va_list对象，将src完全拷贝（包括遍历状态）到dest</li>
</ul>
<p>示例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Mytest1</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  <span class="comment">// 对ap初始化，并指明形参n是在...之前的形参</span></span><br><span class="line">  va_start(ap, n);</span><br><span class="line">  </span><br><span class="line">  <span class="keyword">int</span> a = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">unsigned</span> b = va_arg(ap, <span class="keyword">unsigned</span>);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">double</span> d = va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 传了三个实参，但是取了4个形参，gcc下不会报错，但是取出来的内容是任意值</span></span><br><span class="line">  <span class="keyword">int</span> x = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line"></span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d,b = %u,d = %f\n"</span>, a, b, d);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果直接传一个va_list对象初始化过，则不需要再次初始化</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">double</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> n, va_list ap)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">  <span class="keyword">unsigned</span> b = va_arg(ap, <span class="keyword">unsigned</span>);</span><br><span class="line">  <span class="keyword">double</span> d = va_arg(ap, <span class="keyword">double</span>);</span><br><span class="line">  <span class="keyword">return</span> n + a + b + d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyTest2</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, n);</span><br><span class="line">  <span class="keyword">double</span> result = MyFunc(n, ap);</span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result is %f\n"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span> <span class="keyword">int</span> a,b; &#125;;</span><br><span class="line"><span class="keyword">union</span> MyUnion &#123; <span class="keyword">char</span> c; short s; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于struct和union也能正确取值</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyTest3</span><span class="params">(<span class="keyword">int</span> a, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, a);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> <span class="title">s</span> = <span class="title">va_arg</span>(<span class="title">ap</span>, <span class="title">struct</span> <span class="title">MyStruct</span>);</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">union</span> MyUnion un = va_arg(ap, <span class="keyword">union</span> MyUnion);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of MyUnion is %zu\n"</span>, <span class="keyword">sizeof</span>(un));</span><br><span class="line"></span><br><span class="line">  va_end(ap);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> result = a + s.a + s.b - un.s;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int8_t</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">uint16_t</span> b = <span class="number">20</span>;</span><br><span class="line">  <span class="comment">// 实参会晋升，a、b都会变成int，10.5f会变成double</span></span><br><span class="line">  Mytest1(<span class="number">3</span>, a, b, <span class="number">10.5f</span>);</span><br><span class="line">  MyTest2(<span class="number">5</span>, a, b, <span class="number">10.5f</span>);</span><br><span class="line">  MyTest3(<span class="number">10</span>, (struct MyStruct) &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, (<span class="keyword">union</span> MyUnion) &#123; .s = <span class="number">3</span> &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>要点：</p>
<ul>
<li>va_list能够当作单独的类型使用</li>
<li>不定参数的使用流程如下：<ul>
<li>定义va_list对象ap</li>
<li>va_start(形参,ap)初始化ap</li>
<li>va_arg(ap，类型)获取参数值，自动迭代</li>
<li>va_end(ap)销毁va_list对象</li>
</ul>
</li>
</ul>
<h2 id="函数的递归调用"><a href="#函数的递归调用" class="headerlink" title="函数的递归调用"></a>函数的递归调用</h2><p>递归调用是栈式的，如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f(3)   f(2)    f(1)    f(0)</span><br><span class="line">|---调用-&gt;|-调用-&gt;|---调用-&gt;|</span><br><span class="line">|&lt;-返回---|&lt;-返回-|&lt;---返回-|</span><br></pre></td></tr></table></figure><br>递归一定要注意边界，无限递归会造成栈溢出。</p>
<p>深度搜索，归并等算法都使用递归来实现。</p>
<h2 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h2><p>C99标准加入inline关键字。inline和_Noreturn都属于函数说明符，仅用于函数的声明中。</p>
<p>如果一个函数用inline函数说明符进行声明，那么该函数是一个内联函数，<strong>暗示编译器对该函数的调用尽可能地快</strong>.</p>
<p>具有内部连接的任一函数都可以作为一个内联函数。</p>
<p>下面是内联函数的使用和注意事项：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 外部内联函数中出现静态对象编译器会警告</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">  s += n;</span><br><span class="line">  <span class="keyword">return</span> s + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Func3</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 内部内联函数可以包含static</span></span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">  s += n;</span><br><span class="line">  <span class="keyword">return</span> s + n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// mytest定义在hello.c中</span></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> result = Func(<span class="number">3</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result = %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">  MyTest();</span><br><span class="line"></span><br><span class="line">  result = Func2(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result in main is %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">  result = Func3(<span class="number">1</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result 1 = %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">  result = Func3(<span class="number">2</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result 2 = %d\n"</span>, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// hello.c的内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Func</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> n * <span class="number">3</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这里如果加上extern，就重复定义了，链接器链接的时候会报错</span></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">int</span> <span class="title">Func2</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> <span class="keyword">int</span> s;</span><br><span class="line">  s += n;</span><br><span class="line">  <span class="keyword">return</span> s+n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MyTest</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"value is %d\n"</span>, Func2(<span class="number">2</span>));</span><br><span class="line">  <span class="keyword">int</span> result = Func2(<span class="number">20</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result in MyTest is %d\n"</span>, result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>通过<code>gcc inline.c hello.c</code>，gcc会自动编译两个c文件并链接称可执行程序。</p>
<p>inline的注意点：</p>
<ul>
<li>inline知识给出编译器优化建议，怎么处理有编译器决定</li>
<li>外部连接函数如果用inline声明，那么声明和定义应该在同一个文件中</li>
<li>外部连接的内联函数，不应该使用static对象</li>
</ul>
<h2 id="函数的返回类型与void"><a href="#函数的返回类型与void" class="headerlink" title="函数的返回类型与void"></a>函数的返回类型与void</h2><p>记住下面几个要点就行：</p>
<ul>
<li>返回类型可以是<strong>除了数组之外的任意类型</strong>，可以使用指针实现返回数组的功能</li>
<li>函数遇到return会立即返回，return的表达式类型必须和返回类型兼容</li>
<li>reuturn后面为空，表示返回void</li>
<li>C11引入了<code>_Noreturn</code>，表示该函数体内不应该出现任何return语句，其返回值为void。<code>&lt;stdnoreturn&gt;</code>头文件中定义了<code>noreturn</code>宏</li>
</ul>
<h2 id="指向函数的指针"><a href="#指向函数的指针" class="headerlink" title="指向函数的指针"></a>指向函数的指针</h2><p>函数指针类型的通用表达形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回类型 (* 可选限定符<span class="keyword">const</span>等) (形参列表)</span><br></pre></td></tr></table></figure></p>
<p>函数指针要求和函数定义的返回类型和形参列表一样，但是可以是不完整类型。</p>
<p><strong>对于void Func()，Func和&amp;Func都表示函数指针，类型是<code>void (*)(void)</code></strong>，但是注意对于<code>void (* pFunc)(void)</code>，pFunc是指针，不是函数标识，所以<code>&amp;pFunc</code>肯定不等于<code>pFunc</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdarg.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct <span class="title">MyStruct</span> <span class="params">(*p)</span><span class="params">(struct MyStruct s, <span class="keyword">int</span> a[*])</span> </span>= <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">Foo</span><span class="params">(<span class="keyword">int</span> n, ...)</span> </span>&#123;</span><br><span class="line">  va_list ap;</span><br><span class="line">  va_start(ap, n);</span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">    sum += va_arg(ap, <span class="keyword">int</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  va_end(ap);</span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">void</span>(*pf)(<span class="keyword">void</span>) = Test;</span><br><span class="line">  <span class="comment">// 也可以使用pf()</span></span><br><span class="line">  (*pf)();</span><br><span class="line">  pf();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于数组，a和&amp;a也是相等的</span></span><br><span class="line">  <span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a == &amp;a? %d"</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)a == (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*pFunc)(<span class="keyword">int</span>, ...) = &amp;Foo;</span><br><span class="line">  <span class="keyword">int</span> (**pp)(<span class="keyword">int</span>, ...) = &amp;pFunc;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面两种调用方式也是相同的</span></span><br><span class="line">  <span class="keyword">int</span> result = (*pp)(<span class="number">5</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="keyword">int</span> result2 = (**pp)(<span class="number">5</span>, <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result == result2? %d\n"</span>, result2 == result);</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">MyStruct</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct MyStruct <span class="title">Func</span><span class="params">(struct MyStruct s, <span class="keyword">int</span> a[])</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sum = %f\n"</span>, s.a + s.f + a[<span class="number">0</span>]);</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Test</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  p = Func;</span><br><span class="line">  p((struct MyStruct)&#123;.a = <span class="number">10</span>, .f=<span class="number">.5</span>f&#125;, (<span class="keyword">int</span>[])&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意点：</p>
<ul>
<li><code>(*pf)()</code>和<code>pf()</code>一样</li>
<li>如果Func是函数标识符，Func==&amp;Func。数组也是a == &amp;a</li>
<li><strong>注意函数指针的类型是 <code>类型 (*)(形参列表)</code></strong>，</li>
</ul>
<h2 id="main函数"><a href="#main函数" class="headerlink" title="main函数"></a>main函数</h2><p>要点如下：</p>
<ul>
<li>返回类型应该是int，用于返回给操作系统</li>
<li>可以有两种类型的参数：int main(void)或者int main(int argc, const char* argv[])，argc表示传入字符串的个数。argv是字符指针数组，<code>argv[argc]</code>应该是NULL。<code>argv[0]</code>表示当前程序名，1到(argc-1)是传过来的命令行参数。</li>
<li>main不能是static、inline、_Noreturn</li>
</ul>
<h2 id="函数与sizeof"><a href="#函数与sizeof" class="headerlink" title="函数与sizeof"></a>函数与sizeof</h2><p>sizeof不能用于：</p>
<ul>
<li>函数，但是sizeof(&amp;Func)是合法的</li>
<li>不完整类型表达式</li>
<li>位域</li>
</ul>
<p>_Alignof不能用于：</p>
<ul>
<li>函数</li>
<li>不完整类型</li>
</ul>
<p>sizeof(Func())，返回的是Func返回类型的大小，<strong>而不是返回表达式的大小！函数调用也不会发生！</strong></p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-19T02:50:37.000Z" title="2019-11-19T02:50:37.000Z">2019-11-19</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">4 minutes read (About 540 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/19/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/7.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5/">7.C语言中的控制流语句</a></h1><div class="content"><h2 id="逗号表达式"><a href="#逗号表达式" class="headerlink" title="逗号表达式"></a>逗号表达式</h2><p>用于将若干表达式按序执行，<strong>并返回最后一个表达式的结果</strong>。</p>
<p><code>,</code>是一个双目运算符。</p>
<h2 id="条件表达式"><a href="#条件表达式" class="headerlink" title="条件表达式"></a>条件表达式</h2><p>结构：<code>布尔表达式?表达式1:表达式2</code></p>
<h2 id="分支语句"><a href="#分支语句" class="headerlink" title="分支语句"></a>分支语句</h2><h3 id="if-else"><a href="#if-else" class="headerlink" title="if-else"></a>if-else</h3><p>形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(expression) 语句</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="keyword">if</span>(expression) &#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"><span class="keyword">if</span>(expression) &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">  statements</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 和</span></span><br><span class="line"><span class="keyword">if</span>(expression) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span>(expression2) &#123;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>C语言一共有以下几种语句：标签语句、复合语句、表达式语句、选择语句、迭代语句、调转语句。</p>
<h3 id="switch-case"><a href="#switch-case" class="headerlink" title="switch-case"></a>switch-case</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">switch</span>(expression) &#123;</span><br><span class="line">  <span class="keyword">case</span> 整数常量表达式<span class="number">1</span>:</span><br><span class="line">    语句<span class="number">1</span>;</span><br><span class="line">    语句<span class="number">2</span>;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  <span class="keyword">case</span> 整数常量表达式<span class="number">2</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  ...</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>case后面只能是整数常量表达式，和js不同，js中是任意表达式都可。</li>
<li>如果没有break，那么会从匹配到的位置执行到switch结尾。</li>
<li>如果要在case中声明变量，必须使用语句块({})包起来</li>
</ul>
<h2 id="迭代语句"><a href="#迭代语句" class="headerlink" title="迭代语句"></a>迭代语句</h2><p>使用continue和break可以跳过循环。continue跳过本次循环，直接执行下一次循环。break跳出循环。</p>
<h3 id="while与do…while"><a href="#while与do…while" class="headerlink" title="while与do…while"></a>while与do…while</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(expression) 语句；</span><br><span class="line"><span class="keyword">while</span>(expression) &#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">语句;</span><br><span class="line"><span class="keyword">while</span>(expression);</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125; <span class="keyword">while</span>(expression);</span><br></pre></td></tr></table></figure>
<h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(expr1;expr2;expr3) 语句</span><br><span class="line"><span class="keyword">for</span>(expr1;expr2;expr3) &#123;</span><br><span class="line">  语句块</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>三个位置都是表达式</li>
<li>expr2用作布尔表达式，值为true则继续。</li>
<li>每个表达式都可省略，如果省略expr2，则其始终为true</li>
<li>执行顺序是expr1-&gt;expr2-&gt;语句块-&gt;expr3-&gt;expr2-&gt;语句块-&gt;expr3-&gt;…</li>
</ul>
<h2 id="goto"><a href="#goto" class="headerlink" title="goto"></a>goto</h2><p>goto、continue、break、return统称调转语句。</p>
<p>continue用于循环，break用于switch和循环。</p>
<p>return用于函数返回。</p>
<p>goto相当于汇编中的jump、branch等。goto需要和标签配合使用：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">NEXT:</span><br><span class="line"> <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">   <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(a &lt; <span class="number">10</span>) &#123;</span><br><span class="line">  <span class="keyword">goto</span> NEXT;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>goto限制很少，能够调转到<strong>一个函数内的任何位置（因为标签的作用域是函数作用域）</strong>，调转可能出现没有初始化的情况，而且影响可读性，要谨慎使用。但是用的好有奇效。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-18T04:03:52.000Z" title="2019-11-18T04:03:52.000Z">2019-11-18</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">31 minutes read (About 4648 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/18/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/6.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/">6.C语言中的指针和数组</a></h1><div class="content"><p>本文首先学习C语言中的数组，再学习指针以及指针和数组的关系，再学习字符串字面量，最后学习C语言的完整类型和不完整类型。</p>
<p>数组和结构体一样，属于<strong>聚合类型</strong>。</p>
<h2 id="一维数组"><a href="#一维数组" class="headerlink" title="一维数组"></a>一维数组</h2><p>形式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;类型名&gt; &lt;标识符&gt;[&lt;数组元素个数&gt;]</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>注意：C99之前，数组元素个数必须是一个整数常量表达式。C99之后可以是一个运行时计算的整数表达式。</p>
</blockquote>
<p>如果<code>数组元素个数</code>是一个变量，那么该数组又称为变长数组。</p>
<blockquote>
<p>注意：sizeof能正确计算数组的长度，但是是在运行时计算，不管是不是变长数组</p>
</blockquote>
<h3 id="访问数组元素"><a href="#访问数组元素" class="headerlink" title="访问数组元素"></a>访问数组元素</h3><p>使用：<code>标识符[index]</code>形式，例如<code>arr[0]</code>，index从0开始，表示访问数组的第一个元素。</p>
<blockquote>
<p>注意：C语言的数组长度没有办法从数组中知道（除非自行用数组元素记录，不像js或者java有length数组。只能自己用额外的变量记录</p>
</blockquote>
<p>数组对象可以使用{}初始化列表。如果初始化列表中的数量小于数组长度，那么剩余部分填充0。C99开始可以指定数组下表来初始化数组，如果没有指定，那么按顺序赋值。</p>
<blockquote>
<p>通过 <code>{ [1] = 10.5f, [3] = 6.0 }</code>这种形式可以对特定的下标赋值，未赋值的部分是0。这种形式和结构体还有联合体的成员赋值类似，区别是结构体使用<code>{ .成员名 = 值 }</code>的形式</p>
</blockquote>
<p>初始化列表中的元素不仅仅可以是常量，还可以是运行时求值的表达式：<code>int32_t b[] = { c[0], c[1], c[2] }</code>。还注意到指定了初始化列表，可以不指定<code>数组元素个数</code>，<code>数组元素个数</code>会自动计算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;complex.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">char</span> c[<span class="number">2</span>*<span class="number">2</span>+<span class="number">1</span>] = &#123; <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%c "</span>, c[i]);</span><br><span class="line">    <span class="keyword">if</span>(i==<span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 可以添加额外的逗号，未赋值的部分置0</span></span><br><span class="line">  <span class="keyword">int32_t</span> a[<span class="number">4</span>] = &#123; <span class="number">100</span>, <span class="number">-1</span>, &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">3</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对第二个和第四个元素赋值，其他为0</span></span><br><span class="line">  <span class="keyword">float</span> f[<span class="number">5</span>] = &#123; [<span class="number">1</span>] = <span class="number">10.5f</span>, [<span class="number">3</span>] = <span class="number">-0.5f</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%.2f "</span>, f[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">4</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里注意几个点：</span></span><br><span class="line">  <span class="comment">// 1. 赋值默认从0开始，后面递增+1，所以s[0] = -1, s[1] = 2</span></span><br><span class="line">  <span class="comment">// 2. 没有指定下标的元素，序号是上一个序号+1，所以s[5] = 20</span></span><br><span class="line">  <span class="comment">// 赋值后的数组是[-1,2,0,10,1,50,5];</span></span><br><span class="line">  <span class="keyword">int16_t</span> s[] = &#123; <span class="number">-1</span>, <span class="number">2</span> ,[<span class="number">3</span>] = <span class="number">10</span>, [<span class="number">6</span>] = <span class="number">5</span>, [<span class="number">4</span>] = <span class="number">1</span>, <span class="number">20</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">7</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, s[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">6</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">T</span> &#123;</span></span><br><span class="line">    <span class="keyword">int32_t</span> a, b;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面是一个更复杂的赋值示例，一个结构体数组的赋值</span></span><br><span class="line">  <span class="comment">// 如果没有使用&#123;&#125;，列表中的值依次赋给结构体成员，下例中的10赋给[0].a，20赋给[0].b</span></span><br><span class="line">  <span class="comment">// 使用[1] = &#123; 1, 2 &#125;</span></span><br><span class="line">  <span class="comment">// 还可以结合使用[2] = &#123; .a = -1, .b = -2 &#125;</span></span><br><span class="line">  <span class="comment">// 还可以使用[3].a = 4, [3].b = 5</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">T</span> <span class="title">t</span>[] = &#123;</span> <span class="number">10</span>, <span class="number">20</span>, &#123; <span class="number">1</span>, <span class="number">2</span> &#125;, [<span class="number">2</span>] = &#123; .a = <span class="number">-1</span>, .b = <span class="number">-2</span>&#125;, [<span class="number">3</span>].b = <span class="number">4</span>, [<span class="number">3</span>].a = <span class="number">5</span> &#125;;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"[%d]: %d %d\n"</span>, i, t[i].a, t[i].b);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>数组类型和其他类型不同，不能直接将一个数组对象直接赋值给另一个数组对象，即便初始化的时候也是这样。</strong></p>
<p>结构体可以直接赋值，成员会自动拷贝，但是数组不可以。如果想引用数组，使用指针。如果想拷贝数组，可以使用<code>&lt;string.h&gt;</code>中的<code>memcpy函数</code>。</p>
<p>通过<strong>数组的字面复合量</strong>可以表示一个匿名数组，但是不能用于初始化，gcc下会报错。</p>
<blockquote>
<p>memcpy(void<em> dest, void</em> source, size_t n)，从source地址拷贝到dest地址n个字节。看下面的例子：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> c[<span class="number">10</span>] = &#123; <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, [<span class="number">6</span>] = <span class="number">20</span>, [<span class="number">8</span>] = <span class="number">100</span> &#125;;</span><br><span class="line">  <span class="keyword">int</span> d[<span class="number">10</span>];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 注意，数组的标识符d、c可以当作一个指针，指针的值是d、c数组的起始地址</span></span><br><span class="line">  <span class="comment">// 传给memcpy(d, c, sizeof(c))，会将指针值传过去，其值是地址，所以不需要在使用&amp;d</span></span><br><span class="line">  <span class="built_in">memcpy</span>(d, c, <span class="keyword">sizeof</span>(c));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, d[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// d的最后三位被设置成了7,9,8</span></span><br><span class="line">  <span class="built_in">memcpy</span>(&amp;d[<span class="number">7</span>], ((<span class="keyword">int</span> [])&#123;<span class="number">7</span>, <span class="number">9</span>, <span class="number">8</span>&#125;), <span class="number">3</span> * <span class="keyword">sizeof</span>(<span class="keyword">int</span>));</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, d[i]);</span><br><span class="line">    <span class="keyword">if</span>(i == <span class="number">9</span>) <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
</blockquote>
<h2 id="多维数组"><a href="#多维数组" class="headerlink" title="多维数组"></a>多维数组</h2><p>形式如：<code>int[2][3]</code>表示含有两个<code>int[3]</code>类型的的数组。习惯上我们也称为两行散列的int类型元素的数组。</p>
<p>内存模型如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">                   -&gt; 0</span><br><span class="line">a -&gt; 0 -&gt; (int[3]) -&gt; 1</span><br><span class="line">                   -&gt; 2</span><br><span class="line"></span><br><span class="line">                   -&gt; 0</span><br><span class="line">  -&gt; 1 -&gt; (int[3]) -&gt; 1</span><br><span class="line">                   -&gt; 2</span><br></pre></td></tr></table></figure><br>在内存中二维数组也是线性存放的，例如<code>a[0][0] a[0][1] a[0][2] a[1][0]...</code></p>
<p>如果是<code>int a[2][3][4]</code>，表示两个<code>int[3][4]</code>型的数组。多维数组就是数组的元素还是数组。</p>
<p>sizeof也可以输出多维数组的大小。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>], <span class="keyword">int</span> n)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 数组初始化列表进行初始化</span></span><br><span class="line">  <span class="keyword">int</span> a[<span class="number">2</span>][<span class="number">3</span>] = &#123;</span><br><span class="line">    &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    &#123; <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span> &#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 也可以扁平化的初始化</span></span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">2</span>][<span class="number">3</span>] = &#123; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span> &#125;;</span><br><span class="line">  print_matrix(a, <span class="number">2</span>);</span><br><span class="line">  <span class="comment">// 2*3*4 = 24</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sizeof a is %zu\n"</span>, <span class="keyword">sizeof</span>(a));</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 声明二维数组的时候并初始化的时候，第一个数组长度可以省略，但是第二个不行，如果想都省略，使用指针</span></span><br><span class="line">  <span class="keyword">int</span> c[][<span class="number">3</span>] = &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;,</span><br><span class="line">    [<span class="number">2</span>] = &#123; <span class="number">4</span>, <span class="number">5</span> &#125;,</span><br><span class="line">    [<span class="number">3</span>][<span class="number">0</span>] = a[<span class="number">1</span>][<span class="number">1</span>], [<span class="number">3</span>][<span class="number">2</span>] = <span class="number">7</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  print_matrix(c, <span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 不能使用匿名数组初始化，gcc下会报错</span></span><br><span class="line">  <span class="comment">// int e[][3] = (int[][3]) &#123;</span></span><br><span class="line">  <span class="comment">//   &#123;1,2,3&#125;,</span></span><br><span class="line">  <span class="comment">//   [1] = &#123;4,5,6&#125;,</span></span><br><span class="line">  <span class="comment">//   &#123;7,9,9&#125;</span></span><br><span class="line">  <span class="comment">// &#125;;</span></span><br><span class="line">  <span class="comment">// print_matrix(e, 3);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_matrix</span><span class="params">(<span class="keyword">int</span> a[][<span class="number">3</span>], <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++) &#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; <span class="number">3</span>;j++) &#123;</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i][j]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="高维数组"><a href="#高维数组" class="headerlink" title="高维数组"></a>高维数组</h3><p>除了二维数组，还可以有三维、思维等等数组。具体能到多少维是实现定义的。</p>
<p>声明三维数组：<code>int a[2][3][4]</code>。</p>
<h2 id="变长数组"><a href="#变长数组" class="headerlink" title="变长数组"></a>变长数组</h2><p>C99引入可变长数组。这类数组声明是不是通过常量来声明的，而是通过变量。有以下限制：</p>
<ul>
<li>变长数组不能在文件作用域中声明</li>
<li>不能使用static修饰符来修饰</li>
<li>指向变长数组的指针以及变长数组统称为<code>可变修改类型</code>，该类型作为sizeof的操作数时，在运行时计算</li>
<li>变长数组声明后不能直接通过初始化列表初始化，只能通过memcpy或者逐个赋值</li>
<li>gcc 中const作为数组长度，也会当作变量</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">int</span> b[a];</span><br><span class="line"></span><br><span class="line">  a++;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"b size is %zu\n"</span>, <span class="keyword">sizeof</span>(b));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*p)[a] = &amp;b;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"p[0] size is : %zu\n"</span>, <span class="keyword">sizeof</span>(p[++x]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">  <span class="comment">// x = 1，sizeof(p[++x])是可变类型，在运行时得到，有副作用</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// gcc 中const作为数组长度，也会当作变量</span></span><br><span class="line">  <span class="comment">// const int n = 10;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int d[n] = &#123; 1, 2, 3 &#125;;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// int (*q)[n] = &amp;d;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// x = 1，这里sizeof(b[++x])在编译时确定，没有副作用</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"q[0] size is : %zu\n"</span>, <span class="keyword">sizeof</span>(b[++x]));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"x = %d\n"</span>, x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意：如果sizeof是在编译时计算的，那么不会产生副作用，例如<code>sizeof(b[++x])</code>，即便b时可变类型，但是<code>b[index]</code>是int，不是可变类型，所以++x不会产生副作用。但是同样指向数组的指针会有副作用</p>
</blockquote>
<h2 id="一级指针与对象地址"><a href="#一级指针与对象地址" class="headerlink" title="一级指针与对象地址"></a>一级指针与对象地址</h2><p>C中只要是一个存储对象，就能取地址。</p>
<p>通过&amp;来取地址，例如对于<code>int a;</code>，<code>&amp;a</code>表示取a的地址。无论在文件作用域还是语句块作用域中，都能取到地址。</p>
<p>在32位系统下拿到的地址是4字节，64位系统下拿到的是8字节。<strong>桌面程序中拿到的都是虚拟地址，而不是真实的物理地址，由操作系统和硬件负责将虚拟地址转成真实的物理地址，我们不需要关心</strong>。一些简单的嵌入式环境中可以拿到真实的地址。</p>
<p>C语言用<strong>指针</strong>来存储地址。使用<code>int* p</code>来声明指针，在正常变量声明前加一个<code>*</code>。需要注意，指针的长度就是地址的长度，32位系统下是4字节，64位系统下是8字节。那反正指针都是8字节，<code>int* p</code>和<code>double* p</code>有什么区别呢？区别在于如何解释所在地址的内容。指针存的只是一个起始地址，<code>int *p</code>表示指针指向的地址中，存的是一个int型的值，如果对指针取值，这时编译器会取<code>起始地址</code>到<code>起始地址+4</code>内存区间中的值并将其作为int类型返回。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一个指针对象可以转为一个无符号整数类型来观察该指针对象的值</span></span><br><span class="line">  <span class="comment">// 不过一般用uintptr_t来表示一个对象地址的值</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"p value is 0x%.16tX, size is: %zu\n"</span>, (<span class="keyword">uintptr_t</span>)p, <span class="keyword">sizeof</span>(p));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们指针的值是地址，但是我们只有将指针对象转为整数，一般是<code>uintptr_t</code>，才能正确看到地址的值。</p>
<h3 id="访问指针对象所指对象的内容"><a href="#访问指针对象所指对象的内容" class="headerlink" title="访问指针对象所指对象的内容"></a>访问指针对象所指对象的内容</h3><p>通过<code>*</code>可以间接访问指针指向地址中的值，例如<code>*p</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">  <span class="comment">// a变成了20，因为p指向的是a的地址</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// *p表示p指向的内存中的值，可以读写该值</span></span><br><span class="line">  *p = <span class="number">20</span>;</span><br><span class="line">  short b = *p;</span><br><span class="line">  *p = <span class="number">10</span>;</span><br><span class="line">  <span class="comment">// b拥有自己的地址，只是将a地址中的值赋值给了b，再改变a不影响b</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"b = %d\n"</span>, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="指针的比较和取地址"><a href="#指针的比较和取地址" class="headerlink" title="指针的比较和取地址"></a>指针的比较和取地址</h3><p>指针的比较就是指针指向的地址值的比较，可以比较相等，比较大小。</p>
<p>指针类型之间的相互转换，必须强制转换，例如<code>(int*)p</code>，强制指针转换在读取值的时候可能会出现问题，例如原来是<code>int*</code>，转成<code>long long*</code>，指针取值的那么会多读内存中的4个字节，这可能导致地址空间溢出。</p>
<p>只能对左值取地址，而对于右值不能取地址。右值是一个表达式的值，例如sizeof返回的值，整数字面量等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int32_t</span> a = <span class="number">10</span>, b = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int32_t</span> *p = &amp;a, *q = &amp;b, c = <span class="number">0</span>, *r = &amp;c;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 指针可以比较大小</span></span><br><span class="line">  <span class="keyword">bool</span> e = p &gt; q;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Is p &gt; q? %d\n"</span>, e);</span><br><span class="line"></span><br><span class="line">  e = p == r;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Is p equal to r? %d\n"</span>, e);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Is r equal to &amp;c? %d\n"</span>,  r == &amp;c);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int16_t</span> s = <span class="number">1</span>, *t = &amp;s;</span><br><span class="line">  t = &amp;a; <span class="comment">// 这里会出现警告，因为指针不会隐式转换</span></span><br><span class="line">  t = (<span class="keyword">int16_t</span>*)&amp;a; <span class="comment">// 只能强制转换</span></span><br><span class="line">  *t = <span class="number">2048</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于匿名数组，匿名结构体可以取地址</span></span><br><span class="line">  <span class="keyword">int32_t</span> (*pa)[<span class="number">3</span>] = &amp;(<span class="keyword">int32_t</span>[])&#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="多级指针"><a href="#多级指针" class="headerlink" title="多级指针"></a>多级指针</h2><p>多级指针用于表示指针的地址，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> *p = &amp;a;</span><br><span class="line"><span class="keyword">int</span> **pp = &amp;p;</span><br></pre></td></tr></table></figure><br>上例中，指针p存了a的地址，二级指针pp存了指针p的地址。那么我们取内容的时候，<code>*pp</code>拿到的是指针p的值，就是a的地址，<code>**pp</code>拿到是a的地址的值，就是10。地址指向关系如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">地址  低-----&gt;高</span><br><span class="line">int a---------int*p--------int**pp----&gt;</span><br><span class="line">  |              |              |</span><br><span class="line">  |          &#x3D;p的地址----------- 求值</span><br><span class="line">  |              |</span><br><span class="line">&#x3D;a的地址--------- 求值</span><br><span class="line">  |</span><br><span class="line">求值 &#x3D; 10</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;c</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdbool.h&gt;</span><br><span class="line">#include &lt;stdint.h&gt;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">  int32_t x &#x3D; 10, y &#x3D; 20;</span><br><span class="line"></span><br><span class="line">  int32_t *p &#x3D; &amp;x, *q &#x3D; &amp;y;</span><br><span class="line">  int32_t **pp &#x3D; &amp;p;</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; pp的值指向的内容是p的值也就是&amp;x</span><br><span class="line">  bool b &#x3D; (uintptr_t)*pp &#x3D;&#x3D; (uintptr_t)&amp;x;</span><br><span class="line">  printf(&quot;b &#x3D; %d\n&quot;, b);</span><br><span class="line"></span><br><span class="line">  &#x2F;&#x2F; *pp是指针p的值，赋值q，所以p &#x3D;&#x3D; q</span><br><span class="line">  *pp &#x3D; q;</span><br><span class="line">  printf(&quot;p &#x3D;&#x3D; q? %d\n&quot;, p &#x3D;&#x3D; q);</span><br><span class="line"></span><br><span class="line">  **pp &#x3D; 30;&#x2F;&#x2F; **pp是a的值，a的值变成了30</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="指向用户自定义类型的指针"><a href="#指向用户自定义类型的指针" class="headerlink" title="指向用户自定义类型的指针"></a>指向用户自定义类型的指针</h2><p>指向用户自定义类型的指针和普通的指针差不多。只是变一下类型。需要注意的是对结构或者联合体成员的访问。</p>
<p>如果是指针，那么需要使用<code>-&gt;</code>来访问结构体成员。例如<code>(s-&gt;a)</code>，当然也可以使用<code>(*p).a</code>。</p>
<p>注意二级指针的使用，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> **<span class="title">pp</span> = &amp;<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">(*pp)-&gt;a = <span class="number">10</span>;</span><br><span class="line">(**pp).a = <span class="number">10</span>;</span><br></pre></td></tr></table></figure><br>不能直接使用<code>pp-&gt;a</code>。</p>
<h2 id="数组和指针之间的关系"><a href="#数组和指针之间的关系" class="headerlink" title="数组和指针之间的关系"></a>数组和指针之间的关系</h2><p>C语言中数组可以隐式转换成指针。</p>
<p>C语言规定，除了sizeof、_Alignof、单目&amp;之外，表示数组类型的表达式会被转换成指针，而该表达式的值指向数组第一个元素的地址。</p>
<p>指针也能做整数加减法，但是和普通的加减法不一样，<strong>指针的加减法表示地址偏移，而且和类型相关</strong>。例如<code>int* p</code>，假设p指向的地址是<code>a</code>，那么<code>p+1</code>，指向地址<code>a+4</code>，因为int大小是4字节。</p>
<p>*(p+1)可以也写成p[1]。指针的偏移地址取值和数组类似。</p>
<h2 id="指向数组的指针"><a href="#指向数组的指针" class="headerlink" title="指向数组的指针"></a>指向数组的指针</h2><p>数组可以直接赋值给一个指针，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> *p = a;</span><br></pre></td></tr></table></figure><br>也可以使用指向数组的指针，如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> (*pa)[<span class="number">10</span>] = &amp;a;</span><br></pre></td></tr></table></figure><br>我们知道在这里数组a其实就是一个int<em>的指针，那么对其取地址就是指针的指针了。要访问a的元素需要通过`(</em>pa)[i]<code>或者</code>pa[0][i]`来访问。</p>
<p>那么<code>int (*pa)[10]</code>该怎么理解呢？指向数组的指针，也就是指针指向内容是一个数组，所以指针pa指向的是数组的地址，<code>(*pa)</code>是一个数组。如果要访问数组的内容，就需要使用<code>(*pa)[i]</code></p>
<p><strong><code>int (*pa)[10]</code>的类型是<code>int(*)[10]</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a[] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> *p = a;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> (*pa)[<span class="number">5</span>] = &amp;a;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of pa is: %zu\n"</span>, <span class="keyword">sizeof</span>(pa));</span><br><span class="line">  <span class="comment">// 输出8，因为pa是一个指针</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of (*pa) = %zu, sizeof (*p) = %zu\n"</span>, <span class="keyword">sizeof</span>(*pa), <span class="keyword">sizeof</span>(*p));</span><br><span class="line">  <span class="comment">// 输出(*pa) = 20 (*p) = 4</span></span><br><span class="line">  <span class="comment">// 因为(*pa)是int[5]，而*p是int</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">5</span>;i++) &#123;</span><br><span class="line">    sum += (*pa)[i]; <span class="comment">// 括号不能省略</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> b[<span class="number">3</span>][<span class="number">5</span>] = &#123;</span><br><span class="line">    &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;,</span><br><span class="line">    &#123;<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>&#125;,</span><br><span class="line">    &#123;<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// pa是指向数组的指针，所以(*pa)是指向b[0]，其值是一个数组</span></span><br><span class="line">  <span class="comment">// *(pa+1)指向b[1]，其值也是一个数组</span></span><br><span class="line">  pa = b;</span><br><span class="line">  pa[<span class="number">0</span>][<span class="number">0</span>]++;</span><br><span class="line">  (*(pa+<span class="number">1</span>))[<span class="number">0</span>]--;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 表示p的类型是int (*)[2][3]，即指向二维数组的指针</span></span><br><span class="line">  <span class="keyword">int</span> (*p)[<span class="number">2</span>][<span class="number">3</span>] = &amp;a;</span><br><span class="line">  <span class="comment">// 是一个指针，大小是8字节</span></span><br><span class="line">  <span class="keyword">int</span> a = <span class="keyword">sizeof</span>(<span class="keyword">int</span> (*)[<span class="number">2</span>][<span class="number">3</span>]);  </span><br><span class="line">  <span class="comment">// 表示p的类型是int (*)[2]，指向一维数组的指针</span></span><br><span class="line">  <span class="keyword">int</span> (*p)[<span class="number">2</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>三种指针：</p>
<ol>
<li>指向数组元素的指针：<code>int *p = a</code>，指针指向的是数组元素，类型是<code>int *</code></li>
<li>指向数组的指针：<code>int (*pa)[5] = &amp;a</code>，指针指向的是数组，类型是<code>int (*)[5]</code>；指向二维数组的指针是<code>int (*pa)[2][3]</code>，类型是<code>int (*)[2][3]</code>。那么问题来了，指向数组的指针的数组呢？<code>int (*pa[3])[2]</code>，表示长度为3的成员类型为<code>(int*)[2]</code>的数组，类型是<code>int(*[3])[2]</code></li>
<li>指针的数组：<code>int* a[10]</code>，是一个输出，数组元素是指针，类型是<code>int*[10]</code></li>
</ol>
</blockquote>
<h2 id="void类型"><a href="#void类型" class="headerlink" title="void类型"></a>void类型</h2><p>void一般用于函数返回类型以及空的表达式形参，<strong>也可以作为表达式的类型</strong>。</p>
<p>具有void类型的表达式称为<code>void表达式</code>，通过(void)expression，将表达式转为void类型。<code>void表达式</code>有以下规则：</p>
<ul>
<li>void表达式只能作为逗号表达式和三目运算符<code>:</code>左右两边的值，不能用于其他运算符</li>
<li>void表达式不能再被投射到其他类型</li>
</ul>
<p><strong>指向void类型的指针为<code>void*</code>，<code>void*</code>可以被隐式转换为指向任意对象的指针。指向任意对象的指针也能被隐式转换为<code>void*</code></strong></p>
<p>NULL表示空指针。</p>
<h2 id="字符数组和字符串字面量"><a href="#字符数组和字符串字面量" class="headerlink" title="字符数组和字符串字面量"></a>字符数组和字符串字面量</h2><p>C99只有ASCII字符和宽字符，宽字符的编码是根据环境来定的，可能是GB2312编码、UTF-16编码等。宽字符使用<code>wchar_t</code>，再<code>&lt;wchar.h&gt;</code>头文件中定义。</p>
<p>C11引入了UTF-8、UTF-16、UTF-32编码，通过u8、u、U字符串前缀来使用。<code>u&quot;abc&quot;</code>是含有三个UTF-16编码的字符串，类型是char16_t[4]。<code>char16_t</code>和<code>char32_t</code>在<code>&lt;uchar.h&gt;</code>中定义。</p>
<p>字符串字面量末尾会自动加上<code>&#39;\0&#39;</code>。如果”abc”占4个字节，分配空间的时候要注意多分配一个字节。</p>
<p><strong>C语言相邻的相同编码的字符串字面量会进行拼接</strong>，例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span>* a = <span class="string">"aaaaa"</span> <span class="string">"bbb"</span></span><br><span class="line">          <span class="string">"cccc"</span>;</span><br></pre></td></tr></table></figure><br>等价于<code>a = &quot;aaaaabbbcccc&quot;</code>。</p>
<h2 id="完整类型和不完整类型"><a href="#完整类型和不完整类型" class="headerlink" title="完整类型和不完整类型"></a>完整类型和不完整类型</h2><p>C语言中的类型分为：<strong>对象类型和函数类型</strong>。</p>
<p><strong>不完整类型</strong>指缺乏足够的信息取判定该类型所声明对象的大小。</p>
<p>例如：</p>
<ul>
<li>void表达式就是不完整类型，因为不知道对象的大小。</li>
<li>只含有枚举、结构体、联合体的声明，没有定义也是不完整类型。定义了之后变成完整类型</li>
<li>结构体中最后不指定大小的数组对象也是不完整类型</li>
</ul>
<p>不完整类型不能作为sizeof和_Alignof的操作数。</p>
<h2 id="灵活的数组成员"><a href="#灵活的数组成员" class="headerlink" title="灵活的数组成员"></a>灵活的数组成员</h2><p>在至少含一个对象的结构体中，最后一个成员可以是不完整类型，该成员被称为灵活的数组成员。</p>
<p>灵活的数组成员不计算大小，但是会影响字节填充。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Test1</span> &#123;</span></span><br><span class="line">    <span class="keyword">int8_t</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 灵活的数组成员，影响字节填充</span></span><br><span class="line">    <span class="keyword">double</span> d[];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">size_t</span> offset = offsetof(struct Test1, d);</span><br><span class="line">  <span class="comment">// 偏移量和结构体大小一样，是8字节</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"offset of is : %zu\n"</span>, offset);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of is : %zu\n"</span>, <span class="keyword">sizeof</span>(struct Test1));</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">array</span>[];</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="comment">// 因为按照4字节对齐（如果是double array[]）就按照8字节对齐</span></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of struct2 is %zu\n"</span>, <span class="keyword">sizeof</span>(struct Test2));</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> <span class="title">ts</span>[] = &#123;</span> &#123;<span class="number">10</span>&#125;, &#123;<span class="number">20</span>&#125;, &#123;<span class="number">30</span>&#125; &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 灵活的数组成员没有大小，地址是结构体的结束的下一个字节</span></span><br><span class="line">  <span class="comment">// 这里相当于(int*)&amp;ts[2]，(int*)&amp;ts[3]</span></span><br><span class="line">  <span class="comment">// 取到的值是20和30</span></span><br><span class="line">  <span class="keyword">int</span> sum = ts[<span class="number">0</span>].<span class="built_in">array</span>[<span class="number">0</span>] + ts[<span class="number">1</span>].<span class="built_in">array</span>[<span class="number">0</span>];</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"sum = %d\n"</span>, sum);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 灵活的数组成员还有一种方式就是对结构体做动态内存分配</span></span><br><span class="line">  <span class="comment">// 动态分配的结构体之后的内存将给灵活数组成员</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Test2</span> *<span class="title">pt</span> = <span class="title">malloc</span>(<span class="title">sizeof</span>(*<span class="title">pt</span>) + <span class="title">sizeof</span>(<span class="title">int</span>[<span class="title">sum</span>]));</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sum;i++) &#123;</span><br><span class="line">    pt-&gt;<span class="built_in">array</span>[i] = i + <span class="number">1.0</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  pt-&gt;a = <span class="number">100</span>;</span><br><span class="line">  <span class="keyword">int</span> result = pt-&gt;a;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"result is %d\n"</span>, result);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sum;i++) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%d "</span>, pt-&gt;<span class="built_in">array</span>[i]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>灵活数组成员的起始地址是结构体结束的下一个字节</li>
<li>灵活数组成员可用于对结构体做动态内存分配</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-18T01:53:33.000Z" title="2019-11-18T01:53:33.000Z">2019-11-18</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">2 minutes read (About 371 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/18/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/">C语言标准库</a></h1><div class="content"><p>这篇文章学习C语言标准库，包括基本数据类型对应的标准库例如stdbool以及数据结构算法、线程进程、网络等等的库。综合对这些库的介绍和使用示例。</p>
<h2 id="stddef-h"><a href="#stddef-h" class="headerlink" title="stddef.h"></a>stddef.h</h2><p>定义了以下常用的宏：</p>
<ul>
<li>offsetof：获取结构体成员的偏移位置（字节计数）</li>
</ul>
<h2 id="stdalign-h"><a href="#stdalign-h" class="headerlink" title="stdalign.h"></a>stdalign.h</h2><p>定义了对齐常用的宏：</p>
<ul>
<li>alignof：_Alignof的别名，获取对象的对齐字节数，必须有括号</li>
<li>alignas：_Alignas的别名，设置对象的对齐字节数，可以放在类型的前面或者后面，可以重复声明多个alignas，取最大字节数</li>
</ul>
<h2 id="stdbool-h"><a href="#stdbool-h" class="headerlink" title="stdbool.h"></a>stdbool.h</h2><p>定义了布尔值相关的宏：</p>
<ul>
<li>bool：_Bool的别名，是一个类型，布尔类型，值为0或1，大小占1个字节</li>
<li>true：宏，值为1</li>
<li>false：宏，值为0</li>
</ul>
<h2 id="stdint-h"><a href="#stdint-h" class="headerlink" title="stdint.h"></a>stdint.h</h2><p>int在不同的平台下的长度可能不一样，使用stdint可获取一样长度的整数，缺点是可能会影响性能。</p>
<p>定义了标准长度整数相关的宏：</p>
<ul>
<li>int8_t</li>
<li>int16_t</li>
<li>int32_t</li>
<li>int64_t</li>
<li>uintptr_t</li>
<li>intptr_t</li>
</ul>
<h2 id="wchar-h"><a href="#wchar-h" class="headerlink" title="wchar.h"></a>wchar.h</h2><p>定义了宽字符wchar_t等</p>
<h2 id="uchar-h"><a href="#uchar-h" class="headerlink" title="uchar.h"></a>uchar.h</h2><p>定义了char16_t，char32_t等，表示c11新增的编码类型。</p>
<h2 id="stdlib-h"><a href="#stdlib-h" class="headerlink" title="stdlib.h"></a>stdlib.h</h2><p>定义了malloc等</p>
<ul>
<li>malloc</li>
<li>abort</li>
<li>exit</li>
</ul>
<h2 id="stdarg-h"><a href="#stdarg-h" class="headerlink" title="stdarg.h"></a>stdarg.h</h2><p>函数不定参数获取宏等</p>
<h2 id="stdnoreturn-h"><a href="#stdnoreturn-h" class="headerlink" title="stdnoreturn.h"></a>stdnoreturn.h</h2><p>定义了noreturn，_Noreturn的别名</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-17T07:23:49.000Z" title="2019-11-17T07:23:49.000Z">2019-11-17</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">13 minutes read (About 1896 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/17/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/5.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%92%8C%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85/">5.C语言的字节对齐和字节填充</a></h1><div class="content"><p>前面已经涉及到了一些字节对齐的知识。这里更加详细的学习C语言中的字节对齐和字节填充。</p>
<p>对于32/64位系统环境，通常编译器会默认对<strong>指令和数据</strong>进行4字节对齐。也就是说，<strong>一个函数的起始地址以及一个数据对象的起始地址斗会是4字节的倍数</strong>。在不同的CPU架构下对齐的字节数也不相同。</p>
<blockquote>
<p>N字节对齐指分配该对象存储空间时，起始地址是N字节的倍数</p>
</blockquote>
<h2 id="Alignof操作符"><a href="#Alignof操作符" class="headerlink" title="_Alignof操作符"></a>_Alignof操作符</h2><p>一般基本数据类型参照的是其数据类型本身的大小。C11引入了_Alignof来查看指定对象的对齐要求。</p>
<p>_Alignof和sizeof类似，但有两点不同：</p>
<ul>
<li>_Alignof后面必须接圆括号</li>
<li>_Alignof操作数只能是类型名（基本类型、枚举类型等等），而不是一个表达式。GNU语法扩展能够让_Alignof的操作数是表达式。</li>
</ul>
<p>_Alighof也返回size_t类型。</p>
<p>max_align_t表示当前实现对基本对齐要求的最大对齐的支持，max_align_t是一个类型。通过引入<code>&lt;stddef.h&gt;</code>使用。<strong>基本对齐要求指编译器默认对齐要求，对于存储空间很大数组或一个结构体，编译器会按照_Alignof(max_align_t)来对齐</strong></p>
<p>引入对齐头文件<code>&lt;stdalign.h&gt;</code>可以使用alignof宏，和_Alignof等同。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span> = _Alignof(<span class="keyword">max_align_t</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of max_alignof_t is : %zu\n"</span>, <span class="built_in">size</span>);</span><br><span class="line">  <span class="comment">// 输出size of max_alignof_t is 16</span></span><br><span class="line">  <span class="comment">// gcc 8.3 linux 64下最大默认对齐是16字节</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">size</span> = <span class="keyword">alignof</span>(<span class="keyword">bool</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"Boolean size is : %zu\n"</span>, <span class="built_in">size</span>);</span><br><span class="line">  <span class="comment">// 输出1</span></span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">float</span> f;</span><br><span class="line">    <span class="keyword">double</span> d;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">double</span> ld;</span><br><span class="line">  &#125; s = &#123; <span class="number">0</span>, <span class="number">1.0f</span>, <span class="number">10.5</span>, <span class="number">1000.005L</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 只能用alignof(struct S)，而不能用alignof(s)</span></span><br><span class="line">  <span class="comment">// 因为操作数只能是类型</span></span><br><span class="line">  <span class="built_in">size</span> = <span class="keyword">alignof</span>(struct S);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"struct S's size is : %zu\n"</span>, <span class="built_in">size</span>);</span><br><span class="line">  <span class="comment">// 输出16，因为long double是16字节，struct的字节对齐不小于其所有成员的字节对齐</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Alignas"><a href="#Alignas" class="headerlink" title="_Alignas"></a>_Alignas</h2><p>前面介绍了类型默认对齐以及_Alignof的使用，但是很多情况下默认对齐不能满足需要。通过_Alignas可以显式指定某一个对象以多少字节对齐。</p>
<p>_Alignas的用法和_Alignof类似，但是其操作数是一个常量表达式或者类型名。引入<code>&lt;stdalign.h&gt;</code>后，可以使用alignas宏。</p>
<p>_Alignas也有一些限制：</p>
<ul>
<li>_Alignas的操作数不能小于默认的对齐大小</li>
<li>_Alignas的操作数应该是0,1,2,4等无符号整数（2的幂次方），0表示采用默认对齐</li>
<li>编译器会指定最大可对齐的字节数，Apple LLVM是256MB</li>
<li>_Alignas可以对同一个对象多次使用，取最大对齐数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a1 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 这里使用了GNU语法扩展，因为alignof只能接类型，但是这里接了表达式</span></span><br><span class="line">  <span class="comment">// GNU扩展提供了表达式支持</span></span><br><span class="line">  <span class="keyword">size_t</span> align = <span class="keyword">alignof</span>(a1);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ai alignment is %zu\n"</span>, align);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> _Alignas(<span class="keyword">double</span>) a2 = <span class="number">0</span>;</span><br><span class="line">  align = <span class="keyword">alignof</span>(a2);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a2 alignment is %zu\n"</span>, align);</span><br><span class="line">  <span class="comment">// 输出8</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// alignas可以放在int的前面，也可以放在int的后面</span></span><br><span class="line">  <span class="comment">// 这里有多个alignas，取最大对齐</span></span><br><span class="line">  <span class="keyword">alignas</span>(<span class="keyword">int</span>) <span class="keyword">alignas</span>(<span class="keyword">double</span>) <span class="keyword">alignas</span>(<span class="number">64</span>) <span class="keyword">int</span> a3 = <span class="number">0</span>;</span><br><span class="line">  align = <span class="keyword">alignof</span>(a3);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a3 alignment is %zu\n"</span>, align);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 0表示默认对齐</span></span><br><span class="line">  <span class="function"><span class="keyword">double</span> <span class="title">alignas</span><span class="params">(<span class="number">0</span>)</span> d </span>= <span class="number">0</span>;</span><br><span class="line">  align = <span class="keyword">alignof</span>(d);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"d alignment is %zu\n"</span>, align);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 使用条件表达式来判断对齐基本要求</span></span><br><span class="line">  <span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">alignas</span><span class="params">(<span class="keyword">alignof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) &gt; <span class="number">8</span> ? <span class="keyword">alignof</span>(<span class="keyword">long</span> <span class="keyword">long</span>) : <span class="number">8</span>)</span> ll </span>= <span class="number">0L</span>L;</span><br><span class="line">  align = <span class="keyword">alignof</span>(ll);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"ll alignment is %zu\n"</span>, align);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对齐说明符也能修饰结构体</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">alignas</span><span class="params">(<span class="number">16</span>)</span> a</span>;</span><br><span class="line">    <span class="keyword">int</span> b;</span><br><span class="line">  &#125;s = &#123; <span class="number">0</span>, <span class="number">6</span> &#125;;</span><br><span class="line">  <span class="keyword">size_t</span> aa = <span class="keyword">sizeof</span>(s.a), aaa = <span class="keyword">alignof</span>(s.a);</span><br><span class="line">  <span class="keyword">size_t</span> sa = <span class="keyword">alignof</span>(s), sa1 = <span class="keyword">sizeof</span>(s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"%zu %zu %zu %zu\n"</span>, aa, aaa, sa, sa1);</span><br><span class="line">  <span class="comment">// 输出4 16 16 16</span></span><br><span class="line">  <span class="comment">// 只是将a按照16字节对齐，即a的起始地址是16的倍数</span></span><br><span class="line">  <span class="comment">// 但是并没有改变int的宽度，还是4</span></span><br><span class="line">  <span class="comment">// struct的对齐不小于a，所以也是16</span></span><br><span class="line">  <span class="comment">// 因为struct的对齐是16，所以尽管a+b=8字节，但是会填充8个字节的0变成16字节</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="结构体成员的字节对齐与字节填充"><a href="#结构体成员的字节对齐与字节填充" class="headerlink" title="结构体成员的字节对齐与字节填充"></a>结构体成员的字节对齐与字节填充</h2><p>前面有多次提到结构体成员的字节对齐和字节填充，这里更加全面和深入的学习一下。</p>
<p>C语言的结构体的字节填充一般也是根据其成员的字节对齐情况来确定的。C11标准只是提到了一个结构体或联合体对象的每个非位域成员，以实现定义的、适合改成员对象类型的方式进行对齐；在一个结构体或者联合体的末尾可以做字节填充。</p>
<p>结构体的字节填充根据实现来定，对于主流桌面编译器来说。遵守一下规则来判定每个成员的字节对齐和字节填充：</p>
<ul>
<li>结构体第一个成员所在的偏移地址为0</li>
<li>每个成员根据其类型或者程序员指定的对齐字节数来判定它所在的偏移地址。<strong>如果该成员按照4字节对齐，那么它所在的偏移地址是4的倍数，如果不是4的倍数，则向上取整到4的倍数的最小整数</strong></li>
<li>当前成员的偏移地址到上一个成员之间存储空间用0填充</li>
<li>结构体对象的字节对齐与其成员的最大字节对齐要求一致</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int8_t</span> c;</span><br><span class="line">    <span class="keyword">int32_t</span> i;</span><br><span class="line">    <span class="keyword">int16_t</span> s;</span><br><span class="line">    <span class="keyword">int64_t</span> d;</span><br><span class="line">  &#125;s = &#123; <span class="number">0x10</span>, <span class="number">0x20</span>, <span class="number">0x30</span>, <span class="number">0x40</span> &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s alignment is %zu\n"</span>, <span class="keyword">alignof</span>(s));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size is %zu\n"</span>, <span class="keyword">sizeof</span>(s));</span><br><span class="line">  <span class="comment">// 第一行输出8，第二行输出24</span></span><br><span class="line">  <span class="comment">// 内存分布如下：</span></span><br><span class="line">  <span class="comment">// 0 1  4    8  10       16          24</span></span><br><span class="line">  <span class="comment">// c 000i    s   00000000 d</span></span><br><span class="line">  <span class="comment">// 第一个int8占一个字节，一字节对齐，放在[0,1)</span></span><br><span class="line">  <span class="comment">// 第二个int32占4字节，4字节对齐，所以起始地址必须是4的倍数，放在[4-7]</span></span><br><span class="line">  <span class="comment">// 中间的三个字节[1-4)填充0</span></span><br><span class="line">  <span class="comment">// 第三个in16占两字节，2字节对齐，当前偏移地址是8，对齐了，放在[8-9]</span></span><br><span class="line">  <span class="comment">// 第四个int64占8字节，8字节对齐，当前偏移地址是10，没有对齐，向上取整8的倍数到16，放在[16-23]</span></span><br><span class="line">  <span class="comment">// 中间的6个字节[10-15]填充0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="offsetof宏"><a href="#offsetof宏" class="headerlink" title="offsetof宏"></a>offsetof宏</h3><p>C标准中定义了offsetof宏，用于获取当前成员所在的偏移位置。定义在<code>&lt;stddef.h&gt;</code>头文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stddef.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdalign.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdbool.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdint.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// s按16字节对齐，大小是32个字节，末尾4个字节填充0</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">    <span class="comment">// 2字节对齐，起始位置是0</span></span><br><span class="line">    <span class="keyword">int16_t</span> s;</span><br><span class="line">    <span class="comment">// 4字节对齐，起始位置是4，占1个字节</span></span><br><span class="line">    <span class="keyword">alignas</span>(<span class="keyword">int32_t</span>) <span class="keyword">bool</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 4字节对齐，起始位置是8，中间的5、6、7三个字节填充0</span></span><br><span class="line">    <span class="keyword">int32_t</span> i;</span><br><span class="line">    <span class="comment">// 按照16字节对齐，起始位置是16，中间的[12-15]4个字节填充0</span></span><br><span class="line">    <span class="comment">// 占12个字节，末尾的4个字节填充0</span></span><br><span class="line">    <span class="keyword">alignas</span>(<span class="number">16</span>) <span class="keyword">union</span> &#123;</span><br><span class="line">      <span class="keyword">alignas</span>(<span class="number">8</span>) <span class="keyword">char</span> c;</span><br><span class="line">      <span class="keyword">float</span> f;</span><br><span class="line">    &#125; un;</span><br><span class="line">  &#125; ss;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> offset = offsetof(struct S, s);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s offset is %zu\n"</span>, offset);</span><br><span class="line"></span><br><span class="line">  offset = offsetof(struct S, b);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"b offset is %zu\n"</span>, offset);</span><br><span class="line"></span><br><span class="line">  offset = offsetof(struct S, i);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"i offset is %zu\n"</span>, offset);</span><br><span class="line"></span><br><span class="line">  offset = offsetof(struct S, un);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"un offset is %zu\n"</span>, offset);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">size_t</span> <span class="built_in">size</span> = <span class="keyword">sizeof</span>(struct S);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"size of struct S is %zu\n"</span>, <span class="built_in">size</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>C语言会对结构体的末尾进行字节填充，一般来说，是根据当前结构体的对齐字节数来填充的，例如当前结构体的对齐字节数为16，结构体大小是8个字节，那么后面的8个字节填充0.</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-15T03:12:02.000Z" title="2019-11-15T03:12:02.000Z">2019-11-15</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">29 minutes read (About 4414 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/15/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/9.C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/">9.C语言预处理器</a></h1><div class="content"><p>C语言编译器前端还分为预处理阶段和编译阶段。预处理阶段是通过C语言的各类预处理器将指定的一些字符符号直接替换到即将编译的源代码。<strong>通过预处理器可以在不同的平台上插入不同的代码，还可以将某些代码抽象成宏定义</strong>。</p>
<p>C语言的三大类预处理指示符：</p>
<ul>
<li>条件段预处理</li>
<li>控制行预处理，例如宏定义</li>
<li>空指示符</li>
</ul>
<p>这篇文章学习条件预处理、文件包含、宏替换、行控制、错误指示符、编译指示符(pragma)、空指示符以及C11标准中定义的宏名。</p>
<p>对于预处理指令有一些规则：</p>
<ul>
<li>对于任意一条预处理指示符，除了_Pragma之外，其他的必须以#开头，并且#必须出现在每一行的最前面（#前面可以有空白字符）。</li>
<li>预处理指令无需加分号</li>
<li>有范围的预处理器的范围是起始指示符的下一行到结束指示符的上一行</li>
</ul>
<h2 id="宏定义"><a href="#宏定义" class="headerlink" title="宏定义"></a>宏定义</h2><p>宏定义属于<code>控制行预处理指示符</code>。以<code>#define</code>定义的一个符号称为宏。</p>
<p>C语言的宏定义由两种方式：类似对象的宏定义以及类似函数的宏定义。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 类似对象的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符 替换列表 换行符</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 类似函数的宏定义</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> 标识符(参数列表) 替换列表 换行符</span></span><br></pre></td></tr></table></figure><br><strong>宏定义用于将标识符替换位替换列表中的内容，其作用范围是从它定义完的那个位置起一直到当前源文件结束。</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 下面是宏定义部分的代码</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO1 100</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO2 10 + a</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义一个宏，宏的内容是一个函数</span></span><br><span class="line"><span class="comment">// 如果代码较长，通过\+换行符表示单行</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO3 static int Foo(void) &#123;\</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">1</span>;\</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 预处理时会替换，相当于定义了一个函数</span></span><br><span class="line">MY_MACRO3</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了一个宏函数，交换两个实参的值</span></span><br><span class="line"><span class="comment">// MY_SWAP与(之间没有空格</span></span><br><span class="line"><span class="comment">// 这里假定x和y都是整数类型</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_SWAP(x, y) &#123; int temp = x; x = y; y = temp; &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">Dummy</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 两个点：</span></span><br><span class="line">  <span class="comment">// 1.有空格，不是宏函数而是宏对象</span></span><br><span class="line">  <span class="comment">// 2.尽管在函数中定义但是作用范围是其后的整个文件</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> MY_MACRO4 (a,b)</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span> * argv[])</span> </span>&#123;</span><br><span class="line">  <span class="comment">// MY_MACRO不包含任何替换符号，会被忽略</span></span><br><span class="line">  <span class="keyword">int</span> a = MY_MACRO MY_MACRO2;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 变成10+a*3</span></span><br><span class="line">  <span class="keyword">int</span> b = MY_MACRO2 * <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">  <span class="comment">// a = 10, b = 40</span></span><br><span class="line"></span><br><span class="line">  a = Foo();</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">  <span class="comment">// a = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换成&#123; int temp = a; a = b; b = temp; &#125;</span></span><br><span class="line">  MY_SWAP(a, b)</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">  <span class="comment">// a = 40 b = 1</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换成a = (a, b)</span></span><br><span class="line">  a = MY_MACRO4;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里会输出ok</span></span><br><span class="line">  <span class="keyword">if</span> (a == b) &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"ok\n"</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在预编译阶段会替换宏定义，同时会合并空白符。</p>
<p>在编译器命令行中也可以使用宏定义，例如-D MY_MACRO=100.</p>
<p>要点：</p>
<ul>
<li>不管是宏对象还是宏函数都是单行的。如果多行需要\</li>
<li>宏函数标识符与(之间不能有空格</li>
<li>宏定义作用域整个文件</li>
<li>宏定义直接替换，在编译之前</li>
<li>替换列表中的前后空白会忽略，但是中间的空白会保留</li>
<li><strong>宏函数中参数的所有空白（包括前后空白）都会保留，#操作符会忽略前后空白</strong></li>
</ul>
<h3 id="宏定义中的-操作符"><a href="#宏定义中的-操作符" class="headerlink" title="宏定义中的#操作符"></a>宏定义中的#操作符</h3><p>要点：</p>
<ul>
<li>#用于宏函数定义</li>
<li>#后面接形参名（#和名字之间可有空格），表示将其内容作为<strong>字符串字面量</strong>表示</li>
<li>预处理符号不同于C语言的标识符，可以作为预处理符号的如下：<ul>
<li>头文件名</li>
<li>标识符</li>
<li>预处理数字</li>
<li>字符常量</li>
<li>字符串常量</li>
<li>标点符号</li>
<li>所有非空白符号，并且不是上面的符号</li>
<li><strong>上述所有内容包括标点字符都会保留，但是不能只出现一个’或者”的情况</strong></li>
</ul>
</li>
<li>宏函数前面的参数可以忽略，置空用逗号隔开</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 宏定义中的#操作符</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAFUC(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MAFUC2(x, y) #x <span class="meta-string">"\n"</span> #y</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sharp</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* s =MY_MAFUC(<span class="number">10</span>ab);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"this literal is %s\n"</span>, s); </span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, <span class="string">"10ab"</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Equal!"</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 对于#操作的实参的空白符，前后空白符都会被删除</span></span><br><span class="line">  <span class="comment">// 同时"\"会被替换成"\\"，"和'等也会被转义</span></span><br><span class="line">  s = MY_MAFUC(   <span class="number">10</span><span class="string">"ab\n"</span>    );</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(<span class="built_in">strcmp</span>(s, <span class="string">"10\"ab\\n\""</span>) == <span class="number">0</span>)</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Equal\n"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 逗号包括在圆括号中不作为实参分隔符</span></span><br><span class="line">  <span class="comment">// 都在在''或者""中也不作为实参分隔符</span></span><br><span class="line">  s = MY_MAFUC2((<span class="number">123</span>abc,<span class="number">45</span>;<span class="string">'0'</span>), [<span class="number">1</span>a2b3c:?<span class="string">','</span>=]);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"string is :%s\n"</span>, s);</span><br><span class="line">  <span class="comment">// 输出string is :(123abc,45;'0')</span></span><br><span class="line">  <span class="comment">//[1a2b3c:?','=]</span></span><br><span class="line">  <span class="comment">// 圆括号也会保留</span></span><br><span class="line"></span><br><span class="line">  s = MY_MAFUC2(,abcd);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="宏定义中的-操作符-1"><a href="#宏定义中的-操作符-1" class="headerlink" title="宏定义中的##操作符"></a>宏定义中的##操作符</h3><p>简单来说，##用于拼接。例如<code>#define CONCAT(x) x##10</code>，将10接到x的后面，<strong>并且替换后的不是字符串，而是原内容</strong>。例如<code>CONCAT(10)</code>，替换后的是1010，而不是字符串”1010”，这和#不同。结果1010可以赋值给整型变量，<code>int x = CONCAT(10)</code>。</p>
<p><code>##</code>后面可以接宏函数参数，也可以接常量</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCAT(x,y) x##10 + 0x##y</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a = CONCAT(<span class="number">10</span>, <span class="number">16</span>);</span><br><span class="line"><span class="comment">// 将被替换成 int a = 1010 + 0x16</span></span><br></pre></td></tr></table></figure>
<h3 id="宏替换"><a href="#宏替换" class="headerlink" title="宏替换"></a>宏替换</h3><ul>
<li>同一文件作用域内，不能出现两个名称相同的宏标识符。但是同一个宏可以重复定义。</li>
<li>替换列表之前和之后的空白符，都不属于替换列表，会被忽略</li>
<li>一个宏定义中可以引用另外一个已定义的宏，宏定义可以连续扩展，但是不能递归，替换顺序如下：<ul>
<li>处理替换列表中的#和##</li>
<li>展开掉替换列表中的宏</li>
<li>检查实参是否引用了宏，替换实参宏</li>
<li>用扩展后的实参替换形参宏</li>
</ul>
</li>
<li>宏定义不能递归（包括直接递归和间接递归），递归的宏不会被替换</li>
<li>替换后出现在<code>#define</code>这样的预处理结构，编译器会报错</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 允许定义两个完全相同的宏</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO(x) x + x ## 0</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO(x) x + x ## 0</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LITERAL(x) #x</span></span><br><span class="line"><span class="comment">// 替换类标引用了宏LITERAL</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO2(x) LITERAL(x)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CONCAT(x,y) x ## y ## ELLO</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 替换为10 + 100，所a = 110</span></span><br><span class="line">  <span class="keyword">int</span> a = MY_MACRO(<span class="number">10</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// #和##的优先级最高，所以MY_MACRO(20)，直接当作字符串返回了，不会继续扩展</span></span><br><span class="line">  <span class="comment">// s = MY_MACRO(20)</span></span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = LITERAL(MY_MACRO(<span class="number">20</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换顺序是# -&gt; 替换列表的宏 -&gt; 实参宏 -&gt; 形参宏</span></span><br><span class="line">  <span class="comment">// 1. 替换MY_MACRO2，得到LITERAL(x)</span></span><br><span class="line">  <span class="comment">// 2. 替换LITERAL(x)，得到#x。这里的#x是扩展出来的（不是MY_MACRO2替换列表中的），所以不会将实参作为字符串，接下来扩展实参</span></span><br><span class="line">  <span class="comment">// 3. 替换MY_MACRO(20)，得到20 + 200</span></span><br><span class="line">  <span class="comment">// 4. 替换形参#x得到字符串"20 + 200"</span></span><br><span class="line">  s = MY_MACRO2(MY_MACRO(<span class="number">20</span>));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里会得到#defineELLO，得到#开头的预处理指令，编译器会报错</span></span><br><span class="line">  <span class="comment">// CONCAT(#, define);</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里先扩展MY_MACRO2，得到LITERAL(x)</span></span><br><span class="line">  <span class="comment">// 继续扩展，得到#x，#x不是MY_MACRO2替换列表中的，不会优先处理</span></span><br><span class="line">  <span class="comment">// 然后扩展实参CONCAT(if, def H)，得到ifdef HELLO</span></span><br><span class="line">  <span class="comment">// 替换形参#x得到"ifdef HELLO"</span></span><br><span class="line">  s = MY_MACRO2(CONCAT(<span class="keyword">if</span>, def H));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可变参数的宏定义"><a href="#可变参数的宏定义" class="headerlink" title="可变参数的宏定义"></a>可变参数的宏定义</h3><p>从C99标准起，C语言开始加入了不定参数个数（可变参数）的宏定义。定义可变参数的宏函数时，宏的形参列表使用…来表示。再替换列表中，用<strong>VA_ARGS</strong>来表示…对应的参数内容。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARIDIC_MACRO1(...) <span class="meta-string">"the String is: "</span> #__VA_ARGS__</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARIDIC_MACRO2(...) (__VA_ARGS__ ## 100)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARIDIC_MACRO3(a, ...) (a __VA_ARGS__ 10)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LITERAL(x) #x</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VARIDIC_MACRO4(X) LITERAL(X)</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span> *s = VARIDIC_MACRO1(<span class="string">"Good Luck!"</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 这里的参数作为一个整体，而不是三个参数</span></span><br><span class="line">  s = VARIDIC_MACRO1(Say <span class="string">"Hi"</span>!, Byebye, Thank you);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line">  <span class="comment">// 输出：s = the String is: Say "Hi"!, Byebye, Thank you</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换成int a = (10, 20, 30100)，右边是一个逗号表达式，值为30100</span></span><br><span class="line">  <span class="comment">// 输出：a = 30100</span></span><br><span class="line">  <span class="keyword">int</span> a = VARIDIC_MACRO2(<span class="number">10</span>, <span class="number">20</span> ,<span class="number">30</span>);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> b = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 替换成 (++b - 20 + 10)</span></span><br><span class="line">  <span class="comment">// a = -9, b = 1</span></span><br><span class="line">  a = VARIDIC_MACRO3(++b, <span class="number">-20</span> + );</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 因为第一个参数被忽略，所以其为空，替换成( 30 * 10)</span></span><br><span class="line">  <span class="comment">// 注意30前面的空格被吃掉了，但是*后面的空格保留了</span></span><br><span class="line">  a = VARIDIC_MACRO3(, <span class="number">30</span> * );</span><br><span class="line">  s = VARIDIC_MACRO4(VARIDIC_MACRO3(, <span class="number">30</span> * ));</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"s = %s\n"</span>, s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>要点：</p>
<ul>
<li>宏函数只有…，那么实参会当作一个整体传给宏函数</li>
<li>如果有参数，那么后面的参数会当做一个整体，包括’,’</li>
<li>__VA_ARGS表示的是形参中的…部分</li>
</ul>
<h2 id="C语言中预定义的宏"><a href="#C语言中预定义的宏" class="headerlink" title="C语言中预定义的宏"></a>C语言中预定义的宏</h2><p>C语言标准值出了C语言实现（即编译器）必须实现的预定义宏以及可选的预定义宏。</p>
<p>C语言中的预定义宏分为三类：</p>
<ul>
<li>C语言标准强制要求预定义的宏</li>
<li>环境宏，可选实现的预定义宏</li>
<li>条件特征宏，这也是可选的</li>
</ul>
<h3 id="C语言强制要求的预定义宏"><a href="#C语言强制要求的预定义宏" class="headerlink" title="C语言强制要求的预定义宏"></a>C语言强制要求的预定义宏</h3><ul>
<li><code>__DATE__</code>：表示当前日志，形式为Mmm dd yyy，Mmm是月份的缩写</li>
<li><code>__FILE__</code>：当前源文件</li>
<li><code>__STDC__</code>：如果值为1，说明当前C语言实现遵循C语言标准</li>
<li><code>__STDC_HOSTED__</code>：主机端实现值为1，独立式实现值为0.主机端实现值当前C源代码最终编译成当前平台目标兼容的二进制代码文件</li>
<li><code>__STDC_VERSION__</code>：当前C的版本，例如201710，C17版本</li>
<li><code>__TIME__</code>：当前实现，形式为hh: mm: ss</li>
<li><code>__func_</code>：当前函数名</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current date is: %s\n"</span>, __DATE__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current time is: %s\n"</span>, __TIME__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current file is: %s\n"</span>, __FILE__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current function is: %s\n"</span>, __func__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current line is: %d\n"</span>, __LINE__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current stardard is: %ld\n"</span>, __STDC_VERSION__);</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The current date is: %d\n"</span>, __STDC_HOSTED__);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="环境宏"><a href="#环境宏" class="headerlink" title="环境宏"></a>环境宏</h3><p>确定字符编码支持情况。<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">"The current standard time is: %d\n"</span>, __STDC_ISO_10646__);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The current support utf-16 is: %d\n"</span>, __STDC_UTF_16__);</span><br><span class="line"><span class="comment">// 支持UTF-32，值为1，上同</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"The current support utf-32 is: %d\n"</span>, __STDC_UTF_32__);</span><br></pre></td></tr></table></figure><br>_</p>
<h3 id="条件特征宏"><a href="#条件特征宏" class="headerlink" title="条件特征宏"></a>条件特征宏</h3><p>C标准中有一些语法特性是C语言编译器可选实现的，编译器根据这些宏来指明自己是否支持这些特性。</p>
<p>例如<strong>STDC_NO_THREADS</strong>用于指明当前C语言实现支持不支持<code>&lt;threads.h&gt;</code>头文件；<strong>STDC_NO_VLA</strong>指明当前C语言实现支不支持变长数组。</p>
<h2 id="主流编译器及平台预定义的宏"><a href="#主流编译器及平台预定义的宏" class="headerlink" title="主流编译器及平台预定义的宏"></a>主流编译器及平台预定义的宏</h2><p>以下预定义宏不是C标准指定的，而是编译器实现的。</p>
<ul>
<li><code>_MSC_VER</code>：如果定义了该宏，编译器是MSVC</li>
<li><code>__GNUC__</code>：GCC或者兼容GCC的编译器</li>
<li><code>__clang__</code></li>
<li><code>__i386__</code>：生成目标是32位x86处理器</li>
<li><code>__x86_64__</code>：x86_64处理器，运行再64位系统模式</li>
<li><code>__arm__</code></li>
<li><code>__arm64__</code></li>
<li><code>__APPLE__</code></li>
<li><code>__unix__</code></li>
<li><code>__linux__</code></li>
<li><code>_WIN32</code></li>
<li><code>_WIN64</code></li>
<li><code>__LP64__</code></li>
</ul>
<h2 id="条件预编译"><a href="#条件预编译" class="headerlink" title="条件预编译"></a>条件预编译</h2><p>条件预编译用于控制所要编译的代码。条件预编译中的条件为真时，这段代码参与编译，否则不参与编译。</p>
<blockquote>
<p>注意：这里的编译不仅仅指编译，也指预处理。如果条件为假，代码块中的预处理指令也不会执行</p>
</blockquote>
<p>控制条件包含的表达式应该是一个<strong>整数常量表达式</strong>。</p>
<p>此外还支持defined表达式，类似于sizeof，有两种形式<code>defined 标识符</code>和<code>defined(标识符)</code>。<strong>defined只能和条件控制语句联合起来使用，defined后面的标识符应该是一个宏名，如果该宏已经被定义，其值为1。还可以使用!defined</strong></p>
<h3 id="if和-elif预处理指示符"><a href="#if和-elif预处理指示符" class="headerlink" title="#if和#elif预处理指示符"></a>#if和#elif预处理指示符</h3><p>语法:<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> 常量表达式 换行符</span></span><br><span class="line">  <span class="comment">// 代码块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">elif</span> 常量表达式 换行符</span></span><br><span class="line">  <span class="comment">// 代码块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"> <span class="comment">// 代码块</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure></p>
<p>如果常量表达式的值等于0，结果为false，否则为true。</p>
<p>常量表达式可以使用布尔表达式，可以使用==、!=、&amp;&amp;、||、!和算术运算。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> 3 + 5</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"No zero expression"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">puts</span>(</span><br><span class="line">    #<span class="keyword">if</span> <span class="number">0</span></span><br><span class="line">      <span class="string">"0"</span></span><br><span class="line">    #elif <span class="number">3</span> - <span class="number">3</span></span><br><span class="line">      <span class="string">"1"</span></span><br><span class="line">    #<span class="keyword">else</span></span><br><span class="line">      <span class="string">"2"</span></span><br><span class="line">    #endif</span><br><span class="line">  );</span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> HELLO</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(HELLO)</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"HELLO defined"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(HELLO) &amp;&amp; defined(HI)</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Both defined~!"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> HI 2</span></span><br><span class="line"></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> defined(HELLO) &amp;&amp; defined(HI) &amp;&amp; (defined(HELLO) + defined(HI)) == HI</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"HI value: %d\n"</span>, HI);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// aa 不是预处理阶段的标识符</span></span><br><span class="line">  <span class="keyword">int</span> aa = <span class="number">100</span>;</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> aa == 100</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"aa is defined"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"aa is not defined"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 预处理阶段定义了aa，并且aa的值是20</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">define</span> aa 20</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> aa == 20</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"Yep!"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"aa = %d\n"</span>, aa);</span><br><span class="line">  <span class="keyword">enum</span> &#123;</span><br><span class="line">    M1,</span><br><span class="line">    M2,</span><br><span class="line">    M3</span><br><span class="line">  &#125;;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// M2不是预处理阶段的标识符</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">if</span> M2 == 1</span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"M2 is defined!"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">"M2 is not defined"</span>);</span><br><span class="line">  <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 下面会报错，因为sizeof只能在编译阶段调用，sizeof不是合法的常量表达式</span></span><br><span class="line">  <span class="comment">// #if aa == sizeof(int)</span></span><br><span class="line">  <span class="comment">//   puts("Yep!");</span></span><br><span class="line">  <span class="comment">// #endif</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="ifdef和-ifndef"><a href="#ifdef和-ifndef" class="headerlink" title="#ifdef和#ifndef"></a>#ifdef和#ifndef</h3><p><code>#ifdef</code>和<code>#if defined</code>类似，<code>#ifndef</code>和<code>#if !defined</code>类似（if not defined）。不同点是<code>#ifdef</code>和<code>#ifndef</code>后面只能跟预处理标识符，而不能跟常量表达式。</p>
<p><code>ifdef</code>和<code>ifndef</code>后面也要接<code>#endif</code>.</p>
<h2 id="include预处理指示符"><a href="#include预处理指示符" class="headerlink" title="#include预处理指示符"></a>#include预处理指示符</h2><p>通过头文件，可以将自己源码中的对外函数接口以及数据类型等共享给其他开发者。C语言的头文件以.h文件结尾，使用<code>#include</code>指令包含头文件。</p>
<p><code>#include</code>有两种形式：</p>
<ul>
<li><code>include &lt;头文件名&gt; 换行符</code></li>
<li><code>include &quot;头文件名&quot; 换行符</code></li>
</ul>
<p><code>&lt;&gt;</code>指定的文件路仅的搜索是实现自定义的，默认是操作系统存放库头文件的系统路径。也可以通过编译器环境变量和编译器命令行选项来指定。(例如在操作系统实现中，就不使用标准库，自定义了<code>&lt;&gt;</code>的查找位置)</p>
<p><code>&quot;&quot;</code>对指定的文件进行搜索，通常就是当前C语言工程项目下的路径；如果搜索不到，则换用<code>&lt;&gt;</code>进行搜索。</p>
<p>一般来说，对C语言标准库，我们使用<code>&lt;&gt;</code>，而对于自己编写的头文件，使用<code>&quot;&quot;</code>。</p>
<p><strong>#include后面可以跟一个宏名</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 头文件的内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> defs_h</span></span><br><span class="line"><span class="comment">// 用于防止重复include文件或者间接重复include</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> defs_h</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MY_MACRO 100</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">S</span> &#123;</span></span><br><span class="line">  <span class="keyword">int</span> a;</span><br><span class="line">  <span class="keyword">float</span> f;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyFunction</span><span class="params">(struct S s)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The value is %f\n"</span>, s.a+s.f);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// include文件中的内容</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defs.h"</span></span></span><br><span class="line"><span class="comment">// defs.h中已经包含了&lt;stdio.h&gt;，不需要再次包含，重复包含会报错</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 重复包含defs.h没有问题，因为我们在defs.h中做了保护</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"defs.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"The macro value is %d\n"</span>, MY_MACRO);</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">S</span> <span class="title">s</span> = &#123;</span> <span class="number">10</span>, <span class="number">1.5f</span> &#125;;</span><br><span class="line">  MyFunction(s);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>#include</code>指令的作用就是将头文件中的所有内容包含到<code>#include</code>指令所在的文件中。在defs.h中使用了<code>#ifndef</code>，用于防止重复包含，上例中，我们第一次已经将头文件包含进来了，第二次就不会将内容包含进来了。<strong>这说明include不是简单的复制，会分析被include文件中的预处理指令，将预处理指令执行完的结果include进来</strong></p>
<h2 id="error"><a href="#error" class="headerlink" title="#error"></a>#error</h2><p><code>#error</code>指令用于在预处理工程中报出指定的错误诊断信息。其基本形式为：<code>#error 预处理符号 换行符</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_SAFE_MACRO</span></span><br><span class="line">  <span class="comment">// 报错，#error后面接的是错误信息</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">error</span> safe macro not defined!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接报错，没有提示信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> 警告信息</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="line"><a href="#line" class="headerlink" title="#line"></a>#line</h2><p><code>#line</code>用于作为行号控制，形式为：<code>#line 数字序列 换行符</code>后面的数字指示它下一行的行号，而忽略它之前的行号。</p>
<p>还有一种形式可以修改源文件名：<br><code>#line 数字序列 &quot;源文件名&quot; 换行符</code></p>
<p>注意，通过<code>__LINE__</code>宏可以获取到当前的行号，<code>__FILE__</code>可以获取到当前的文件名。</p>
<h2 id="undef"><a href="#undef" class="headerlink" title="#undef"></a>#undef</h2><p><code>#undef</code>用于取消之前定义的宏。</p>
<h2 id="pragma操作符。"><a href="#pragma操作符。" class="headerlink" title="pragma操作符。"></a>pragma操作符。</h2><p><code>#pragma</code>只是当前翻译单元使用某种编译特性进行编译。比如，可以指定哪些函数用某个优化选项进行优化，从哪里开始使用标准浮点约定等。形式为:<code>#pragma 预处理符号 换行符</code></p>
<p>这里的预处理符号就是编译选项，一般有编译器定义，但是C语言标准也定义了若干标准，以STDC作为前缀，形式为：<code>#pragma STDC 编译选项 开关值 换行符</code>。</p>
<p>开关值有三种，分别是：ON、OFF、DEFAULT。</p>
<p>C99引入了_Pragma操作符，语义和<code>#pragma</code>一样，不过可用于宏定义的替换列表中。形式：<code>_Pragma(字符串字面量)</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> MY_SAFE_MACRO</span></span><br><span class="line">  <span class="comment">// 报错，#error后面接的是错误信息</span></span><br><span class="line">  <span class="meta">#<span class="meta-keyword">error</span> safe macro not defined!</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 直接报错，没有提示信息</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">error</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">warning</span> 警告信息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用遵循浮点数标准的编译选项</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> STDC FP_CONTRACT ON</span></span><br><span class="line"><span class="comment">// 后面的代码启用O2进行优化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> O2</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">MyFunc</span><span class="params">(<span class="keyword">int</span> a)</span> </span>&#123;</span><br><span class="line">  a += <span class="number">10</span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d\n"</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> O0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 可用于宏替换列表</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> DEBUG</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAGMA_OPTION <span class="meta-keyword">_Pragma</span>(<span class="meta-string">"O0"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PRAGMA_OPTION <span class="meta-keyword">_Pragma</span>(<span class="meta-string">"o2"</span>)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">PRAGMA_OPTION</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">MyFunc2</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a * a + b * b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_Pragma(<span class="string">"O1"</span>) <span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="空指令"><a href="#空指令" class="headerlink" title="空指令"></a>空指令</h2><p><code>#</code>直接接换行就是空指令，空指定没有特殊作用。</p>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/page/0/">Previous</a></div><div class="pagination-next"><a href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">1</a></li><li><a class="pagination-link" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Bright Wu"></figure><p class="title is-size-4 is-block line-height-inherit">Bright Wu</p><p class="is-size-6 is-block">working harder to be better</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing Chaoyang</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">154</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">84</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">115</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wre232114" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wre232114"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://brightblog.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">brightblog.cn</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/spring%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">spring实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/"><span class="level-start"><span class="level-item">Open Source</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/Huaxu/"><span class="level-start"><span class="level-item">Huaxu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/"><span class="level-start"><span class="level-item">Webpack</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Webpack基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">Webpack实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">css基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">css工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/less/"><span class="level-start"><span class="level-item">less</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/sass/"><span class="level-start"><span class="level-item">sass</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/docker/docker-swarm/"><span class="level-start"><span class="level-item">docker swarm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/docker/docker%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">docker基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/"><span class="level-start"><span class="level-item">html5</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/html5/dom/"><span class="level-start"><span class="level-item">dom</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5-API/"><span class="level-start"><span class="level-item">html5 API</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="level-start"><span class="level-item">html5标签和属性</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/svg/"><span class="level-start"><span class="level-item">svg</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/js/js%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">js基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="level-start"><span class="level-item">正则表达式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/linux/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/"><span class="level-start"><span class="level-item">node.js</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/node-js/npm/"><span class="level-start"><span class="level-item">npm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">命令行工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/php/"><span class="level-start"><span class="level-item">php</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/"><span class="level-start"><span class="level-item">spring-boot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/typescript/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">踩坑指南</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vue/cli/"><span class="level-start"><span class="level-item">cli</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue-router/"><span class="level-start"><span class="level-item">vue-router</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">vue实战</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">vue组件开发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/xml/"><span class="level-start"><span class="level-item">xml</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/xml/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/"><span class="level-start"><span class="level-item">学习打卡</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">密码技术</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/"><span class="level-start"><span class="level-item">shell</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/"><span class="level-start"><span class="level-item">ucore</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">操作系统原理</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%AF%AD%E5%8F%A5/"><span class="level-start"><span class="level-item">sql语句</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AF%BC%E8%AE%BA/"><span class="level-start"><span class="level-item">导论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">数据库编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">数据库设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"><span class="level-start"><span class="level-item">图</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="level-start"><span class="level-item">树莓派</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%AF%95%E8%AE%BE/"><span class="level-start"><span class="level-item">毕设</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="level-start"><span class="level-item">模式匹配</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="level-start"><span class="level-item">深度优先搜索</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C语言</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/%E7%94%9F%E8%AF%8D/"><span class="level-start"><span class="level-item">生词</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wireshark/"><span class="level-start"><span class="level-item">wireshark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">问题记录</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="level-start"><span class="level-item">交给子类</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="level-start"><span class="level-item">生成实例</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">适应设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-27T13:07:22.000Z">2020-06-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE3-5%E5%AF%B8%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A5%97%E8%A3%85%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">树莓派3.5寸显示器套装安装操作系统</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:21:47.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/opensource/%E8%B7%A8%E6%A1%86%E6%9E%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%8E%9F%E5%9E%8B%E6%A6%82%E8%A7%88/">跨框架、自定义主题的静态博客系统原型概览</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Open-Source/">Open Source</a> / <a class="link-muted" href="/categories/Open-Source/Huaxu/">Huaxu</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:18:37.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/webpack/webpack%E5%AE%9E%E6%88%98%EF%BC%9A%E6%89%93%E9%80%A0%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%91react%E5%92%8Cvue%E7%9A%84%E6%9E%84%E5%BB%BA%E5%BC%95%E6%93%8E/">webpack实战：打造同时编译react和vue的构建引擎</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Webpack/">Webpack</a> / <a class="link-muted" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/">Webpack实战</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.142Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/php/Smarty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Smarty块度入门</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/php/">php</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.122Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/git/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93/">在centos上搭建git服务器仓库</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/git/">git</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Adapter%E6%A8%A1%E5%BC%8F/"><span class="tag">Adapter模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC/"><span class="tag">GCC</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Huaxu/"><span class="tag">Huaxu</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iterator%E6%A8%A1%E5%BC%8F/"><span class="tag">Iterator模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"><span class="tag">Linux命令行与shell脚本编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Maven/"><span class="tag">Maven</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Open-Source/"><span class="tag">Open Source</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Template-Method%E6%A8%A1%E5%BC%8F/"><span class="tag">Template Method模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%9F%BA%E7%A1%80/"><span class="tag">Webpack基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%AE%9E%E6%88%98/"><span class="tag">Webpack实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/autoprefixer/"><span class="tag">autoprefixer</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/browserslist/"><span class="tag">browserslist</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos7%E5%B7%A5%E5%85%B7/"><span class="tag">centos7工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%8D%95%E4%BD%8D/"><span class="tag">css单位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%9F%BA%E7%A1%80/"><span class="tag">css基础</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B7%A5%E5%85%B7/"><span class="tag">css工具</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B8%83%E5%B1%80/"><span class="tag">css布局</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker-swarm/"><span class="tag">docker swarm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker%E5%9F%BA%E7%A1%80/"><span class="tag">docker基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom/"><span class="tag">dom</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom%E5%9F%BA%E7%A1%80/"><span class="tag">dom基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html-Permission-API/"><span class="tag">html Permission API</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5/"><span class="tag">html5</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5-API/"><span class="tag">html5 API</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="tag">html5标签和属性</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%9F%BA%E7%A1%80/"><span class="tag">js基础</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1/"><span class="tag">js对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"><span class="tag">js对象类型判断</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E6%95%B0%E7%BB%84/"><span class="tag">js数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less/"><span class="tag">less</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E5%91%BD%E4%BB%A4/"><span class="tag">linux命令</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"><span class="tag">linux远程连接</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node-js/"><span class="tag">node.js</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npm/"><span class="tag">npm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postcss/"><span class="tag">postcss</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-boot/"><span class="tag">spring-boot</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring%E5%AE%9E%E6%88%98/"><span class="tag">spring实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E8%AF%AD%E5%8F%A5/"><span class="tag">sql语句</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg/"><span class="tag">svg</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%9F%BA%E7%A1%80/"><span class="tag">svg基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%AE%9A%E4%BD%8D/"><span class="tag">svg定位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tips/"><span class="tag">tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tslint%E5%9F%BA%E7%A1%80/"><span class="tag">tslint基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typescript/"><span class="tag">typescript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore/"><span class="tag">ucore</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore-os/"><span class="tag">ucore-os</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-cli/"><span class="tag">vue-cli</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-router/"><span class="tag">vue-router</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-tips/"><span class="tag">vue-tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"><span class="tag">vue博客后台开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%9F%BA%E7%A1%80/"><span class="tag">vue基础</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%AE%9E%E6%88%98/"><span class="tag">vue实战</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="tag">vue组件开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E8%BF%9B%E9%98%B6/"><span class="tag">vue进阶</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wireshark/"><span class="tag">wireshark</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xml/"><span class="tag">xml</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC-Primer%E3%80%8B/"><span class="tag">《C Primer》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E3%80%8B/"><span class="tag">《C语言编程魔法书》</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8CShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E3%80%8B/"><span class="tag">《Linux命令行和Shell脚本编程》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B/"><span class="tag">《图解密码技术》</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"><span class="tag">二叉树</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="tag">交给子类</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E6%B2%BB/"><span class="tag">分治</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%AF%8D/"><span class="tag">单词</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="tag">命令行工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE/"><span class="tag">图</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%88%98/"><span class="tag">实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="tag">密码技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%BC%E8%AE%BA/"><span class="tag">导论</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><span class="tag">异步编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="tag">操作系统原理</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="tag">数据库编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="tag">数据库设计</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%83%E9%99%90/"><span class="tag">权限</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="tag">模式匹配</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="tag">正则表达式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%95%E8%AE%BE/"><span class="tag">毕设</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="tag">深度优先搜索</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="tag">生成实例</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="tag">踩坑指南</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">适应设计模式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="tag">问题记录</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%95%B01/"><span class="tag">高数1</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 Bright</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("default");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.brightblog.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>