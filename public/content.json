{"pages":[],"posts":[{"title":"阅读中遇到的不熟悉的单词","text":"这篇文章记录了在读书、文档中遇到的英语生词，用于提升英语能力以及定期的单词复习 123456789101112131415161718192021222324252627282930313233343536enbark 从事malfunction 故障severity 严格、严厉、严重minor 较小的、次要的、未成年的semantic 语义的、语义学的vetur 冬季approximate 大约、近似is aware of 知道concatenation 串接、连接、编程中指字符串连接caret 插入符号，光标符号glossary 词汇表（glocery，杂货铺）obsolte 过时的dedicated 专用spawn 卵、产物、产卵cumbersome 笨重的disposable 一次性的revoke 撤销、取消、废除comprise 包含、由...组成regarding 至于、关于；就...而论enormous 巨大的、即大的，庞大的verbatim 逐个的，逐字的versatile 多才多艺verbose 冗长的，啰嗦的stash 藏匿处，藏匿物；贮藏，存放condense 浓缩；使压缩internalize 使内在化；phony 假的，欺骗的；骗子；假货suppress 压制、镇压；抑制dump 倾倒、倾卸impose 推行，强制实行；欺骗penetration 渗透、侵入、突破anatomy 解剖；剖析；人体；骨骼；干尸granularity 粒度","link":"/2019/08/31/%E9%98%85%E8%AF%BB%E4%B8%AD%E9%81%87%E5%88%B0%E7%9A%84%E4%B8%8D%E7%86%9F%E6%82%89%E7%9A%84%E5%8D%95%E8%AF%8D/"},{"title":"GCC常用选项","text":"这篇文章学习GCC中的常用选项。 -I dir将dir目录添加到预处理过程中搜索include头文件的目录中。通过-isyatem和-idirafter可以指定include &lt;file&gt;和include &quot;file&quot;的搜索路径。 -M输出一个适用于make的规则，而不是输出预处理的结果。该规则描述了主要源文件的依赖关系。 -MM和-M类似，但是不mention在系统头文件目录中找到的头文件。不能是直接还是间接的都不会从这样的头中包含。 -MT改变被依赖生成发射的rule的target。-MT选项将target设置成你指定的字符串。","link":"/2019/11/23/c-c++/GCC%E5%B8%B8%E7%94%A8%E9%80%89%E9%A1%B9/"},{"title":"GCC内联汇编","text":"GCC提供了在C语言中嵌入汇编语言的能力。在C语言中嵌入汇编，在操作系统和嵌入式软件中开发很有用，编写底层软件时能够直接访问硬件。但是编写客户端软件时有些汇编指令是不可用的，所以编写windows或者linux下的客户端软件时，使用某些指令可能会出错。因为计算机系统的保护模式会提供对特定指令的保护，这些指令只能在内核态中运行；而一般的应用运行于应用层，特权级最低，仅能通过系统调用来获取访问系统资源。 两种内联汇编语法GCC有两种内联汇编语法，一种是简单内联汇编，另一种是扩展内联汇编。简单内联语法如下：1asm [volatile] (asm instructions);例如：1asm (\"pushl %eax;movl $0,%eax;popl %eax;\");这种情况下C语言不能和汇编进行交互，而且如果使用的寄存器恰被C编译器分配给其他变量，那么这里对寄存器重新赋值就会出现问题。扩展内联汇编语法 不同的汇编指令之间要用\\t\\n或者;隔开，表示不同的指令。 asm、volatile和__asm__和__volatile__是完全相同的，两者均可。 扩展内联语法GCC下通过asm可以在C语言中嵌入汇编指令，如下例：123456789101112131415161718#include &lt;stdio.h&gt;int main(void) { int a = 40; int b; asm( \"movl %1,%%eax;\" \"shr %%eax;\" \"movl %%eax,%0;\" : \"=r\"(b) : \"r\"(a) : \"%eax\" ); printf(\"a = %d, b = %d\\n\", a, b); return 0;}上面的代码通过asm嵌入了一系列汇编指令。通过asm扩展语法，这些汇编指令能够和C语言中的变量进行交互，能够将C语言中变量的值传到汇编中，也能够将汇编中计算的值赋值给C语言中的变量。上面的示例就是将变量a赋值给eax寄存器，然后将eax寄存器右移一位（相当于除2），然后将结果输出给变量b。 asm的语法如下：12345asm volatile (汇编语言模板 : 输出操作数 : 输入操作数 : 使用的寄存器 );volatile暗示编译器不需要对这部分代码进行优化。编译器优化时可能会调整指令的位置，如果我们不希望编译器这么做，可以加上volatile让编译器不优化。 汇编语言模板这个汇编语言模板起始就是汇编语言，只是指令的操作数用占位符代替。例如：movl %eax, %0。这里的%0就是一个占位符，通过占位符和C语言变量交互。 注意如下要点： 模板中的寄存器有两个百分号%%eax 使用%0，%1作为占位符和C语言变量交互。先输出后输入，意思就是，如果有2个输出，那么%0、%1就是输出，后面才是输入；如果有三个输出，那么%0、%1、%2是输出、后面是输出，依次类推。 可以通过寄存器寻址：movb (%%eax),%al 数字以$开头：$3 多个指令之间使用\\t\\n或者;隔开 输入输出参数通过输入输出参数可以将C语言变量匹配到内联汇编中。例如：12345678910int array[2], i = 0; array[0] = 150; asm volatile ( \"movl %1,%%eax;\" \"shl %%eax;\" \"movl %%eax,%0;\" : \"=r\"(array[i+1]) : \"r\"(array[i]) ); printf(\"array[0] = %d, array[1] = %d\\n\", array[0], array[1]);&quot;=r&quot;(array[i+1])中，=表示输出操作符，r表示值必须放在任意一个寄存器中，输入时会将变量加载到这个寄存器中，输出时会从这个寄存器输出到变量所在的内存中。除了r之外，常用的约束字母如下： m、v、o：内存单元 r：任何通用寄存器 q：abcd四个寄存器之一 l、h：直接操作数 E、F：浮点数 G：任意 a、b、c、d：eax/ax/al、ebx… S、D：esi或者edi I：常数（0-31） 如果输入和输出时一个操作数，那么可以用下面的方式：123asm(\"incw %0;\": \"=a\"(counter): \"0\"(counter));&quot;0&quot;表示引用%0表示的寄存器，所以输入和输出使用的是同一个寄存器。 使用的寄存器最后一个冒号接的是使用的寄存器，告诉编译器我需要这些寄存器或者这些寄存器的值已经改变；编译器在分配寄存器的时候就会考虑这些因素。 如果使用memory，表示某些内存中的值已经改变。如果之前编译器已经将该内存的值放在了寄存器中，那么会导致数据不一致。使用memory告诉编译器这个信息，编译器会处理这些情况。 __attribute____attribute__用于在函数和变量声明的时候，给编译器设置一些属性，从而实现对函数的优化和对变量声明的控制。 例如：123456void fatal_error() __attribute__((noreturn));struct mong { char id; int code __attribute__((align(4)));}告诉编译器这个函数没有返回值，所以编译器编译时会进行优化，不产生函数返回相关的代码；结构体中的成员按照4字节对齐。 常用的属性值如下： always-inline：将函数作为inline函数，尽可能优化并放在CPU能够尽快取到的位置 packed：用于结构体成员，表示拥有尽可能小的对齐属性；用于结构体，表示结构体的总大小尽可能小。","link":"/2019/12/01/c-c++/GCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/"},{"title":"gcc编译器初步","text":"gcc编译器入门最近重新复习c/c++，操作系统等等计算机的基础知识，直接从gcc开始，这一篇文章记录gcc编译器命令行的基本使用。 使用gcc编译器编译第一个程序编写一个HelloWord.c文件，于目录下运行： gcc HelloWorld.c -o HelloWorld.out 这将在当前目录下生成HelloWorld.out文件，运行./HelloWorld.out执行生成的可执行文件。 注意：在linux系统下，不以后缀区分可执行文件，和windows下不同。.out只是为了区分这是由gcc生成的文件 C语言的编译过程如下图: 预处理，生成.i文件 将.i文件编译成汇编文件，生成.s文件 汇编语言文件经过汇编，生成.o文件 将多个.o文件链接起来生成可执行文件 接下来我们看每个步骤对应的编译选项和中间输出结果。选项|作用:—:|:—:-E|预处理-S|生成汇编文件-c|生成.o文件-o|指定输出的文件名-g|生成调试信息 预处理—— -E选项-E选项生成预处理的文件，预处理比如宏命令和包含文件的展开等等。参考这里，有一些其他的选项，比如如何指定其他的include目录。 我们对上面的HelloWorld.c，执行一下: gcc -E HelloWorld.c -o HelloWorld.i 下面截取了一些代码片段，可以看到将#include &lt;stdio.h&gt;包含进来了，.i文件中已经包含了stdio中的代码。12345678910111213# 1 \"HelloWorld.c\"# 1 \"&lt;built-in&gt;\"# 1 \"&lt;command-line&gt;\"# 31 \"&lt;command-line&gt;\"# 1 \"/usr/include/stdc-predef.h\" 1 3 4# 32 \"&lt;command-line&gt;\" 2# 1 \"HelloWorld.c\"# 1 \"/usr/include/stdio.h\" 1 3 4# 27 \"/usr/include/stdio.h\" 3 4# 1 \"/usr/include/features.h\" 1 3 4# 375 \"/usr/include/features.h\" 3 4# 1 \"/usr/include/sys/cdefs.h\" 1 3 4... 生成汇编语言 -S选项如果想把C语言变量的名称作为汇编语言语句中的注释，可以加上-fverbose-asm选项： gcc -S HelloWorld.i -o HelloWorld.s HelloWorld.s12345678910111213141516.file &quot;HelloWorld.c&quot; .text .section .rodata.LC0: .string &quot;hello world!&quot; .text .globl main .type main, @functionmain:.LFB0: .cfi_startproc pushq %rbp .cfi_def_cfa_offset 16 .cfi_offset 6, -16 movq %rsp, %rbp... -c选项生成没有链接的文件使用-c选项会为每一个.c文件生成一个.o文件，.o文件链接之后才会生成可执行文件。 编译链接多个文件&amp;生成动态链接库","link":"/2019/06/11/c-c++/gcc%E7%BC%96%E8%AF%91%E5%99%A8%E5%88%9D%E6%AD%A5/"},{"title":"计算机网络复习问题记录","text":"如何组建一个完整的计算机网络？如何设置核心路由器、组建局域网、接入无线路由器？如何选择网络传输介质？在思科的模拟软件上模拟一个完整的网络。 无线路由器和核心路由器是不是一样的？如何将无线路由器接入局域网？","link":"/2020/02/04/computer-network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%A4%8D%E4%B9%A0%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"title":"centos7 下升级gcc编译器","text":"只支持64位程序。 12yum -y install centos-release-sclyum -y install devtoolset-8-gcc devtoolset-8-gcc-c++ devtoolset-8-binutils 高版本gcc不是默认开启的，如果只想在当前命令行中使用，输入：1scl enable devtooset-8 bash 如果想永久开启，以管理员权限执行：12echo \"source /opt/rh/devtoolset-8/enable\" &gt;&gt;/etc/profileecho \"source /etc/profile\" &gt;&gt;~/.bashrc","link":"/2019/11/11/c-c++/centos7-%E4%B8%8B%E5%8D%87%E7%BA%A7gcc%E7%BC%96%E8%AF%91%E5%99%A8/"},{"title":"计算机网络概述","text":"这里文章从总体上复习计算机网络涉及的基本概念，主要包括计算机网络的组成成分、时延、协议栈分层、安全等知识点，从总体上概览计算机网络的方方面面。其中知识点的细节会分布到后面的每一个章节中复习，最终的复习目标是全面掌握整个计算机网络的工作原理，从终端设备、交换机、路由器，到每一个设备涉及的协议栈的细节，涵盖《计算机网络》和《计算机网络技术和应用》的知识。 计算机网络的构成计算机网络的物理组成是网络边缘、接入媒体和网络核心。1234567终端设备（边缘） | |接入媒体（接入） 路由器（核心） -------- 终端设备 | | 终端设备 网络边缘网络边缘主要包括的就是终端设备，包括PC、手机、平板电脑、服务器、嵌入式设备等等使用终端应用程序访问互联网的设备。这些终端设备也能被分成客户端和服务器，分别使用和提供网络服务。 接入媒体网络边缘通过接入媒体接入到计算机网络中，接入媒体指将端系统连接到边缘路由器的物理链路。注意网络边缘指物理链路，平时我们上网要通过网线接入网络，这里的网线就是接入媒体的一种。除此之外，还有无线局域网（wifi），4G、5G等无线接入方式。 家庭接入家庭前几年一般通过DSL（数字用户线）和电缆来接入。DSL通过电话线来接入网络，电话线同时承载了网络数据和传统的电话信号，不过被编码成频率不同的信号。在用户一层需要通过分频器来区分网络数据和电话数据，网络数据还要通过DSL调制调解器解析后到达PC。在电话商一侧，也需要将这两个信号分开，分别接入因特网和电话网络。如下图： 123456789家庭电话 \\ 因特网 \\ 电话线，分频率区分电话和网络 / 分频器 -------------------------- 中心局 / \\ / 电话网 DSL调制调解器 /家庭PC DSL利用了频分复用技术，所以网络、电话能够同时使用一根电话线来进行通信。本文后面会介绍频分复用和时分复用之间的区别和优劣。 电缆接入和DSL接入类似，不过电缆接入使用的有线电视的基础设施，而DSL使用的是家庭电话的基础设施。DSL接入使用的是双绞线、而电缆接入使用的是同轴电缆。同轴电缆也要通过电缆调制调解器解析信号。123 PC PC \\ \\ 同轴电缆----------------------- 目前最常用的是FTTH（光纤到户），家庭通过光纤接入到互联网中，通过光纤网络端接受器来解析光纤中传输的数据。 企业（家庭）接入家庭接入主要是使用本地运营商提供的服务，通过一定的接入网络（DSL、电缆、FTTH），直接将数据发给运行商，运行商再发送到因特网中。 而企业接入一般也要使用本地运营商提供的服务，但是由于一个企业往往有多台设备，我们希望这些设备在一个网络中，这时候使用的是局域网。用户发送的数据先通过局域网，然后再发送给服务商。相当于在家庭网络的基础上再组建了一个小型网络。 当一个家庭中有多台设备时，也可以自行组建以太网，这时候需要自行购入以太网交换机，并将多台设备连接到交换机上。使用双绞铜线与以太网交换机相连。 通过无线路由器，可以组建无线局域网，还可以将无线设备接入到因特网中。","link":"/2020/02/04/computer-network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E6%A6%82%E8%BF%B0/"},{"title":"browserlist文档学习","text":"browserslist用于在不同的前端工具，比如autoprefixer、stylelint、babel-preset-env间共享相同的目标浏览器和nodejs环境。使用该配置的工具如下： autoprefixer babel postcss-preset-env eslint-plugin-compact styleline-no-unsupported-browser-feature postcss-normalize obsolete-webpack-plugin 所有的工具都会自动找到目标浏览器，当在package.json中添加以下字段的时候：123456\"browserslist\": [ \"last 1 version\", \"&gt; 1%\", \"maintained node versions\", \"not dead\"]或者在.browserslistrc配置文件中添加：123456# Browsers that we supportlast 1 version&gt; 1%maintained node versionsnot dead 最佳实践 当且仅当只在特定的浏览器下开发使用web app时，才会直接选择浏览器（例如：last 2 Chrome versions）。如果开发通用的web app，那么一定要考虑浏览器的多样性。 有默认的查询，给大多数的用户一个合理的默认配置。 如果改变默认的浏览器集，推荐组合last 1 version，not ，dead，以及&gt;0.2%（或者 &gt;1% in US） 不要删除你不知道的浏览器。 查询browserslist从以下来源获取query： 在package.json中。官方推荐这种方式 .browserslistrc，当前或者父目录 browserslist配置文件，当前目录或者父目录 BROWSERSLIST环境变量， 如果以上都没有，那么会应用默认的：&gt;0.5%，last 2 versions，Firefox ESR，not dead 查询组合可以使用三种方式组合查询： or和,代表取并集 and取交集 not取反 完整的查询清单You can specify the browser and Node.js versions by queries (case insensitive): > 5%: browsers versions selected by global usage statistics. &gt;=, &lt; and &lt;= work too. > 5% in US: uses USA usage statistics. It accepts two-letter country code. > 5% in alt-AS: uses Asia region usage statistics. List of all region codes can be found at caniuse-lite/data/regions. > 5% in my stats: uses custom usage data. cover 99.5%: most popular browsers that provide coverage. cover 99.5% in US: same as above, with two-letter country code. cover 99.5% in my stats: uses custom usage data.*maintained node versions: all Node.js versions, which are still maintained by Node.js Foundation. node 10 and node 10.4: selects latest Node.js 10.x.x or 10.4.x release. current node: Node.js version used by Browserslist right now. extends browserslist-config-mycompany: take queries from browserslist-config-mycompany npm package. ie 6-8: selects an inclusive range of versions. Firefox &gt; 20: versions of Firefox newer than 20. &gt;=, &lt; and &lt;= work too. It also works with Node.js. iOS 7: the iOS browser version 7 directly. Firefox ESR: the latest [Firefox ESR] version. unreleased versions or unreleased Chrome versions: alpha and beta versions. last 2 major versions or last 2 iOS major versions: all minor/patch releases of last 2 major versions. since 2015 or last 2 years: all versions released since year 2015 (also since 2015-03 and since 2015-03-10). dead: browsers without official support or updates for 24 months. Right now it is IE 10, IE_Mob 10, BlackBerry 10, BlackBerry 7, Samsung 4 and OperaMobile 12.1. last 2 versions: the last 2 versions for each browser. last 2 Chrome versions: the last 2 versions of Chrome browser. defaults: Browserslist’s default browsers (&gt; 0.5%, last 2 versions, Firefox ESR, not dead). not ie &lt;= 8: exclude browsers selected by previous queries. 思考browserslist查询的书写方式就是将上面的清单用再上面提到的三种组合方式组合起来。 其他的库和框架会根据上面提到的browserslist的来源中的查询表达式来确定支持的浏览器。所以我们使用browserslist和第三方库的时候，只需要将组合的查询写道browserslist配置中，然后第三库就会自动识别并使用满足查询的浏览器。 browserslist还提供了api、环境变量等的访问方式，等用到的时候再查文档添加。","link":"/2019/08/14/css/browserlist%E6%96%87%E6%A1%A3%E5%AD%A6%E4%B9%A0/"},{"title":"css中的基本框模型","text":"概述这是一篇css基础的文章，主要讲css中的各类框模型的细节，比如inline-block，table，flex，grid。这里会解答一些开发中常见的问题，例如：为什么有时候我设了外边距、内边距没有效果？ 这些其实很多都是由css框模型来决定的。那么问题来了：css中的框模型不就是外边距+边框+内边距+内容吗？有什么好说的呢？ 其实不然。你知道在什么时候框模型没有外边距、没有内边距吗？为什么表格设了宽度没有效果？事实上，但我们使用display指定不同的布局形式的时候，框模型会根据不同的值，有不同的行为。 同时，也会描述html和css分离的思想，例如，我们知道&lt;div&gt;是块级元素，所有的书上都会这么写，但是其实，只是&lt;div&gt;默认布局是display:block，这是由浏览器实现的默认行为。用这种思想来看待css和html，就会清晰很多。事实上，在浏览器底层，是使用dom+cssdom来构建页面的，cssdom就是由浏览器默认样式、开发者定义的样式等来构建的。html元素的几乎所有样式行为，都可以由css来定制。 当我们理解了上面的两个核心概念——不同框模型的不同行为+html与css分离的思想——之后，我们对于页面的理解/把控一定会更上一层楼。 举个例子举个例子，对于表格来说，表格元素(table)和表格单元格(th,td)的框模型其实不一样，表格单元格没有外边距，表格没有内边距（当table-collapse:collapse时，设置内边距没有效果），也就是说在表格单元格设置外边距和表格上设置内边距是无效的。同时，依照html和css分离的思想，表格是display:table，表格单元格是display:table-cell，所以我们在div上使用display:table-cell，可以将div的框模型变成表格单元格，与普通的td并无区别——因为td默认就是display: table-cell。 上一张表格的框模型图：在图中我们可以看到，右上角的user agent stylesheet表明是浏览器默认提供的样式表。 我们在设置一下table-cell的margin看看123td { margin: 20px;}可以看到，表格单元格的框模型里面没有margin,只有border,padding和content。 而对于thead,tbody,tr,tfoot呢？thead,tbody,tr,tfoot只有内容和边框，没有内边距和外边距。后面会详细讲表格的细节，包括如何实现表格单元格宽度固定、单行/多行文本、利用css表格属性实现块级/非块级的水平垂直居中对齐等等。 接下来我们列举一些display属性值，来看看其框模型行为究竟是怎样的。 display:block/inline这是最常见的两种布局模式，html块级元素的默认布局是block，内联元素的默认布局是inline。相信大家都知道block和inline的区别——block元素单独一行，可以设置宽高；inline元素不能设置宽高，超出一行的内容会自动换行。 如果我们想让一个元素表现得像块级元素，只需设置其display:block，这样设置的元素和div元素没有任何的区别，因为div的默认样式就是display:block。去掉外在，大家都一样，穿上一样的衣服，大家也都一样，这篇文件中会始终使用这个思想（仅仅是个人的理解，不具备任何权威性，大家做个参考就好，欢迎提出批评和指正） inline和inline-block会继承上级的line-height属性，block每一个block都有自己的line-height属性，当我们要使用line-height进行子元素垂直居中的时候，就需要注意这一点。 display:inline-blockdisplay:inline-block综合了两种元素的特性，表现的像内联元素，但是它可以设置宽高。 这里需要注意的是，如果我们在一个block元素中写了多个inline-block元素，而我们在源代码中将这几个元素写在了很多行中，那么页面中会多出来间隙，多出来的间隙其实是空格，只不过浏览器将换行、空格等都合并成一个空格了。 这个问题在多个不同行的内联元素中均存在。 如下面的例子：123456789101112&lt;style&gt;span { width: 50px; height: 40px; border: 1px solid gray; display: inline-block;}&lt;/style&gt;&lt;div&gt; &lt;span&gt;&lt;/span&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt;效果如下图： 去掉空格可以将父元素的font-size设置成0，然后子元素的字体设置成对应的字体。 123456div { font-size: 0;}span { font-size: 16px;} ie8及以上完全支持，在ie6、ie7中不支持，但是可以模拟，在ie6、ie7中，兼容性写法如下：12345span { display: inline-block; *display: inline; *zoom: 1;}*开头是ie特有的，inline说明元素内联显示，zoom触发布局，让其可以设置宽高。 display:table/inline-tabletable和inline-table的区别是，table占单独的一行，而inline-table是内联的，这两者的表格特性都完全相同。inline-table可以用于内联元素的垂直距中对齐。 在前面的示例中我们已经对表格进行了一些介绍，这里稍微总结一下： 在表格设置了border-collapse: collapse时，table元素设置padding无效 th、th没有margin，只有padding thead、tfoot、tbody、tr只有border，没有padding、margin 接下来我们更加深入表格，这里我分出来下面几个特性： 表格能否设置宽高 表格宽高是否根据内容自动扩张 表格内容换行/不换行 表格内容对齐 表格设置宽高使用width: VALUE，就可以设置表格的宽。这里需要注意的是，使用table-layout:auto，表格的宽度会随内容的扩展而扩展，不管是否设置了宽高（这时候的宽高相当于min-width、min-height）；使用table-layout:fixed; width:VALUE可以限定表格的宽高，需要注意的是，如果给子元素设置了固定宽高，且子元素的宽度之和大于父元素设置的宽度，那么表格依然会扩展自己的宽度来适应子元素的宽度。 表格宽高根据内容自动扩展当table-layout为auto时，表格的宽高会根据内容来自动扩展，即便我们设置了宽高，当内容的宽度大于表格宽度，表格宽度依然会自动扩展，宽度为width的单元格将不显示； 当table-layout为fixed时，需要指定table的width，然后再设置表格单元格的width。这时候表格的宽度就是固定的。但是仍然要注意： 所有单元格的内容宽度之和大于表格宽度，表格依然会扩展自己的宽度 所有单元格都设置了宽度，且宽度之和小于表格宽度，那么按照单元格的宽度之比将表格宽度分给单元格。例如：123456789101112131415161718&lt;style&gt; table { table-layout: fixed; width: 500px; } td { width: 200px; } td:first-child { width: 100px; }&lt;/style&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;111&lt;/td&gt; &lt;td&gt;bright&lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; 那么两个单元格会按照1:2的比例来分这500px。 当只设置了其中某一个或者某几个表格的宽度时，剩下的单元格会平分剩下的空间 高度会始终适应内容的高度，设置height的效果始终只相当于min-height 表格换行/不换行但表格内的内容是文本时，我们可以利用white-space和word-break属性来控制文本的换行，当没有限定表格单元格的宽度的时候，宽度是根据内容来自适应的，会首先尽量填满表格的空间而不会换行。 表格内容对齐可以很方便的利用表格进行垂直居中对齐。 块级元素垂直居中对齐：123456789101112131415161718192021222324&lt;style&gt; .table { width: 400px; height: 400px; display: table; } .table-cell { width: 100px; height: 100px; display: table-cell; vertical-align: middle; } .content { width: 50px; height: 50px; margin: 0 auto; font-size: 14px; }&lt;/style&gt;&lt;div class=\"table\"&gt; &lt;div class=\"table-cell\"&gt; &lt;div class=\"content\"&gt;&lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 效果如下： 内联元素和块级类似，块级元素水平居中使用margin:0 auto;，内联元素使用text-align: center;垂直居中使用 内联元素、块级元素、匿名元素之间的关系总结接下来对上面提到的一些框模型进行总结，如下表：框模型|特有的css属性|有无内边距|有无外边距|能否设置宽高|备注:—:|:—:|:—:|:—:|:—:|:—:block|/|有|有|可以|利用width可以设置宽度，width:100%可以拉伸，width:auto内容自适应inline|/|有|有|不能|一个块级元素中有多个内联元素，这些内联元素在代码中不在同一行，那么页面中会被插入空格，解决方案看下面inline-block|/|有|有|可以|多行的inline/inline-block会被插入空格，使用font-size可以解决","link":"/2019/06/15/css/css%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A1%86%E6%A8%A1%E5%9E%8B/"},{"title":"centos 7下安装wireshark","text":"wireshark是一款可以对网卡进行抓包的软件，能获取到网卡上收到的二进制数据，可以分析到达主机的网络包，分析其使用的协议，内容等等。这篇文章我们介绍如何在centos 7下安装wireshark。 安装12&gt; yum install wireshark&gt; yum install wireshark-gnome 解决权限问题安装完成后打开软件提示权限不允许，这时候需要将/usr/sbin/dumpcap添加到用户所在的组中，例如：1sudo chgrp /usr/sbin/dumpcap bright 执行完成后有权限访问了，但是没有接口，开启接口执行下面的命令：1setcap cap_net_raw,cap_net_admin+eip /usr/sbin/dumpcap","link":"/2019/10/02/computer-network/centos-7%E4%B8%8B%E5%AE%89%E8%A3%85wireshark/"},{"title":"css中各种百分比的指向","text":"在日常的开发中，我们会接触到各种各样的百分比单位，那这些百分比到底是参照于谁呢？查了一些资料，下面做一个总结： 相对于父元素的宽度max-width、min-width、width、left、right、text-intent、padding、margin、grid-template-columns、grid-auto-columns、column-gap等。 这里需要注意，margin、padding是相对于父元素的宽度，也就是padding-top、padding-bottom也是相对于父元素的宽度，利用padding的这个特性我们可以将一个盒子容器撑起来，实现等宽高比盒子缩放。这个特性在实现图片自适应，同时保持宽高比的情况下非常有用。 还有一个需要注意的是，box-sizing的设置对百分比宽度是有影响的： width、min-width、max-width始终相对于content-box left、right跟随box-sizing走，如果box-sizing是border-box，那么left、right相对于的是border-box 相对于父容器高度min-height、max-height、height、top、bottom、grid-template-rows、grid-auto-rows、row-gap等。 相对于自身宽高border-radius、background-size、border-image-width、transform: translate()、transform-origin、zoom、clip-path等； 相对于主轴长度flex-basis 相对于继承的font-sizefont-size 相对于自身的font-sizeline-height 相对于line-heightvertical-align","link":"/2019/07/14/css/css%E4%B8%AD%E5%90%84%E7%A7%8D%E7%99%BE%E5%88%86%E6%AF%94%E7%9A%84%E6%8C%87%E5%90%91/"},{"title":"css容易弄错的小细节","text":"有很多容易被我们忽略的小细节，所以理所当然的认为的错误的细节，这里做一个汇总，遇到了就到这里添加。 多类选择器在class属性中我们可以指定多个class，例如：12345678910&lt;style&gt;.red { color: red;}.blue { color: blue;}&lt;/style&gt;&lt;div class=\"red blue\"&gt;color&lt;/div&gt;&lt;div class=\"blue red\"&gt;color&lt;/div&gt; 这里我们需要注意的是：多个class的顺序是无关紧要的，在上例中”red blue”=”blue red”。 那上例中的颜色到底是什么样的呢？首先可以确定是，两个div的文字颜色是一样的，因为”red blue”=”blue red”。 这里就涉及到css选择器的权重机制，权重由高到低： !important === 10000 style属性，内联选择器 === 1000 id选择器 === 100 类、伪类、属性选择器 === 10 标签、伪元素选择器 === 1 *，&gt;，+，～ === 0 那么权重相同时如何处理呢？这时候就由css声明的顺序决定了。因为blue声明在red的后面，所以上面两个div的颜色都是blue。 同时注意，style标签可以视为放在所有属性表的最后面，如果style和link指定的样式选择器中有权重相同，同时指定了同一个css属性比如color，那么style标签优先。","link":"/2019/07/24/css/css%E5%AE%B9%E6%98%93%E5%BC%84%E9%94%99%E7%9A%84%E5%B0%8F%E7%BB%86%E8%8A%82/"},{"title":"css布局：Grid","text":"参考资料：mdn css grid css grid布局是一个web上二维布局系统，它可以让你把内容放置在数行和数列中，而且可以通过一系列的特性，实现复杂的布局。 什么是Grid布局？一个grid只是简单的行和列的集合，grid创建了一种模式我们可以在一行上放置我们设计的元素。 一个grid通常有三种元素，rows、columns、gutters（行列之间的间隙）。 在css中创建grid这里首先会介绍Grid布局的基本特性，然后探索如何在自己的项目中引入基本的grid布局。 定义一个grid使用display:grid来定义一个grid布局容器。类似与flex布局，这会将当前容器切换到grid布局系统，并且容器的所有直接子元素都会变成grid items。123.container { display: grid;}但是不像flex布局，grid默认是一列，所以看起来只设置的display: grid看起来并且没有什么区别。 接下来我们在grid中设置多列：12345.container { display: grid; grid-template-columns: 200px 200px 200px;}然后看起来就像下面这样： .mycontainer { display: grid; grid-template-columns: 200px 200px 200px; } .mycontainer div { background: lightseagreen; border: 2px solid seagreen; border-radius: 5px; } 1 2 3 4 5 6 7 通过fr实现弹性的grid除了使用长度和百分比来创建grid之外，我们还可以使用fr来弹性设置grid rows和grid columns。1fr代表代表grid容器的一份可用空间。 改变上面的代码：1234.mycontainer { grid-template-columns: 1fr 1fr 1fr; grid-gap: 20px;} .mycontainer1 { display: grid; grid-template-columns: 1fr 1fr 1fr; grid-gap: 20px; } .mycontainer1 div { background: lightseagreen; border: 2px solid seagreen; border-radius: 5px; } 1 2 3 4 5 6 7 我们看到三列平分了每一行的可用空间。如果我们将第一列改称2fr，那么每一行的可用空间总共分成4份，第一列占2份（和flex一样）。可以使用grid-column-gap、grid-row-gap设置列和行之间的间距，或者grid-gap同时设置行和列的间距。gap支持长度和百分比，但是不支持fr单位。最新的标准变成了gap属性，为了统一多列布局和grid布局的gap，所以最保险的做法是同时使用grid-gap和gap属性。","link":"/2019/08/13/css/css%E5%B8%83%E5%B1%80%EF%BC%9AGrid/"},{"title":"css布局：flex","text":"","link":"/2019/12/13/css/css%E5%B8%83%E5%B1%80%EF%BC%9Aflex/"},{"title":"每日学习打卡记录","text":"每日打卡这篇文档记录了每日学习到了什么新知识，干了一些什么事情，持续记录。 每周学习计划（markdown不支持合并单元格，使用table来实现） 日期 时间段 任务 周一 7:00-8:30 操作系统原理和实现 9:00-19:30 上班，有时间空余的话看看开源框架的文档 20:30-21:30 读书，程序设计原理，写读书笔记 21:50-22:50 读书linux基础&amp;命令行和shell脚本 23:00-23:30 个人博客网站完善 周二 7:00-8:30 数学基础 9:00-19:30 上班，有时间空余的话看看开源框架的官网 20:30-21:30 读书，《深入浅出Vue.js》，写读书笔记 21:50-22:50 C/C++语言 GCC和汇编 23:00-23:30 个人博客网站完善 周三 7:00-8:30 操作系统原理和实现 9:00-19:30 上班，有时间空余的话看看开源框架的官网 20:30-21:30 读书，《鸟哥的linux私房菜》，写读书笔记 21:50-22:50 leetcode算法刷题 23:00-23:30 个人博客网站完善 周四 7:30-8:30 leetcode刷题 9:00-19:30 上班，有时间看开源框架的官网 20:30-21:30 《程序设计原理》 21:50-22:50 《linux脚本和命令行基础》 23:00-23:30 个人博客网站 周五 7:30-8:30 数学基础 9:00-19:30 上班，有时间看开源框架的官网 20:30-23:30 休息，打打游戏，或者学习 周六日 0:00-24:00 最多打半天游戏，时间主要给操作系统和前端基础，其他再自行安排 2019.5.28 星期二 学习sass，参阅博客《sass快速入门》 完成博客内容页的基本布局，三列宽度自适应，利用左右浮动和margin实现。 添加markdown编译后的html样式 2019.5.29 星期三 进行个人博客网站的开发 完成card样式 调整样式 2019.5.30 星期四 学习table框模型 table没有padding、table-cell没有margin table的列宽度是按照第一列（设定宽度型）或者该列所有行中宽度最大的那一列（自动）来设置 table-layout有两种取值:auto和fixed，fixed是设定宽度型，auto是默认值。 学习解决外边框合并 父子元素的外边距合并可以通过设置父元素的边框或者padding解决 子元素之间的外边距无法取消，可以通过透明边框或者padding来实现效果 开发个人博客网站 调整文章的样式，标题、p的line-height、text-indent、margin 调整hr（分隔线的样式），添加透明度 调整card，添加font-awesome（实际上就是导入字体，设置字体，然后将字符的值设置成指定的值比如’\\f002’，一般用::before+content来实现） 添加分类 2019.6.3 周一 配置自动化git部署 创建git服务器仓库，ssh连接需要使用~/.ssh/authorized-keys 使用git钩子——post-receive，需要赋予执行权限，写shell脚本在这个里面实现服务器上的代码仓库pull 服务器仓库是空的，所以在服务器上另外clone一个源代码仓库，然后每次提交对这个仓库进行pull和hexo generate 在hexo generate前需要先清理所有的静态文件，解决scss不编译的问题 nginx http转https https监听的是443端口，http监听的是80端口，所以我们需要监听80端口，然后将请求重定向到https的url 2019.6.4 周二 完善个人博客网站 弄清楚了分类、归档首页如何实现：归档有一级路由，分类没有一级路由（到时候需要添加hover实现多级路由的跳转）。 todo：弄清楚分类跳转的实现；完成分类和跳转的页面样式。 学习php语法基础 php有八种数据类型：boolean、string、integer、float、array、object、resource、null … 2019.6.5 周三 背6级单词 leetcode刷题：子集问题 todo：总结排列、组合、子集问题用到的算法和题解 看书：程序设计——抽象思维 2019.6.6 周四 看书：pro git，深入了解git 2019.6.8 周六 写博客，总结 排列组合子集问题的解决算法 深度优先搜索题解——Leetcode单词匹配 学习markdown中嵌入latex数学表达式 博客地址 学习git 总结三区四态的概念，以及对三区四态进行操作的基本命令 学linux命令行和脚本编程 2019.6.9 周日 读书：linux命令行和shell脚本 了解了文件/进程操作的基本命令 了解bash 读书：鸟哥的linux私房菜 了解的用户、群组权限 了解sudo，sudo可以让当前用户以其他用户的身份执行命令，需要在/etc/sudoers文件中添加，使用visudo命令添加 为hexo添加mathjax数学公式的支持 nginx服务器开启gzip压缩和配置缓存 了解hexo归档和分类界面的实现细节 在大类page中，使用page.posts可以拿到当前分类/归档下的所有文章 2019.6.10 周一 读书《鸟哥linux私房菜》，了解计算机硬盘的分区。 开始编写ucore操作系统，从预备知识看起，了解gcc，c语言内联汇编 2019.6.11 周二 less入门，看文档写博客 gcc编译器，看《c语言编程魔法书》，初步复习gcc编译器和c语言 2019.6.12 周三 操作系统开发基础知识，gcc编译器内联汇编 《鸟哥的linux私房菜》 2019.6.13 周四 leetcode算法 《深入浅处Vue.js》 2019.6.14 周五 《深入浅出Vue.js》 2019.6.15 周六 《深入浅出Vue.js》 《鸟哥的linux私房菜》 文件系统命令 文件权限，更改所有人、群组、权限 css框模型，表格框模型 2019.6.15 周日 css框模型，表格框模型完成 GNU make，makefile基本入门 ucore-os 安装qemu 调试源码 了解源码，builtin_va_list等gcc内置变量 todo makefile细节，如规则编写、变量等等 ucore-os lab1完成 了解gcc编译器，如内联汇编语句、内置变量 更多的css框模型，grid、multi-column、flex、-webkit-box、contents等等。","link":"/2020/06/14/daily-note/%E6%AF%8F%E6%97%A5%E6%89%93%E5%8D%A1/"},{"title":"图的基本概念","text":"图中最核心的概念是顶点和边，当我们的问题可以抽象为多个点以及这些点之间的相互联系时，我们就可以考虑用图来建模。每一个图中都包括一个顶点集合V和一个边集合E，用G=(V,E)来表示，E中的每一条边都是E中的一对顶点连接成的边。边的总数范围是$\\vert V \\vert^2 - \\vert V \\vert$。 术语图相关 稀疏图：边数较少的图 稠密图：边数较多的图 完全图：包含所有可能的边的图 有向图：图的边是有方向的，不同方向代表不同的边 无向图：图的边没有方向 带权图：图的边上有权重 子图：从图G中的V中选出一些顶点，E中选出一些边，构成的图是图G的子图 无环图：不带回路图 有向无环图（DAG）：不带回路的有向图 顶点相关： 相邻顶点：一条边连接的两个节点是相邻的，这两个顶点互称邻接点 自由树：不带回路的连通无向图。或者拥有$\\vert V\\vert -1$条边的连通图 路径相关： 路径：如果顶点序列$v_1,v_2,…,v_n$从$v_i$到$v_{i+1}$都有边，那么说顶点v1,…,vn构成一条路径。 简单路径：如果路径上的每一个顶点都不同，那么这个路径是简单路径 回路：如果一条路径将某个节点连接到其自身，并且路径长度大于等于3 简单回路：构成回路的路径是简单路径，除了首尾节点其他节点都相同的回路 连通图：从一个无向图中一个顶点到其他任意一个顶点都存在路径，则称此图为连通图 连通分量：无向图的最大连通子图称为连通分量 图的表示方法图有两种常用的表示方法。一种的相邻矩阵，另一种是邻接表。","link":"/2019/08/28/datastructure/%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"title":"docker swarm基础","text":"Docker的基础知识在另一系列文章中，。这一篇文章主要介绍docker swarm的基础知识，包括docker swarm的基础概念，如何使用docker swarm进行集群部署。 概览当前版本（19）的Docker包含了用于swarm集群的swarm模式，通过docker cli就可以创建一个swarm、发布部署到swarm、控制swarm的行为。 Swarm有如下亮点： 与docker engine集成的集群管理：通过docker cli就可以创建和控制集群 去中心化设计：通过docker engine了一在一台机器上部署任意类型的节点、manager或者workers。 声明式的服务模型：可以在docker中利用声明式的方式为应用程序配置多种不同的服务，例如前端和后端。 扩容：对于每一个服务，可以指定任意多个任务，swarm会根据配置自动添加或者减少任务 理想的状态调和：例如需要10份拷贝，但是有两份挂了，swarm会自动生成两份新的拷贝 多主机网络：对于服务可以指定一个覆盖网络，swarm会自动在启动或者更新的时候为网络中的容器分配地址 服务发现：swarm manager为每一个服务分配独特的dns名称以及负载均衡容器。通过swarm内嵌的dns服务器可以查询swarm中运行的任意一个容器 负载均衡 默认的安全策略：swarm中的每一个节点强制TLS相互认证和加密，可以使用本地的证书或者CA提供的证书 滚动更新：可以滚动更新节点，出错可以回滚 swarm mode的关键概念一个swarm由运行在swarm模式并且作为manager或worker的多个Docker主机组成，一个给定的Docker主机可以是manager、worker或者两者都是。 docker swarm join –token SWMTKN-1-02lxm9l0xnjvb6p8a0623gw4yd41ckh53mhs4kcupqiskk63ku-4l1u2h45oh77sbg6u85rr19am 106.12.110.215:2377 docker swarm的routing mesh策略docker swarm的routing mesh允许用户从集群上的任意一台机器上通过服务开放的端口来访问服务，这意味这swarm上的所有服务对外开放的端口应该是不同的，例如我想启动两个mysql服务，一个用于写，一个用于读，那么这两个服务的开放端口应该不一样，例如读使用3306，而写使用3307. 参考：https://docs.docker.com/engine/swarm/ingress/ 如果希望能够绕过routing mesh策略，例如两个mysql容器部署在两台机器上，想直接通过ip和端口直接定位到具体的mysql服务器，而不通过docker的routing mesh策略，那么需要将mysql容器的service的端口设置成host模式。如下：1docker service create --name mysql-writer -e MYSQL_ROOT_PASSWORD=B123. --publish published=3307,target=3306,mode=host --mode global --config source=my-writer.cnf,target=/etc/mysql/my.cnf mysql:5.7 docker service的配置信息当我们使用一个mysql容器的时候，有时候需要修改配置文件。但是mysql容器并没有提供vim、vi等文本编辑工具、也没有yum等命令，不能直接修改配置文件。如果直接使用docker cp从主机拷贝配置文件到容器，需要重启服务，重启mysql后容器也会重启，镜像的配置又会覆盖调docker cp的配置文件，简单来说就是这种方式也行不同。 如果是在单独的容器中使用，可以在docker run的时候使用-v参数挂载配置文件目录到指定的配置文件目录下，这样可以自定义配置文件并生效。 但是如果在swarm的service中，上述方式又行不通了，因为swarm的service是由manager启动的，并不能提供挂载的能力。那应该怎么办呢？幸好service提供了能够自定义配置文件的能力，参考Store configuration data using Docker Configs。通过docker config创建配置文件，然后在service启动的时候通过--config参数将配置传给指定的容器。 限制service的分配如果相让service在指定的node上执行，需要进行两部操作： 为节点分配label，例如docker node update --label-add bar=baz node-1 service create的时候添加--constraint node.labels.{name}选项 创建私有的registry并在docker上运行资料：https://docs.docker.com/registry/deploying/","link":"/2020/03/26/docker/docker-swarm%E5%9F%BA%E7%A1%80/"},{"title":"在centos上搭建git服务器仓库","text":"在centos上搭建git服务器仓库git的官方文档，这里有git命令，git服务器，git配置，git管理等一系列的说明都有。 1. 安装git首先查看有没有安装git，输入： git –version 如果没有显示“git is not a command”，则说明已经安装了git，跳过此步。 如果没有安装git，则需要安装git： yum install git 如果觉得这样安装的git版本太低，可以再查一下如何升级git。 2. 添加git用户/组 groupadd git useradd git -g git 3. 创建git访问权限文件git需要在/home/git/.ssh目录下创建authorized-keys文件来管理允许访问的客户端，并配置相关的权限： cd /home/git mkdir .ssh touch .ssh/authorized-keys chmod 700 .ssh chmod 600 .ssh/authorized-keys authorized-keys用来存放允许连接的客户端的公钥，也就是说如果你想某一个客户端可以在这个仓库上pull或者push，需要将客户端的公钥复制到authorized-keys中，每一个公钥占单独的一行。 4. 创建git仓库假定git仓库都放在/data/gitrepo目录下： mkdir /data/gitrepo cd /data/gitrepo git init –bare test.git chown -R git:git test.git 到这里我们就已经完成了创建服务器端的git仓库，如果我们要从这个仓库拉代码下来，使用： git clone git@ip地址/网址:/data/gitrepo/test.git 5. 实现免密pull或者push这时候我们可能发现git pull或者push的时候仍然需要输入服务器的密码。如何才能实现免密传输呢？这里先给一个解决方案，如果不行可以搜索“如何免密ssh登陆？”。 5.1 更改ssh配置首先更改sshd的配置，这里可以配置服务器的远程登陆方式，可以有密码，公钥等的登陆方式。输入： sudo vim /etc/ssh/sshd_config 然后更改下列配置： StrictModes no RSAAuthentication yes PubkeyAuthentication yes AuthorizedKeysFile .ssh/authorized-keys 然后重启： service sshd restart 5.2 将客户端的公钥添加到git服务器的authorized-keys文件中有两种方式 使用ssh-copy-id ssh-copy-id -i ~/.ssh/id_rsa.pub git@你的域名或者ip地址 直接将你的客户端的公钥添加到authorized_keys文件中 6. 代码自动部署在服务器上clone另一个仓库： git clone git@localhost:/data/gitrepo/brightblog.git 编写post-receive shell脚本，需要为脚本文件赋予执行权限：12345cd 服务器clone的仓库目录unset GIT_DIRgit pull origin masterhexo cleanhexo generate上面的shell脚本做的事情是：进入目录=》重值GIT_DIR=》获取最新代码=》清空public=》生成静态文件","link":"/2020/06/14/git/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93/"},{"title":"centos7 下升级git","text":"安装所需要的依赖包12yum install curl-devel expat-devel gettext-devel openssl-devel zlib-devel yum install gcc perl-ExtUtils-MakeMaker 删除已有的git1yum remove -y git* 下载安装123456789cd /usr/srcwget https://www.kernel.org/pub/software/scm/git/git-2.7.3.tar.gz tar xzf git-2.7.3.tar.gzcd git-2.7.3make prefix=/usr/local/git allmake prefix=/usr/local/git install# 创建软连接cd /usr/binln -s /usr/local/git/bin/git git 安装gitflow1wget --no-check-certificate -q -O - https://github.com/nvie/gitflow/raw/develop/contrib/gitflow-installer.sh | sudo sh I recommend you to install a script to autocomplete the git-flow commands and params:1234mkdir -p ~/src/external &amp;&amp; cd ~/src/externalgit clone https://github.com/bobthecow/git-flow-completion.git git-flow-completionmkdir -p ~/bin/ &amp;&amp; cd ~/binln -s ~/src/external/git-flow-completion/git-flow-completion.bash ./git-flow-completion.bashThen add a simple command in your .bashrc file:1source ~/bin/git-flow-completion.bash 检查版本git --version，如果输出的版本号是2.7.3说明安装成功","link":"/2019/11/11/git/centos7-%E4%B8%8B%E5%8D%87%E7%BA%A7git/"},{"title":"docker基础","text":"常见问题最后一节收录了docker在开发，运行，部署中的常见问题。 解决镜像下载慢的问题默认是使用国外的源，所以可能会出现提示找不到服务器或者下载很慢的问题，该问题可以通过将源配置成国内的镜像来解决。步骤如下： 修改docker的配置，进入/etc/docker，找到daemon.json文件，如果没有则新建，有则修改。 在daemon.json中添加以下内容：123{ &quot;registry-mirrors&quot;: [&quot;https://registry.docker-cn.com&quot;,&quot;http://hub-mirror.c.163.com&quot;]} 保存，重启docker服务 解决启动warm服务时出现verify: Detected task failure的问题出现这个可能是容器启动失败，容器启动失败后会自动重启，所以一直停留在这个界面。容器启动失败的原因可以通过日志查看。 例如：启动mysql服务器后，出现verify: Detected task failure。此时查看日志docker service logs mysql-reader -f，得到输出12345mysql-reader.1.k005669t522s@instance-3h97b0st | 2020-03-27 00:20:11+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.29-1debian10 started.mysql-reader.1.k005669t522s@instance-3h97b0st | 2020-03-27 00:20:11+00:00 [Note] [Entrypoint]: Switching to dedicated user 'mysql'mysql-reader.1.k005669t522s@instance-3h97b0st | 2020-03-27 00:20:11+00:00 [Note] [Entrypoint]: Entrypoint script for MySQL Server 5.7.29-1debian10 started.mysql-reader.1.k005669t522s@instance-3h97b0st | 2020-03-27 00:20:11+00:00 [ERROR] [Entrypoint]: Database is uninitialized and password option is not specifiedmysql-reader.1.k005669t522s@instance-3h97b0st | You need to specify one of MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD看到了提示，需要明确MYSQL_ROOT_PASSWORD, MYSQL_ALLOW_EMPTY_PASSWORD and MYSQL_RANDOM_ROOT_PASSWORD着三个环境变量中的任何一个。所以解决方案是，启动的时候设置环境变量，如下： 添加-e参数：docker service create --name mysql-reader --replicas 1 -e MYSQL_ROOT_PASSWORD=Abc123456! --constraint node.labels.name==baiduyun mysql:5.7。 redis自定义配置文件的问题通过docker config新增配置文件，通过service，加载配置文件然后启动，注意，这里启动失败可能是配置文件有问题。","link":"/2020/03/26/docker/docker%E5%9F%BA%E7%A1%80/"},{"title":"git命令tips","text":"下面对一些常用的git命令/特性做一些总结 分支管理相关新建分支git checkout -b [branchname]：该命令是下面两条命令的简写：12git branch [branchname]git checkout [branchname]如果只是新建分支而不切换过去，使用git branch [branchname] 删除分支git branch -d [branchname]，如果有未提交的修改，-d选项会失败，如果要强制删除，使用-D选项 切换分支git checkout [branchname] 合并分支git merge [branchname] 该命令会将[branchname]合并到当前所在的分支。合并的方式有好几种，一种是快进（fast-forward），当前分支是合并的分支的上游的时候采用这种形式，如下：123 master hotfix \\ \\---commit1----commit2----commit3当hotfix合并到master时，就会采用fast-forward方式进行合并。 还有一种方式是三方合并，当前分支和被合并的分支在某一个记录后分岔，如下：1234567891011121314151617 master \\----commit1----commit2----commit3 \\ commit4----commit5 \\ hotfix || \\/合并后 old-master master \\ \\----commit1----commit2----commit3--------commit6 \\ / commit4----commit5----- \\ hotfix合并时会先找到最近的共同父节点，然后进行合并，合并之后会有一个合并提交（commit6），该提交有两个父提交。 分支合并时的冲突解决在不同提交中对同一个文件的同一个部分进行了修改，合并时就会产生冲突。git会自动将有冲突的部分都保留，并用特殊的标记记录冲突的位置（HEAD&lt;=====）。 git遇到冲突会停下来，有冲突的文件的状态是unmerged。我们需要手动修改冲突文件，解决掉冲突，然后再执行git add和git commit来将合并进行手动提交。 git diffgit diff命令比较的是工作目录中当前文件和暂存区域快照之间的差异，也就是修改之后还没有暂存起来的变化。 也就是说，在git add .之后，我们再运行git diff，没有任何结果。如果我们希望比较暂存区和某一次commit，使用–cached选项 git remote git remote -v，查看当前项目的所有远程git仓库。 git remote add \\&lt;shortname> \\&lt;url>，添加远程仓库。shortname是对远程仓库的简写，例如设置成origin，当使用origin的时候，指向的就是对应的url，对应的仓库。 git fetch [remote-name]，从任意远程仓库拉取，会合并到本地仓库中，不会修改工作区里面的内容。同时会更新远程仓库的引用。如果要从服务器拉取一个新的分支下来，使用git fetch而不是git pull，因为git pull不仅会拉取分支，而且会自动merge到当前分支。除非我们明确拉取的同时进行合并，否则一律使用git fetch。 远程分支相关 git fetch [remote-name]，会设置远程分支 git pull会试图从远程分支拉取代码，并合并到当前分支 git checkout –track origin/name会试图切换到name分支，并将origin/name作为其远程分支。也可以使用git checkout -b myname origin/name，这会在本地新建一个myname分支，并将origin/name作为其远程分支。 git branch -u orgin/name [branchname]或者git branch –set-upstream-to=origin/name [branchname]，若branchname为空，则默认为当前分支。 git push origin localbranch:serverbranch，将本地的localbranch分支推送到远程的serverbranch分支，如果远程没有serverbranch分支，会自动在远程新建一个。使用-d选项可以删除远程分支。 服务器上的git协议git可以使用4种主要的协议来传输资料：本地协议、HTTP协议、SSH协议及git协议： 本地协议就是直接访问文件系统，大家在一个共享的文件系统中工作 HTTP协议有智能HTTP协议和哑HTTP协议，智能HTTP协议运行在标准的HTTP/S端口上并且可以使用各种HTTP验证机制，用一个URL就能包含授权、加密解密等功能。哑HTTP协议就是一个HTTPweb服务，web服务器将git仓库当作普通文件来处理，设置git自带的post-update钩子就能正常工作。 SSH协议：架设Git服务器的时候常用SSH协议作为传输协议。SSH是一个验证授权的网络协议。可以使用ssh协议的url：git clone ssh://user@server/project.git，也可以使用git clone user@server:project.git（平时看到的git@github.com:test.git）就是这么来的。 git协议：监听一个特定的端口（9418），类似于SSH服务。但是没有授权机制，一旦开发推送，所有人都可以向项目推送数据。 在服务器上搭建git 在开始假设Git服务器前，需要把现有仓库导出为裸仓库——即一个不包含当前工作目录的仓库。裸仓库是不包含工作区的，只有.git文件夹 git init –bare [directory] 把裸仓库放到服务器上，通过ssh可以访问。可以有多用户推送同一个仓库，只要用户对于git所在的目录有可写的权限。 只要能通过ssh链接到服务器，并且就能拉取仓库；如果ssh登陆的账户还有写权限，那么就可以向仓库推送。","link":"/2019/07/18/git/git%E5%91%BD%E4%BB%A4tips/"},{"title":"深入git生命周期","text":"深入git生命周期这篇文章适用于了解git基本的命令，会使用git add，git commit，git pull，git push进行版本管理，希望能深入了解git的版本控制细节的开发者。如果还没有掌握基础，请参考git基础。 这篇文章包括git中的文件状态，工作区，暂存区等的概念，以及深入版本回退。你会了解到git add,git commit在git中代表着什么，了解git reset、git checkout如何工作。 了解这些细节一定能够帮助我们在工作中对项目的版本控制更加如鱼得水。 核心概念git中有两个核心概念：1、三区：工作区、暂存区、git仓库；2、四态：未追踪（untracked）、未更改（unmodified）、已更改（modified）、暂存（staged）。其中工作区就是你的当前项目文件夹，工作区中的文件在git中可能是上面四种状态。使用git add命令添加的文件会被添加到暂存区中。git commit会将暂存区中的文件添加到git仓库中。 所以我们可以这样理解： 三区是物理磁盘上的概念，工作区、暂存区、git仓库在git项目目录下都对应着不同的文件/文件夹，通过工作区的代码通过add可以改变暂存区中的文件，暂存区通过commit可以修改git仓库中的文件，git仓库通过版本回退等也可以改变工作区的文件，三个目录可以相互影响。 而我们项目管理的文件有上面四种状态，通过git命令可以改变我们管理的文件的状态。 所以三区其实是四态的物理体现。当使用git add [file]时，file的状态变为暂存，此时暂存区的文件会被修改，暂存的状态保存在暂存区的文件中。 接下来对git中的这几种状态进行深入的学习和实践，希望能够深入理解git中原理。能够深入git的版本控制，包括分支（branch）、提交（commit）、重置（reset）等的原理和流程，在工作中能够更加深入地控制项目的版本。 三区的状态转移图： 四态的状态转移图： 接下来我们详细分析在git中的状态转移的命令和细节。下面的内容对照着这张图可以更好的理解 基本的git流程细节从新建git仓库开始在一个文件夹下使用git init可以将在该文件夹下创建一个git仓库（使用–bare选项新建一个空的仓库，该仓库不带工作区和暂存区，也就是看不见源代码，用于git服务器）。新建的git仓库没有任何的提交记录。 然后我们在目录下创建文件，比如README.md，使用git status（git status查看当前工作目录下文件的状态），这时README.md的状态是未追踪（untracked）。 添加到暂存区使用git add README.md将README.md添加到暂存区中，这时使用git status查看状态，README.md的状态是staged。 这时候如果我们修改README.md呢？如图： 修改README.md后，我们发现文件状态有两种，怎么回事呢？其实当前文件的状态是modified。暂存区中的是我们刚刚add时的文件的快照。暂存区中的文件等待commit。如果希望保留新修改的内容，需要再次add，将最新的文件添加到暂存区。 commit到git仓库commit的时候是从暂存区取的，如果不太明白请看看文章开头所说的三区和四态的概念。 执行git commit过后处于暂存区的文件的状态会变成unmodified。 接着上面的问题，如果add了之后没有commit，又修改了，这时commit会发生什么？commit后执行git status如下图： 暂存区中已经被提交了，但是未暂存的没有提交到git仓库中，仍然为修改或者未跟踪。那为什么commit过后，仍然会保留“修改”、“未跟踪”这些信息呢？commit的是暂存区中的文件，是否修改或者是否跟踪是根据git仓库中的文件版本和当前工作区中的文件版本来确定的。 实际上每一个文件都是相互独立的，可以独立add，commit，互不干扰。这种特性有什么用呢？比如我现在在一个项目中有很多个需求在同时做，做了一个需求，但是另一个改了还没做完，这时候是一起add了commit还是只commit做完了的需求呢？当然是只commit做完了需求了，不然下一次怎么知道上一次改了那些文件，改了什么，做到那儿了呢？当然可以自己记下来，但是如果有多个项目，每个项目又有好几个需求呢？ 撤销追踪、修改、暂存以及重命名接下来问题又来了，我想撤销追踪、修改和暂存怎么办呢？提示：对应的指令的参数细节可以使用git 命令 -h/–help来查看，-h是简略版，–help是详细版。例： git checkout -h/–help 撤销追踪使用git rm命令可以撤销追踪，但是要注意，git rm默认不仅会撤销追踪，还会从磁盘中删除这个文件，如果不想删除文件，可以使用–cached选项。 git rm –cached 撤销修改使用git checkout [file]可以撤销对文件的修改，回到上一次commit时的状态，即状态图中的unmodified状态。git checkout不仅会修改更新索引（暂存区），还会覆盖工作目录中对应的文件。 git checkout README.md 撤销暂存使用git reset命令可以撤销暂存，原理是将HEAD移动到指定commit记录（默认是HEAD），然后用这一次记录重置暂存区。git reset –soft：仅修改head的指向；–mixed：修改head的指向，并更新暂存区（默认）；–hard：修改head的指向、暂存区和工作目录。 git reset默认只会修改HEAD和暂存区，不会修改工作区中的内容，如果要替换工作区中的内容，使用–hard选项。 git reset [commit] commit可以通过git log得到，commit后面的hash就是: 重命名/移动工作目录下的文件如果我们直接修改工作目录中的文件名，那么在git中的状态是删除了一个文件又新增了一个文件。git提供了命令来执行类似的操作： git mv path1 path2 如果path1=path2，则为重命名。修改会被直接保存到暂存区中。 版本控制上面所列举的所有操作可以用下面的这一张图来概括：","link":"/2019/06/08/git/%E6%B7%B1%E5%85%A5git%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"},{"title":"hexo中使用mathjax","text":"网上给的很多使用hexo插件或者修改各种配置的教程都太过繁琐，而且在我这里不管用，所以我自己上mathjax的官网看了以下，直接使用mathjax，不搞那么多花里胡哨的东西。当然这里方式是通过dom动态实现的，以后我会尝试写个插件在服务器上处理。 当然如果你只是想要在hexo中加入mathjax，而网上找了很多方法都没用，那么这篇文章一定很适合你！ 整个教程仅仅只有两步：1.下载mathjax，或者直接使用第三方的cdn；2.将mathjax的script标签添加到ejs文件中。 获取mathjax接下来讨论获取mathjax的两种方式： 直接下载源文件上mathjax的官网，找到archive，然后在找到current version，点击下载。 下载解压完成后，文件夹中就已经包含了我们所要的全部信息。如何使用我们稍后再说。 使用cdn1234&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt; 添加mathjax支持使用源文件方式使用源文件方式的好处是，对应的静态资源可以放在我们自己的服务器上。 我要要做的仅仅是，将源文件解压后的所有文件拷贝到静态资源服务器下。在hexo中，我们可以放到themes/[你使用的主题]/source/js目录下，然后在ejs文件中，比如layout.ejs，加入下面的代码: 12345678&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config({ extensions: [\"tex2jax.js\"], jax: [\"input/TeX\",\"output/HTML-CSS\"], tex2jax: {inlineMath: [[\"$\",\"$\"],[\"\\\\(\",\"\\\\)\"]]} }); &lt;/script&gt; &lt;%- js(\"js/MathJax\") %&gt; 也可以直接把这一段代码直接考到你需要的markdown文件中，但是这样每一个md都需要手动添加，比较麻烦。 使用cdn方式使用cdn就更容易了，直接把下面的代码粘贴到layouy.ejs中就可以直接使用了： 1234&lt;script type=\"text/javascript\" src=\"https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.4/latest.js?config=TeX-MML-AM_CHTML\"&gt;&lt;/script&gt;&lt;script type=\"text/x-mathjax-config\"&gt; MathJax.Hub.Config({tex2jax: {inlineMath: [['$','$'], ['\\\\(','\\\\)']]}});&lt;/script&gt;","link":"/2019/06/09/hexo/hexo%E4%B8%AD%E4%BD%BF%E7%94%A8mathjax/"},{"title":"基于Hexo搭建自定义博客网站","text":"这篇博客主要内容是如何基于Hexo搭建自定义的静态博客网站，我们将从网站布局设计、实现、部署等各个方面来详细介绍，如何实现自己的个人主页和博客。 基本结构网站目前暂定包含两个部分：个人主页和博客。 个人主页：主要内容是个人简介，学习经历，项目经历，项目介绍，技术路线等的说明。类似于个人简历，但是效果更加的炫酷。要有明显的链接到博客和github的入口。 博客系统：主要内容是个人学习的总结，笔记，技术分享等，需要要有归档和分类功能，分类要能够细分。拥有完整的博客内容导航功能。 自定义主题","link":"/2020/06/14/hexo/%E5%9F%BA%E4%BA%8EHexo%E6%90%AD%E5%BB%BA%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8D%9A%E5%AE%A2%E7%BD%91%E7%AB%99/"},{"title":"DOM：基础","text":"这篇文章主要介绍dom的基础知识，基于最新的DOM标准，和历史dom标准：DOM 4/3/2/1，包括dom的层级结构、dom事件、dom的遍历、dom层级中的接口和API等。 dom简介dom是Document Object Model的简写，就是xml或者html这种树形结构的文档以一种层级对象的形式表现出来。 例如：12345678&lt;html&gt; &lt;head&gt; &lt;title&gt;hello world&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;p&gt;welcome to the frontend world!&lt;/p&gt; &lt;/body&gt;&lt;/html&gt;用dom表示就是：123456789 Document | html / \\head:HTMLHeadElement HTMLBodyElement / \\ title:HTMLTileElement p:HTMLPElement / \\ &quot;...&quot;:TextNode &quot;...&quot;:TextNode这里我们注意到有Document、Element、Node等等一系列接口，接下来我们终点关注接口的继承关系和接口中重要的API。 WHATWG和W3C我们观察到DOM标准来自两个官网：WHATWG和W3C，那么WHATWG和W3C上的内容有什么区别呢？接下来我们从下面几个方向来取WHATWG和W3C做一个比较 WHATWG和W3C的组成WHATWG的全称是The Web Hypertext Application Technology Working Group(web超文本应用技术工作组)，WHATWG是一个由对web标准和测试的人组成的社区。由Apple、Mozilla、Opera在2004年创建。 W3C的全称是The World Wide Web Consortium，由W3C会员、员工和社区共同贡献。 WHATWG和W3C标准WHATWG和W3C是两个不同的标准组织，都致力于web标准的开发。但是WHATWG主要工作内容是HTML、HTML API、encode、DOM这些，与html文档内容及其操作相关，不包括css等。W3C的工作内容涉及到web的方方面面，web性能、css、可访问性等等。 WHATWG中的标准叫living stardard，表示不断维护的html标准，其内容浓缩了多个历史W3C标准以及最新的标准。 W3C标准按照版本号来区分标准版本，每一个历史标准都有版本号。 总结WAHTWG主要是由浏览器厂商发起的标准工作组，主要工作内容是HTML文档方向标准的开发。 W3C是由W3C会员和世界各地的社区成员、学术组织工作维护的web标准，其标准内容涉及到web的方方面面。 DOM标准的历史这里的DOM标准主要基于W3C DOM标准 DOM中的空白和回车的处理在DOM中，回车和空白都会被解析成文本节点。例如，一些文本序列是这样的：12&lt;!DOCTYPE html&gt;&lt;html&gt;\\n\\t&lt;head&gt;\\n\\t\\t&lt;title&gt;空白测试&lt;/title&gt;\\n&lt;/head&gt;\\n&lt;/html&gt;会被处理成如下的结构，请看DOM结构在线演示:12345678-Doctype-HTML--HEAD---:text---TITLE----空白测试---:text----我们可以知道html源文档中的空白和换行，在DOM中都会变成文本节点。在块级元素之间，这些文档节点在显示上没有区别，只是我们用Node的遍历API遍历时，会取到Text节点。 行内元素源文档之间的空白和换行和被合并成一个空格，这也是我们在使用inline-block时会出现额外的空格的原因。解决方案一个是设置父元素的font-size=0，子元素为正常的font-size；另一个是压缩文档去掉标签之间的空格。第二个种方法是解决这个问题的最佳反感，尤其是在生产环境下，可以借助各种工程化工具来压缩html文档去掉额外的空格 DOM中的继承继承在DOM中是非常重要的，每一个DOM对象都有其实现的接口，该接口可能继承了其他的接口，这些接口中定义的API和属性可以操纵和控制DOM元素。 我们这一节的主要目的是弄清楚DOM的继承关系，以及继承链上有哪些接口，这些接口有些什么属性和方法。 继承链下面我们以a标签为例，弄清楚其继承链，包括继承链上接口信息：1EventTarget----&gt;Node----&gt;Element----&gt;HTMLElement----&gt;HTMLAnchorElement我们可以看到a标签的DOM实例是HTMLAnchorElement的实现，其继承链上有HTMLElement、Element、Node、EventTarget，我们只要知道了其实例和继承的接口上有哪些实例和方法，就知道了该如何操作该DOM对象。 EventTarget接口EventTarget接口提供了监听和触发事件的方法，能够监听事件的接口比如Element、Document、XMLHttpRequest等等。 接口中只提供了以下方法： addEventListener(type, listener, [useCapture/options])：useCapture该函数一个useCapture从ie9+开始开始支持（默认是false，即冒泡阶段调用），options底版本浏览器不支持，options是一个对象，参数属性如下： capture：布尔值，true表示捕获，默认是false once：布尔值，true表示只执行一次，默认是false passive：布尔值，true表示监听器永远不会调用preventDefault()，默认是false this的处理：事件处理函数的this指向当前的EventTarget（哪个元素绑定的事件就指向哪一个元素）。箭头函数没有自己的this。如果使用bind绑定this，那么获取到的this就是bind绑定的this（只有new绑定的this优先级比bind高）。关于addEventListener的详细请看EventTarget.addEventListener removeEventListener dispatchEvent Node接口我们先看Node接口，其属性和方法如下。 先来属性： nodeType：节点类型，可能的值是1-12，对应关系如下： 1：Node.ELEMENT_NODE，元素比如&lt;p&gt;、&lt;div&gt; 3：Node.TEXT_NODE，文本节点，是Element或Attribute的子节点 4：Node.CDATA_SECTION_NODE，例如&lt;!CDATA[[ … ]]&gt; 7：Node.PROCESSING_INSTRUCTION_NODE，XML文档的ProcessingInstruction，例如&lt;?xml-stylesheet ...?&gt; 8：Node.COMMENT_NODE 9：Node.DOCUMENT 10：Node.DOCUMENT_TYPE，例如&lt;!DOCTYPE html&gt; 11：Node.DOCUMENT_FRAGMENT_NODE 最新的标准中就这些，其他还有ENTITY、NOTATION等都已经在DOM4中被废除了，ATTRIBUTE没有被废除但是不属于Node了。具体需要的时候查MDN nodeName：节点名称，对于不同的节点类型会返回不同的值 Element.nodeName：返回元素的名称，大写 Attr.nodeName：属性的名称，小写 Text.nodeName：返回#text CDATASection.nodeName：返回#cdata-section ProcessingInstruction.nodeName：目标的名称 Comment.nodeName：#comment Document.nodeName：#document，例如document.nodeName的值就是”#document” DocumentType.nodeName：文档的类型，例如html，document会有两个子节点，一个是doctyoe，另一个是html根结点。取document.documentElement取到的就是html根结点 DocumentFragment.nodeName：返回#document fragment nodeValue：从字面意思上看，nodeValue就是Node的值，但是事实上，nodeValue只对少量的DOM对象有效，主要是值是文本的节点，其他的均返回null Attr.nodeValue，字符串形式的属性值 Text.nodeValue，字符串形式的节点内容 CDATASection.nodeValue，字符串形式的节点内容 ProcessingInstruction.nodeValue，同上 Comment.nodeValue，字符串形式的注释文本 其他的都返回null parentNode：引用父节点 childNodes：引用子节点，返回的是NodeList对象，这是一个类似于数组的对象，内容是Node列表，可能包含Element、Text、Comment等 firstChild lastChild previouSibling，如果是同辈第一个节点，那么值为null nextSibling，如果是同辈最后一个节点，那么值为null ownerDocument：引用document/window.document textContent：文本，textContent的值取决于以下情况： 如果node是document、DOCTYPE或者notation(xml)，返回null 如果node是CDATA、COMMENT、TEXT，textContent返回节点的值（文本） 对于其他的类型，返回每一个子节点的textContent，不包括comment和processing instruction。如果没有子节点也没有内容，返回空字符串 再来方法： parent.appendChild(child)：将child插入到parent的最后面。如果child是一个对DOM中元素的引用，那么会将其移动到新的位置。如果需要克隆，而不是移动，需要使用cloneNode先克隆节点，然后再使用appendChild cloneNode([deep])：复制一个节点，可选参数deep是一个布尔值，当deep=true的时候，会复制其所有子节点，默认为false。cloneNode会复制所有的属性和内联的事件处理器。但是不会复制addEventListener挂载的事件处理器，也不会复制后来添加的事件处理器（例如：dom.onclick=）。canvas绘制的图像也不会被复制。被复制的节点游离于dom外 node1.compareDocumentPosition(node2)：比较两个节点的位置关系。IE9+。 node1.contains(node2)：判断一个节点是不是另一个节点的子节点。IE9+。 node.hasChildNodes() parent.insertBefore(newNode, referenceNode)，再parent下插入到参考节点的前面。如果是对文档中已有的节点进行操作那么是移动。如果需要复制使用cloneNode(true)。如果refNode是null，插入到最后面 node.isEqualNode(otherNode) node.normalise()：将node的子树格式化，格式化的子树中没有空的文本节点以及没有相邻的文本节点。 parent.removeChild(child) parent.replaceChild(newChild, oldChild) textContent和innerText的区别 textContent获取所有的文本内容，包括style和script标签,但是innerText只返回人类可读的内容 textContent获取每一个节点的文本内容，包括隐藏的元素。innerText获取使用的css以后的文本，innerText会触发回流 使用textContent只会当作文本处理，不会有xss攻击的可能 参考资料 DOM Living Standard W3C DOM 《Javascript DOM高级程序设计》","link":"/2019/09/22/html/DOM%EF%BC%9A%E5%9F%BA%E7%A1%80/"},{"title":"html tips","text":"这篇文章的主要内容是记录开发中遇到的一些html小知识。 textContent和innerTEXT的区别 textContenttextContent的值取决于以下情况： 如果节点是documnet、DOCTYPE或者notation，textContent返回null 如果是CDATA Section、注释、处理指令或者text node，返回节点内部的文本 其他节点返回所有子节点的textContent的字符串拼接 设置textContent会移除所有的子节点并用文本替换他们。 innerTEXTinnerTEXT表示节点和其后代的渲染过的文本内容。只会返回用户可以看到的文本内容，例如script、style以及hidden的元素不会返回内容。 textContent和innerTEXT的区别如下： textContent获取所有的内容，包括不可见的元素。innerTEXT只获取可见的内容。 textContent遇到br、div等元素不会添加换行，innerTEXT会自动添加换行","link":"/2019/09/08/html/html-tips/"},{"title":"html5新标签&#x2F;属性总结","text":"结构型的标签html5新增了很多结构型的标签，这些标签没有默认样式，只设置了display:block，是块级元素，其作用主要是语义化，标签名就指示了这个标签所起的作用（除此之外，id、class都可以起到类似的作用，只要能反映标签的作用）。 主要的结构标签有：header、footer、section、article、aside、main、hgroup、figure、figurecation 结构化标签的作用： article：表示文档，一般有自己的头部、内容等，例如一篇博客文章，可以与header、footer等结合使用 section：用于分块，每一个分块一般有自己的标题，article强调独立性、section强调分块 不要将section用作设置样式的页面容器，那是div的工作 如果article、aside、nav更符合使用条件，不要使用section元素 不要为没有标题的内容区块使用section元素 nav：导航，页面的导航或者文档的导航 aside：页面或者文章的附属信息默认有margin的元素p、ul、figure、body、ol，menu，dir，dd 默认有padding的元素ul、ol，menu，dir，button 默认有background的元素mark 全局属性全局属性是指在任何标签上都能使用的属性。这里所指的任何标签是任何支持该属性的标签，有些全局属性被所有的标签支持，例如id、class等，有些只能被部分支持，例如contenteditable。 contenteditable将元素的contenteditable属性置为true，会让该元素变成可编辑的，聚焦到该标签上时，可以编辑该标签内的内容。编辑会直接修改元素的文本，暂时没有相关的API，只能通过innerHTML/textContent获取元素的内容。回车会创建新的被编辑的元素，li会创建新的li，section会创建新的section。 hidden所有元素都允许使用hidden属性。该属性类似于input元素中的hidden元素。功能是通知浏览器不渲染该元素（元素为渲染前获取不到元素所处的位置），使元素处于不可见的状态，但是内容还是由浏览器创建，之后可以通过脚本取消。 tabindextabindex决定了一个元素能不能获取焦点，以及是否参与到线性的键盘导航中（使用tab键进行切换） tabindex接受整数作为它的值： -1，取值-1表示该元素可以被focus，但是不能被tab聚焦（元素可以使用focus()聚焦） 0，取值0表示tab顺序按照文档的顺序，是DOM的顺序，和元素显示的位置无关 正整数如1、2、3，tab会先切换到小的，再切换到大的，值一样的按照dom的顺序切换","link":"/2019/07/22/html/html5%E6%96%B0%E6%A0%87%E7%AD%BE-%E5%B1%9E%E6%80%A7%E6%80%BB%E7%BB%93/"},{"title":"html5 API","text":"在HTML5中，提供了很多的api，例如访问文件的File API，通过使用这个api，从web页面上访问本地文件系统会变得十分简单。还有websocket、localStorage、canvas、跨文档消息传递（postMessage）、web workers、地理位置等。近期新增的还有fetch api，steam api，TypeArray，ArrayBuffer，WebGL等等。 这篇文章尽量对这些api做一个介绍和总结，如果内容太多会外链到其他的博客中。 FileList对象和File对象浏览器中获取本地文件的唯一方法是使用input:file或者拖放API，浏览器由于安全问题，不能直接访问本地文件系统。 通过input:file的DOM对象的files属性能够拿到当前选中文件列表（FileList对象），FileList对象的每一个属性（0、1…）值都是一个File对象，File继承自Blob对象，File对象中有文件的大小、名字、修改时间（lastModified）等等的信息。 input:file可以指定accept属性，指定可以接受的文件类型。 Blob对象Blob表示不变的二进制原始数组，它提供了一个slice方法，可以通过该方法访问到原始数据块。file对象也继承了这个Blob对象。 属性： size，blob包含的数据的字节数 type，blob包含的数据的mime类型 方法： slice(start,[end])，返回一个截取特定长度的Blob对象 stream()，将Blob转成一个ReadableSteam text()，将Blob转成一个stream并且完整的读取它，返回一个值为text的promise arrayBuffer()，将Blob转成一个stream并完整的读取它，返回一个值为arraybuffer的promise 使用实例：1234567891011let obj = { hello: 'world'};let blob = new Blob([JSON.stringify(obj, null, 2)], { type: 'application/json'})let blobReader = new FileReader();blobReader.readAsText(blob);blobReader.onload = function() { console.log(this.result)}Blob构造函数一共接收两个参数，第一个参数是一个数组，数组的内容可以是ArrayBuffer、ArrayBufferView、Blob、USVString，或者这些对象的任意混合。USVString会按照UTF-8处理。第二个参数是一个选项对象： type：Blob的MIME类型，默认是空字符串 ending（非标准）：内容的换行字符（\\n) Blob还能和createObjectURL一起使用，将typearray转成url对象。和FileReader结合使用可以以不同的形式读取Blob内部的内容。 FileReader接口FileReader主要用来把文件读入内存。 FileReader的主要api有： readAsBinaryString(file) readAsDataURL(file) readAsText(file) readAsArrayBuffer(file) abort() 文件读取的结果都存在FileReader实例化后的对象中，主要属性有： result readyState 监听FileReader对象事件，可以知道FileReader当前的读取状态，主要事件有： onabort onerror onloadstart onprogress onload onloadend 事件参数都是Event对象，注意：读取的数据不在Event对象中，在FileReader对象中，我们在回调函数中可以通过this.result拿到读取的结果或者通过reader.result 参考资料 MDN Blob Web WorkerWeb Worker是浏览器提供了一个多线程计算能力，能够打破js单线程的限制，开启新的线程用于计算。这里对Web Worker的创建，使用，消息通信和使用做一个介绍，并介绍如何在vue中使用worker来进行并行计算。最后给出一个实例：在vue中使用worker来进行markdown的编译，然后将编译后的结果渲染到视图中。 提示：浏览器还支持其他的多线程API，例如Service Worker、Shared Worker等等，线程间的通信使用消息机制，例如Channel messaging、BroadCast channel、web RTC等等，具体请看[浏览器的多线程支持和消息传递](#) 创建Web Worker创建Web Worker的方式是使用Worker构造函数new一个实例出来：1const worker = new Worker('myscript.js')Worker构造函数接收两个参数，第一个是url，表示worker中执行的脚本的url，必须遵循同源策略，也就是脚本所在的URL必须和文档是同一种协议、域名、端口（这里的url可以使用绝对、相对、对象URL、完整url，如果是在worker中创建Worker，相对url参照的是当前worker路径而不是文档）。第二个参数是一个可选的选项对象： type：创建的worker的类型，可以是classic或者module，默认classic credentials：值可以是omit、same-origin、include。默认omit name：worker的独立上下文的名字 worker可能会抛出以下异常： SecurityError：文档不允许创建worker时抛出（例如违背了同源策略） NetworkError：当HTTP返回的文档类型不是text/javascript时抛出 SyntaxError：当脚本url无法被解析时抛出 web worker的通信worker和主线程之间通过message进行通信，使用两个API，postMessage()方法和message事件。 在主线程发出/接收信息：12345const worker = new Worker('myscript.js')worker.postMessage(['val', 'value'])worker.onmessage = function(e) { // ...} 在worker中发出/接收信息：1234postMessage(['va'])onmessage = function(e) { // ...}postMessage(message, transfer)会接收两个参数，message表示传递的消息，可以是任意值。注意：这里message不是传递的引用，而是使用结构性克隆算法克隆的结果，worker中收到的结果是一份完全的拷贝。传递的过程是，先将数据克隆，然后序列化，再反序列化还原，所以这里我们传递的是什么数据结构，拿到的就是什么数据结构。 第二个参数transfer是一个数组，里面是transferable对象列表，例如TypedArray。这些对象是按照引用来传递，但是传递到worker中以后，原来的上下文中的引用就不可用了，只有在worker中可用，相当于“将整个引用传递了过去”。 注意：这个参数只是表示将哪些过渡过去，传递的信息还是要使用message参数。 在message事件中收到的是MessageEvent对象，该对象用于message事件（例如Server-Sent、WebSocket、跨文档通信、worker、channel messaging、broadcast messaging等），最常用的是data和origin/source（例如验证在跨文档通信中的来源）。该对象有下面几个只读的属性： data：在message事件中传递的数据，可以是任意的数据类型 origin：代表事件源的字符串 lastEventId：代表event的独特id source：代表消息发送者的message event源（可以是Window Proxy、MessagePort、或者Servcie Worker对象） ports：MessagePort对象数组（在channel messaging或者shared worker中使用） web worker的特性同源特性只能使用同源的url作为执行的代码来源，该代码的url，可以是相对url、绝对url、对象url、完整url路径，一种常见的方式是，通过URL.createObjectURL来创建对象URL，其值是脚本字符串，这样可以不进行网络请求的前提下执行指定的代码片段。 上下文特性web worker拥有自己的独立上下文，和创建它的文档上下文毫不相关。在其特有的上下文中实现了window上下文中的很多API。 self可以访问到上下文对象，在window上下文中，self指window对象；在worker上下文中，self指worker上下文。 API特性web worker用于后台执行特定的代码，不能够直接和用户界面进行交互，例如window对象、DOM API在worker中都是不能访问的，但是worker中可以使用XMLHttpRequest、Websocket、Fetch API等IO操作的API，可以使用LocalStorage等存储API，也可以使用Promise、setTimeout等异步API。 扩展这里我们利用上面学到的知识，封装一个简单的web worker库，具体细节请看vue实战：实现vue-web-worker。 参考资料WorkerUsing Web Worker","link":"/2019/07/23/html/html5-API/"},{"title":"svg基础","text":"Scalable Vector Graphics(SVG)是一种基于XML的标记语言，用于描述基于二维的向量图形。SVG对于如何用text文本来描述图形是非常重要的。 SVG是一个基于文本的开放Web标准。其被设计为与其他的web标准共同工作比如CSS、DOM和SMIL。 SVG图片和其相关的行为被定义在XML文本文件中，这意味着它可以被搜索、索引、脚本化和压缩 简介SVG是一种XML语言，和XHTML类似，可以被用于绘制向量图形。它可以被用于创建一张图片，这张图片由明确所有必须的线以及形状获得，通过修改已经存在的图片获得，或者将两者结合。图片和它的组件可以被转换、相互组合或者过滤以完全改变其外观。 SVG是一个在1999年就已经提出来的标准。 基本成分HTML提供了元素用于定义headers、paragraphs、tables等等。以相同的形式，SVG提供了元素用于圆、矩形、以及简单和复杂的曲线。一个简单的SVG文档仅仅由\\&lt;svg>根元素以及其他一些基本形状一起组成。除此之外还有一个\\&lt;g>元素，用于组织其他基本形状。 从这里开始，SVG图片可以变得任意的复杂。SVG支持渐变、旋转、filter效果、动画、以及和javascript的交互等等。但是所有的这些额外的语言的特性依赖于这一小串元素用于定义图形区域。 开始之前有很多绘制引用可以使用比如Inkscape，但是这里我们使用最基本的XML和文本编辑器。这样是为了理解SVG的内部，自己写下标记语言是最好的学习方法。 不是所有的SVG图片在任何应用中看起来都一样，因为他们可能支持不同的SVG标准，或者与其一同工作的其他标准比如css、javascript不同，这些都会导致表现不一致。 SVG被所有的现代浏览器支持以及一小部分老的浏览器。 如果你对XML不熟悉，下面的两条准则一定要牢记于心： SVG元素和属性应该注意大小写，因为XML是大小写敏感的（不像HTML） SVG的属性应该放在双引号中，即使是数字 SVG是一个巨大的标准，这里只概括了其基础。一旦你熟悉了SVG，你应该阅读元素参考和接口参考获取更多的信息。 SVG的风味自从2003年成为recommendation，最常用的SVG版本是1.1，它在1.0的基础上构建，但是增加了更多模块。2008年推出了1.2 一个简单的实例12345678&lt;svg version=\"1.1\" baseProfile=\"full\" width=\"300\" height=\"200\" xmlns=\"http://www.w3.org/2000/svg\"&gt; &lt;rect width=\"100%\" height=\"100%\" fill=\"red\" /&gt; &lt;circle cx=\"150\" cy=\"100\" r=\"80\" fill=\"green\" /&gt; &lt;text x=\"150\" y=\"125\" font-size=\"60\" text-anchor=\"middle\" fill=\"white\"&gt;SVG&gt;&lt;/text&gt;&lt;/svg&gt; 新建一个文本文件，后缀改为svg，然后将上面的代码拷贝进去，在任意浏览器中打开，我们就能看到svg绘制出来的图形，如下： SVG 渲染的步骤如下： 从svg根元素开始： 一个doctype声明，如上例 在SVG2之前，为了识别SVG的版本以及为了多种验证方式，version和baseProfile属性必须一直被使用。version和baseProfile都在SVG2中被废弃了。 作为XML的方言，SVG必须绑定正确的命名空间（在xmlns属性中） 通过绘制一个背景被设置为红色的覆盖整个区域的矩形\\ 一个半径为80的圆，左边偏移150，上面偏移100实现居中，填充为绿色。 绘制文本”SVG”，每一个内部的字符都是被填充为白色。文本通过设置一个锚点来定位到我们想要的位置。上例中是middle，在实现水平和垂直的居中。 SVG 文件的基本属性 第一个需要注意的重要的事情是元素渲染的顺序。SVG文件的全局合法规则是，后一个元素渲染在前一个元素的上面。SVG文件中越向下的元素可见。 web上的SVG文件可以在浏览器中被直接显示或者嵌入到HTML文件中，通过下面几个方法： 如果HTML是XHTML并且通过application/xhtml+xml类型传输，SVG可以年被直接嵌入到XML源文件中 如果HTML是HTML5，并且浏览器是一个支持HTML5的浏览器，SVG可以被直接嵌入。但是，也许会有必须的语法改变来适应HTML5标准。 SVG文件可以被引用为一个element元素：1&lt;object data=\"image.svg\" type=\"image/svg+xml\"&gt; iframe也可以被使用:1&lt;iframe src=\"image.svg\"&gt;&lt;/iframe&gt; img标签理论上也能使用，可能有兼容性问题。 最后SVG可以通过javascript被动态创建并且注入到HTML DOM中。使用这样的替换技术我们可以在不能常规处理SVG的浏览器中实现SVG。 SVG文件类型SVG文件有两种风格。普通的SVG文件包含SVG标记的简单文本文件。这些文件的推荐的文件名称后缀是”.svg”(都小写) 因为可能存在的巨大的SVG文件（比如地图应用），SVG标准也支持GZIP压缩的SVG文件。推荐的文件扩展名是”.svgz”。可能会有兼容性的问题，对浏览器和服务器两端都有，一般浏览器只能解析从服务器获取的gzip压缩的svg文件，而不能从本地读取。 Webserver上的配置SVG的MIME类型是： Content-Type: image/svg+xmlVary: Accept-Encoding 对于gzip压缩的svg文件： Content-Type: image/svg+xmlContent-Encoding: gzipVary: Accept-Encoding 服务器返回的HTTP头的错误配置是SVG文件加载失败的常见原因。","link":"/2019/07/26/html/svg%E5%9F%BA%E7%A1%80/"},{"title":"html实现选中、获取设置光标、复制、粘贴，并实现一个markdown编辑器","text":"这篇文章记录了如何在html中选中、复制、粘贴内容，以及如何操作可编辑区域中的光标位置，并基于这些基础知识实现了一个简单的markdown编辑器。 基础概念首先我们要介绍一些要用到的基础概念和相关API的使用。 选中DOM提供了与选中有关的API，主要是Selection接口和Range接口。 Selection一个Selection对象表示用户选择的文本范围或者当前光标的位置。使用window.getSelection()来获取Selection对象。 和Selection相关的有三个关键的概念，分别是：anchor、focus、direction。 anchoranchor表示选择的开始，代表鼠标按下时的位置。这个位置在一次选择中是不变的。通常使用DOM节点+文本偏移来表示 focusfocus表示选择的结束，代表鼠标松开时的位置或者通过键盘操作结束时的位置。通常使用DOM节点+文本偏移来表示 direction选择的方向，选择文本的时候可以从左向右选择，也可以从右向左选择。 anchor/focus和开始位置和结束位置（Range中的概念）不同，anchor可以在focus的前面，也可以在focus的后面，根据direction来确定。 Selection不仅仅可以选择文本，还可以选择多个节点，与此相关的概念是，anchorNode和focusNode，anchorNode表示anchor位置的节点，即按下鼠标时的节点；同理focusNode表示松开鼠标时的节点。 下面是使用Selection时的一些tips: 调用Selection.toString()会返回选择中包含的文本 一个Selection可以包含多个Range 调用Selection API时的表现 一个编辑宿主获取焦点，如果上一次选择在其外面 如果Selection API被调用，导致编辑宿主中创建一个新的Selection 焦点移动到编辑宿主 使用下面的API可以创建/修改selection： Selection.collapse(node, offset)：销毁指定的元素中的选择，并将光标定位到offset的位置 Selection.setPosition(ndoe, offset)：同上，是collapse的别名 Selection.collapseToStart()：销毁指定元素中的选择，并将光标定位到其range开始的位置 Selection.collapseToEnd()：销毁指定元素中的选择，并将光标定位到range结束的位置 Selection.extend(node, offset)：将focus移动到指定的位置，anchor不同，选择变成anchor到新的focus，不论方向 Selection.selectAllChildren(parentNode)：丢弃之前的selection，添加指定Node的所有子节点到selection中 Selection.addRange(range) Selection.setBaseExtent(anchorNode,anchorOffset,focusNode,focusOffset)：将两个节点和其之间的内容添加到选择中 注意：Selection API参数是node和offset时(extend除外)，如果node节点是文本节点，offset就是光标左边字符的数量；对于其他的节点类型，是node的偏移的子节点的数量。举个例子：1234&lt;article contenteditable id=\"editor\"&gt; &lt;div&gt;sfasffdgfdg&lt;/div&gt; &lt;div&gt;光标位置&lt;/div&gt;&lt;/article&gt;假设调用window.getSelection().setPosition(document.getElementById(editor), 1)，那么光标会被设置在第二个div的开始位置。如果希望精确到文本偏移，请确保选择一个其子节点是文本节点的节点。 RangeRange代表document中的一部分，可以包含节点和文本节点的一部分。获取Range的方式是document.createRange()或者Selection.getRangeAt(index) 使用Selection API和Range API操作文档中的选择的过程是，选择代表用户或者API选中的文档中的一部分节点或者文本，选中的这一部分节点或者文本叫做Range，所以Selection和Range是有对应关系的，大部分情况下一个Selection对应一个Range，但是也可以对应多个Range，例如使用ctrl或者API来选择多个Range。 操作Range的常用API如下： Range.setStart(startNode, offset)：设置Range的开始位置。设置一个在end后面start会导致Range崩塌(collapse)，start和end都被设置在同一点，为start的位置 Range.setEnd(endNode, offset) Range.setStartBefore(referenceNode) Range.setStartAfter(referenceNode) Range.setEndBefore(refNode) Range.setEndAfter(refNode) Range.collapse(toStart)：将Range设置为一个边界点，默认到为结束，toStart结束为开始 Range.selectNode(node)：将node及其内容加入到Range中 Range.selectNodeContents(node) 浏览器的可编辑区域首先我们先要了解以下浏览器的可编辑元素，浏览器的可编辑元素，我们知道的可编辑元素有两种，一个是将元素设置contenteditable，另一个是textarea。contenteditable可以设置于任何元素，让其内容变成编辑的，其与textarea的区别是，textarea的内容是纯文本，contenteditable元素的内容虽然输入的是纯文本，可以但是在浏览器中复制dom（直接选中复制即可），可以用dom API插入DOM，这样可以在contenteditable中实现高亮，显示图片预览等等功能。接下来我们对两者分别介绍。 contenteditablecontenteditable可以将任意一个元素设置成可编辑的，这里的可编辑，当用户聚焦的时候输入的时候，输入的是纯文本，也就是输入&lt;span class=&quot;red&quot;&gt;red&lt;/span&gt;的时候，显示的就是输入的文字。 但是当我们从其他html页面中选中一部分然后复制时，可以直接将这一部分DOM复制过来，可以包括图片和样式。复制DOM：在contenteditable中复制结束后（图中自己使用contenteditable和Selection API写的markdown编辑器，详见）： 也可以直接用DOM API来操作DOM，例如设置颜色、背景、插入图片，表格等等。在发散思考一下，是不是利用这些特性，一个可编辑的富文本编辑器的雏形就出来了？可以在可编辑区域中插入表格，设置字体颜色，插入图片预览，最重要的是，可以直接复制这些内容！ 需要注意的是，我们在contenteditable区域中输入换行的时候，被编辑的元素中会插入一个DIV(或者是li等，取决于父元素)，而不是用\\n表示。当我们想要获取到contentediable元素中的换行时，需要使用innerTEXT而不是textContent，关于innerTEXT和textContent的区别请看我的另一篇文章：innerTEXT和textContent的区别。 而且当使用Selection API时，contenteditable也会比textarea复杂，因为contenteditable元素可能有很多子元素，在设置光标的位置的时候可能会遇到麻烦，请继续阅读下文的实现部分——实现一个markdown编辑器。 textareatextarea是文本输入区域，其内容区域的所有内容都是文本。不能实现contenteditable元素中对dom操作的那么多功能。其优点是兼容性好，比较简单。 在textarea中获取光标/选中的位置十分方便，直接使用textarea DOM(HTMLTextAreaElement接口）的selectionStart、selectionEnd、selectionDirection来获取，当selectionStart===selectionEnd时，表示光标的位置，获取到的是，光标在textarea中偏移的字符的数量。选择的方向可以是从前到后，也可以是从后到前，由selectionDirection给出，值是”forward”或者”backward”。 提示：css规范并没有规定textarea的基线在哪里，不同浏览器对textarea的实现不同，其基线是不一致的，使用vertical-align: middle得不到一直的结果，并且其结果是不可预测的。 复制粘贴在浏览器中有两种和系统剪切板进行交互的方式：Document.execCommand以及现代异步的ClipBoard API。 使用document.execCommand来实现复制粘贴可以兼容到IE 9，ClipBoard API是最新的标准，用于取代document.execCommand，chrome 66以后才支持。接下来我们来看看两种实现复制粘贴的方式。 document.execCommand使用copy、cut、paste三个命令来实现复制粘贴： document.execCommand(‘copy’)，将当前选中的内容替换系统剪切板的当前内容 document.execCommand(‘paste’)，将系统剪切板中的内容复制到光标位置 document.execCommand(‘cut’)，将当前选中的内容替换系统剪切板的当前内容，并移除原有内容 当直接在事件处理器中执行命令时没有权限问题，但是如果要直接使用execCommand时，不同的浏览器会有不同的行为，在某些浏览器中可能会报错（没有复制权限），需要申请权限，关于权限API请看我的另一篇博客浏览器中的权限和Permission API ClipBoard API使用navigator.clipBoard可以访问clipboard API，clipboard API是最新的标准，所有的API都是基于Promise的异步API。 提供了以下API： read()：从剪切板请求任意的数据，例如图片，返回一个Promise。Promise resolve的是一个DataTransfer对象。 readText()：从剪切板请求文本。Pormise resolve的是一个DOMString文本。 write()：向剪切板写入任意的数据，返回Promise，Promise resolve表示写入完成 writeText()：向剪切板写入文本 123navigator.clipboard.readText().then(str =&gt; { console.log(str)}) clipboard API的优势是其是最新支持的标准，能够直接操作剪切板，向剪切板插入任意数据。 劣势是兼容性差，必须要Permission。 参考资料MDN Interact with the clipboard 实战这里我们使用上面提到的API，来实现一个简单版的markdown编辑器，主要功能是，在光标位置插入指定的内容，并重置光标位置。 Selection和Range API用于设置光标位置，选中指定的区域。Range代表一个区域，API的主要作用是设置区域的开始和结束，Selection代表选中，可以包含多个区域，API的主要作用是设置range，操作选中的区域（销毁选中、选中指定的区域），设置光标。 execCommand和ClipBoard API用于复制粘贴。选中-&gt;复制：可以复制到剪切板，设置光标-&gt;粘贴，可以在光标位置粘贴。 contenteditable元素中插入的是dom，可以通过操作DOM来实现各种内容（多行、图片等）的插入。","link":"/2019/09/08/html/html%E5%AE%9E%E7%8E%B0%E9%80%89%E4%B8%AD%E3%80%81%E5%A4%8D%E5%88%B6%E3%80%81%E7%B2%98%E8%B4%B4/"},{"title":"svg基础：path","text":"","link":"/2019/08/19/html/svg%E5%9F%BA%E7%A1%80%EF%BC%9Apath/"},{"title":"centos7 下安装jdk","text":"首先查看是否安装了jdk，输入命令：1java -version如果输出了版本号，说明安装了java。 再输入命令：1javac 如果没有提示错误，曾说明java已正确安装。如果没有安装java，或者值有java或者javac，请看下面。 仅有java命令如果仅有java命令，那么很可能是安装了java运行环境而没有安装java开发环境。解决方案是先卸载原先安装的java。在安装新的，以java8为例。 查看系统中已有的java版本1yum list installed | grep java 可能输出如下信息：1234567891011121314151617181920java-1.8.0-openjdk.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-accessibility.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-accessibility-debug.x86_64java-1.8.0-openjdk-debug.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-demo.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-demo-debug.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-devel.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-devel-debug.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-headless.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-headless-debug.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-javadoc.noarch 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-javadoc-debug.noarch 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-javadoc-zip.noarch 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-javadoc-zip-debug.noarchjava-1.8.0-openjdk-src.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-1.8.0-openjdk-src-debug.x86_64 1:1.8.0.232.b09-0.el7_7 @updates java-atk-wrapper.x86_64 0.30.4-5.el7 @base javapackages-tools.noarch 3.4.1-11.el7 @base python-javapackages.noarch 3.4.1-11.el7 @base tzdata-java.noarch 2019c-1.el7 @updates 卸载已安装的java1yum -y remove java-1.8.0-openjdk* java-1.8.0-openjdk*是要卸载的包的名字，*是通配符，根据上面yum list的输出来具体确定哪些包。 安装java1yum install -y java-1.8.0-openjdk* 上面的命令安装java 1.8，也可以指定其他的版本。 接下来分别执行java、javac，看看输出，如果都有输出，说明java环境正确安装了。 如果没有呢，看看java环境有没有正确配置。首先yum安装的java会在/usr/lib/jvm下，找到java和javac对应的二进制文件，将其配置到path中。然后在path中添加JAVA_HOME和CLASSPATH环境变量。 没有java命令直接安装java：1yum install -y java-1.8.0-openjdk*在path中添加JAVA_HOME和CLASSPATH环境变量。12345cd ~vim .bashrc# 按i，然后在最后面添加下面的内容export JAVA_HOME=\"/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.232.b09-0.el7_7.x86_64/jre\"export CLASSPATH=\".\"注意java_home要根据安装的java版本来设置。","link":"/2019/11/08/java/centos7-%E4%B8%8B%E5%AE%89%E8%A3%85jdk/"},{"title":"centos7下安装maven以及修改maven仓库设置","text":"默认的Maven仓库因为镜像在国外，下载是在是太慢，这篇文章介绍一下如何修改maven仓库为国内的镜像，适用于centos7。 安装maven1sudo yum install -y maven 配置maven仓库输入：whereis maven，可能输出：1/usr/maven 输入以下命令：12cd /usr/mavensudo vim settings.xml找到&lt;mirrors&gt;，然后输入下面的内容：123456&lt;mirror&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;mirrorOf&gt;central&lt;/mirrorOf&gt; &lt;/mirror&gt; 单个项目配置对于单个项目，可以在pom.xml设置：1234567&lt;repositories&gt; &lt;repository&gt; &lt;id&gt;alimaven&lt;/id&gt; &lt;name&gt;aliyun maven&lt;/name&gt; &lt;url&gt;http://maven.aliyun.com/nexus/content/groups/public/&lt;/url&gt; &lt;/repository&gt;&lt;/repositories&gt;注意&lt;repositories&gt;和&lt;dependencies&gt;同级。","link":"/2019/11/19/java/centos7%E4%B8%8B%E4%BF%AE%E6%94%B9maven%E4%BB%93%E5%BA%93%E8%AE%BE%E7%BD%AE/"},{"title":"svg基础：定位&amp;基础图形","text":"在这篇文章中，我们检验SVG怎么样在一个绘制上下文中呈现对象的位置和大小，包括坐标系统以及’pixel’度量在可伸缩上下文中意味着什么。 网格对于所有的元素，SVG使用一个坐标系统或者grid系统，和canvas中使用的相似，左上角是(0,0)，向左x增大，向下y增大。位置可以通过指定相对于原点的左上偏移来指定。这也是HTML元素默认的坐标系统形式。 例如1&lt;rect x=\"0\" y=\"0\" width=\"100\" height=\"100\" /&gt;定义了一个从左上角开始的举行，并且左右、上下横跨100px。 什么是“像素(pixel)”在大部分的基础场景中，SVG文档中的1像素对应输出设备的1像素（比如屏幕）。但是SVG中的S对应着Scalable（可伸缩的），如果SVG没有改变这个行为的可能性的话，它就不会有这个名字。非常像css种的绝对和相对的font-size。SVG定义了绝对长度单元（比如”pt”或者”cm”），称其为用户单元，它缺少单位并且只是单纯的数字。 没有进一步明确的说明，一个用户单元等与1个屏幕分辨率。为了显式地改变这个行为，在SVG中有几个途径。从svg标签开始： \\ 上面的元素仅仅对应100x100 px，一个用户单元等于一个屏幕单元。 \\ 整个SVG画布是200x200 px。但是viewBox属性定义了画布展示的部分。200x200的区域从用户单元(0,0)开始，并且跨度为100x100用户单元。在这里，width=200，height=200，定义了svg的宽和高，这是不变的，那么viewBox的作用是什么呢?viewBox可以控制图形和显示区域的比例，在上例中，viewbox是(0,0)到(100,100)，那么可视区域将在200x200的区域内展示原图形中100x100的图形，相当于将svg放大了两倍。如下例： SVG 将用户单元转为屏幕单元的匹配称为用户坐标系统。除了缩放之外，坐标系统还可以旋转、扭曲和翻转。默认的用户坐标系统匹配一个用户像素称1个设备像素（但是，设备可能决定，设备的1个像素意味着什么。例如，一个设备像素可能对应多个物理像素，比如移动设备）。SVG文件中的用于明确w维度的长度单元，比如”in”或者”cm”，会用一种方式计算，让其在结果图片中1:1显示。 基本形状矩形 \\ \\ ### 圆&gt; \\ 椭圆 \\ 线 \\ 多点连线 \\ 多边形 \\ 路径 \\ 其中路径是最基础的形状，可以用路径画出其他的所有形状。","link":"/2019/07/27/html/svg%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AE%9A%E4%BD%8D&%E5%9F%BA%E7%A1%80%E5%9B%BE%E5%BD%A2/"},{"title":"浏览器中的权限和Permission API","text":"浏览器提供各种各样的能力，如访问摄像头，访问地理位置，访问剪切板，Notification等等，许多API都是需要用户授权才能使用的。但是以前的API授权方式不具有一致性，每个API都有自己的不一样的授权方式。目前处于Working Draft的Permission标准就是用于解决这个问题的，Chrome 60+，firefox 46+支持。 Permission API用于解决浏览器的授权方式一致性问题，通过Permission API可以对所有的授权提供一直的授权申请、授权状态查询。 使用Permission API通过navigator.permissions.query来申请和获取权限状态。query方法的只接收一个参数，该参数是一个对象，该对象可能包含三个属性： name：申请的权限的名字，可能是 “geolocation”,“notifications”,“push”,“midi”,“camera”,“microphone”,“speaker”,“device-info”,“background-fetch”,“background-sync”,“bluetooth”,“persistent-storage”,“ambient-light-sensor”,“accelerometer”,“gyroscope”,“magnetometer”,“clipboard”,“display” userVisibleOnly：仅用于push sysex：仅用于midi query方法返回一个promise，该promise resolve一个PermissionStatus对象，该对象的state或status属性代表当前授权的信息，可能的值是： granted prompt denied 该对象的change事件当state改变时触发。 参考资料MDN Permission APIw3c Permission","link":"/2019/09/19/html/%E6%B5%8F%E8%A7%88%E5%99%A8%E4%B8%AD%E7%9A%84%E6%9D%83%E9%99%90%E5%92%8CPermission-API/"},{"title":"xml：基础","text":"","link":"/2019/10/04/html/xml%EF%BC%9A%E5%9F%BA%E7%A1%80/"},{"title":"JavaScript-ES5-正则表达式复习","text":"正则表达式是一种描述字符模式的对象。也就是一个正则表达式是描述了一类字符的模式，用一个正则表达式可以来匹配一类字符。 使用正则匹配字符串的时候，从前到后遍历字符串匹配，默认贪婪匹配（即一个模型尽可能多的匹配）。例如，/0x\\d+$/匹配0x1234，0x先匹配，正确；然后\\d+表示一个或者多个数字，1234依次匹配成功，到了末尾，匹配$，成功。至此模式匹配成功。中间由一个匹配不成功则匹配失败 匹配过程可以用有限自动机来理解。 要点 直接量字符：所有字符都是按照字面意思进行翻译，除了一些特殊字符。 js的正则表达式可以识别转义字符，例如\\t \\n \\uxxxx等 具有特殊意义的字符有：^ $ . * + ? = ! : | \\ / ( ) [ ] { }，如果希望使用这些字符的直接量，使用\\转义，例如\\. 字符类：匹配某一类字符 [...]：匹配方括号中任意一个字符，可以使用范围，例如[a-zA-Z0-9] [^...]：匹配方括号之外的任意一个字符，其他同上 .：匹配除\\n和其他Unicode行终止符之外的任意字符 \\w：等价于[a-zA-Z0-9] \\W：等价于[^a-zA-Z0-9] \\s：任何unicode空白符 \\S：任何unicode非空白符 \\d：等价于[0-9] \\D：等价于[^0-9] 重复：上面是字符模型的定义，要表示多个相同模式的字符呢？可以用/\\d\\d\\d/这种形式，但是有更好的方法。注意，重复默认贪婪匹配，可以通过在后面将上?表示尽可能少的匹配。例如??,+? {n,m}：匹配前一项至少n个，至多m个 {n,}：匹配前一项n个或者更多 {n}：匹配前一项n次 ?：匹配1次或者0次，等价于{0,1} +：匹配1个或者更多，等价于{1,} *：匹配0个或者更多，等价于{0,} 选择、分组和引用： 选择：|，例如/a|b/，表示匹配a或者匹配b，即从ab中选择一个匹配 分组：()，圆括号有两个作用，第一个是分组，例如/(ab)+|b/将(ab)作为一个整体；第二个是定义子模式，ab是一个子模式，可以引用该子模式的匹配结果 引用：\\1，引用的是**用圆括号分组的子模式匹配的文本，例如/(ab)+|b\\1/其中的\\1表示引用第一个子模式匹配的文本，如果匹配字符串ababbb那么\\1的值是abab 不产生引用的分组：(?:...)，只有分组功能，不记忆匹配结果 指定匹配位置：匹配的是字符串中的位置，而不是具体的字符 匹配单词边界：\\b，注意[\\b]匹配退格 匹配非单词边界：\\B 匹配开始：^，表示匹配一个字符串的开始位置 匹配结束：$，表示匹配一个字符串的结束位置 零宽正向先行断言：(?=p)，匹配一个位置，该位置的后面是子模式p。例如/(?=s)/表示匹配后面是s的位置，字符s不会被匹配。 零宽负向先行断言：(?!p)，同上，不过是匹配后面不满足子模式p的位置。例如/(?!s)/表示如果后面不是s则该位置匹配，字符不会被匹配。 修饰符： i：匹配不区分大小写 g：执行全局匹配。例如模式/a+/g匹配字符串ababaab，匹配结果由三个分别是a,a,aa。如果没有g，则只有一个a，因为匹配后不会继续匹配 m：多行匹配。^匹配行开头和字符串开头，$匹配行结束和字符串结束。 用于模式匹配的String方法 s.search(pattern)：在s中匹配pattern，返回第一个批评为位置，没有匹配则返回-1。如果pattern不是正则表达式，则用RegExp变成正则 s.replace(pattern|ss, replace)：如果第一个参数是正则，那么替换正则匹配的子串，如果有g则替换所有满足的子串。如果是字符串，那么替换所有等于ss的子串。replace的第二个参数可以是函数，该函数在每次匹配到子串的时候调用，如果没有g则只调用一次，函数的形式是function(fullMatched, child1, child2, ..., position, fullString)，第一个参数是匹配的子串，后面接所有的括号子模式的匹配结果，然后是匹配的位置和完整字符串，函数的返回值是替换结果。第二个参数还可以是字符串，字符串中可以使用$1，$2等等来引用括号匹配的子串。 s.match(pattern)：如果pattern不是正则，则用RegExp转成正则；如果pattern没有g，则返回一个数组，数组的第一项是匹配结果，后面依次是子模式的匹配结果；如果有g，则返回所有匹配pattern的子串的数组。 s.split(pattern)：根据pattern来分割字符串，返回分割后的子串数组。 正则表达式的模式匹配方法： pattern.exec(string)：和s.match基本一样 pattern.test(string)：根据是否匹配成功返回true或者false，只要string中有子串满足模式就匹配成功。","link":"/2020/02/21/js/JavaScript-ES5-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%A4%8D%E4%B9%A0/"},{"title":"JavaScript(ES5)核心语法复习指南","text":"这篇文章覆盖JavaScript(es5)的所有语法要点，便于日后进行js基础方面的查阅和复习。参考《JavaScript权威指南》，采取编译原理结构的形式进行总结，从词法、类型、表达式、语句等方面来总结。 要点归纳 1.词法结构 字符集：使用的是Unicode字符集，采用UTF-16编码，标识符区分大小写。 注释：//或者/**/ 直接量： 数字：12、1.2、1.2E-8、.33333 字符串：”Hello”、”\\u0212” 布尔值：true、false 正则表达式：/javascript/gi 空：null 对象：{x:1, y:2} 数组：[1,2,[2,4],{x:1,y:2}] 标识符：包括字母、数字、下划线(_)和美元符号($)。标识符不能以数字开头。允许使用Unicode全集作为标识符，也就是使用中文变量是可以的。 保留字：和java等其他编程语言的关键字类似，特殊的有：delete、function、typeof、var、debugger、default 分号可选：使用分号隔开不同的语句，否则就需要使用换行 2.类型、值和变量 6种基本数据类型：5种原始数据类型（字符串、数字、布尔值、null、undefined）和对象。原始数据类型变量存的是值，而对象变量存的是引用。数组和函数都属于特殊的对象。js中基础类型都是不可变的，包括字符串，只有对象可变 1.数字：js不区分整数和浮点数，数字全部使用64位IEEE754浮点数（1符号位+52尾数+11指数）来表示。能表示的整数范围是$-2^{53}-2^{53}$。但是数组索引和位运算采用的是32位。 数字的运算：+、-、*、/、%，复杂运算通过Math来实现，例如Math.sin、Math.ceil、Math.floor、Math.round等。 数字溢出和下溢：溢出包括正溢出和负溢出，溢出的值用Infinity和-Infinity表示。x/0返回Infinity，但是如果x=0则报错。 NaN：表示不是一个数字（Not a Number），该值与任何值都不相等，包括它自己，通过isNaN()或者x!=x来判断。 舍入误差：IEEE754浮点数表示法不能精确表示0.1等数字，表示的是近似值，当进行运算时会有误差，因此不能通过.3-.2==.1来判断。ES6新增了Number.EPSILON表示一个即小的数，要使用(.3-.2)-.1 &lt; EPSILON这样判断。 时间和日期：Date()构造函数用于创建时间日期对象。常用方法有： var then = new Date(2020,2,20,10,27,48); var now = new Date(); // 当前时间 now.getFullYear() now.getDate() // 1-31 now.getDay() // 0-6，0表示周日 now.getMonth() // 0-11 now.getHours() now.getMinutes() now.getSeconds() 2.文本 字符串是UTF-16序列的数字，注意位于基本平面内的字符是一个16位值，而处于其他平面的字符需要两个16位值来表示。这在字符串遍历字符的时候需要考虑。字符串是不可变的，所以对字符串的任何操作都是返回新字符串，而不是在原字符串上改变。 多行字符串可以使用\\来分割。 字符串的使用： 通过+连接字符串 s.length s.charAt(0) s.substring(start, end) s.substr(start, length) s.slice(start, end) s.indexOf(‘l’) s.lastIndexOf(‘l’) s.split(‘,’) s.replace(‘h’, ‘H’) s.toUpperCase() 字符串可以使用正则表达式进行模式匹配 pattern.test(text) text.search(pattern) text.match(pattern) text.replace(pattern, ‘#’) text.split(/\\D+/) 3.布尔值：只有两个值true和false。布尔值转成字符串会变成’true’和’false’ 4.null和undefined：null表示控制、undefined表示未定义或者未赋值 5.全局对象：js会创建一个全局对象，未使用var声明的变量、全局属性、全局函数、全局构造函数、全局对象都绑定在全局对象上。浏览器中的全局对象是window，nodejs中的全局对象是global。 6.包装对象：类似&quot;123&quot;.charAt(0)是允许的，原因值js会将原始值转换成其包装对象，所以看起来就像原始值也有属性和方法。创建的包装对象是临时对象，不会保存。 7.可变和不可变的值：原始类型不可变、引用类型可变。对象称为引用类型，对象的比较是引用的比较。 8.类型转换： 字符串到： 数字：数字或者NaN，例如’1.2’=&gt;1.2，’a’=&gt;NaN，区别与C/C++中的char。 布尔值：””=&gt;false，其他=&gt;true 对象：new String() 数字到： 字符串：直接变成字符串，例如0=&gt;’0’，Infinity=&gt;’Infinity’ 布尔值：0=&gt;false，NaN=&gt;false，其他=&gt;true 对象：new Number() 布尔值到： 字符串：false=&gt;”false”，true=&gt;”true” 数字：true=&gt;1，false=&gt;0 对象：new Boolean() null、undefined到： 字符串：’null’、’undefined’ 数字：null=&gt;0、undefined=&gt;NaN 对象：报错 对象到： 字符串：使用对象的toString方法或者valueOf方法 数字：使用valueOf方法或者toString方法 布尔值：true 数组到： 字符串：[]=&gt;””、[9]=&gt;”9”、[1,2]=&gt;’1,2’，使用join方法 数字:[]=&gt;0、[9]=&gt;9，其他=&gt;NaN 布尔值：true 函数到： 字符串：使用toString或者valueOf 数字：NaN 布尔值：true 9.隐式类型转换和显式类型转换： 进行运算时，如果操作数的类型不同，那么会进行隐式的类型转换。==会进行类型转换而===不会。==转换时原始值都会转换成数字，所以”0”==false返回true，尽管”0”转换成布尔值时true。 显式类型转换：通过Number(‘1’)、String(1)、Boolean(1)等方式进行 还有parseInt、parseFloat将字符串转成数字 num.toFixed、num.toPrecision等将数字格式化成对应的字符串的方法。 10.变量声明：var name1=1,name2…，var可以重复声明变量 变量和函数声明会提前到作用域的最顶部，称为变量提升。 没有使用var声明的变量将会挂载到全局对象上 var声明的变量不能用delete删除 11.变量作用域： ES5只有两种作用域，分别是函数作用域和全局作用域 因为能在函数中定义函数，所以函数作用域能嵌套，嵌套的作用域连接成作用域链，变量查找的时候会查作用域链 内层函数能访问到外层函数的变量，如果外层函数退出了而内层函数没有，那么外层函数中被内层函数引用的变量不会回收，称为闭包。 3.表达式和运算符 1.原始表达式：表达式的最小单位 直接量 保留字：true、false、null、this等 变量：i、sum、undefined 2.对象和数组的初始化表达式： [表达式, 表达式, …]，这些表达式会在数组初始化时求值。表达式可以是任意表达式。 {name:表达式, name2:表达式}，内部的表达式会再对象初始化时求值，表达式可以是任意表达式 3.函数定义表达式： 函数定义表达式返回一个值为函数的对象，可视为“函数直接量” 语法：function name() {} 因为函数定义是表达式，所以可以这样赋值var a = function () {} 4.属性访问表达式： expression.identifier或者expresstion[expression]，expression可以是任意表达式，[之前的expression的值会先计算。 5.调用表达式： 语法：expression(args)，expression是函数表达式，在调用前求值，如果值不是可调用的，则报错。 6.对象创建表达式： 语法：new identifier(args) 对象创建过程是，新建一个对象，作为构造函数中的this，如果构造函数没有返回值，那么这个对象作为对象创建表达式的值，否则使用返回的对象作为对象创建表达式的值。 7.运算符：包括算术运算、逻辑运算、赋值运算、还有delete、typeof、instanceof等。 优先级：单目运算（++、–最高）高于双目运算、算术运算$\\lt$移位运算$\\lt$比较运算，逗号最低、赋值倒数第二。 通过括号可以改变优先级，推荐方式 按位运算：&amp;,|,^,~,&gt;&gt;,&lt;&lt;,&gt;&gt;&gt;等采用32位整形运算，会忽略超过32位的部分。 比较运算：==、&gt;=、!=等。对象转为原始值，两个字符串比较的是字母表顺序，至少一个不是字符串则转为数字比较。比较操作如果包含NaN则总是返回false in：左操作数是字符串或者可以转成字符串，右操作数是一个对象。如果右对象包含左属性则返回true。 instanceof：左操作数是对象，右操作数是构造函数。如果构造函数的prototype在对象的原型链上，则返回true。 8.逻辑表达式：&amp;&amp;、||、! &amp;&amp;和||都是短路运算符，左右两边可以是任意表达式，如果短路了则不会对另一部分的表达式进行计算。 a &amp;&amp; b，如果a是真值则返回b，否则返回a。常用a = arg &amp;&amp; arg.length a || b，如果a是真值则返回a，否则返回b。例如a = arg1.len || arg2.len !a，先将a求值并转为布尔值，再取反。 9.赋值表达式 a = b：a一定要是左值，返回赋值后的a的值 10.eval表达式 eval可以动态执行代码，也就是可以在运行时构造任何代码并执行。例如eval(‘2+3’) eval表达式返回其最后一条语句的值。 eval的作用域和调用他的作用域一样 11.其他运算符： 三目运算符：a?b:c，如果a是真值，则计算b并返回其值，否则c typeof运算符，能用typeof区分基础类型、函数和宿主对象： undefined：返回’undefined’ null：返回’object’ 字符串：返回’string’ 数字：返回’number’ true或者false：返回’boolean’ 函数：返回’function’ 任意对象和内置对象：返回’object’ 宿主对象：返回编译器实现的字符串，一般也是’object’ delete运算符：delete a.o，删除a对象中的o属性，delete不返回值。 void运算符：忽略一个表达式的值，例如void window.open() 逗号运算符：i,j=0,k，操作数可以是任意类型，返回最后一个操作数的值。","link":"/2020/02/21/js/JavaScript-ES5-%E6%A0%B8%E5%BF%83%E8%AF%AD%E6%B3%95%E5%A4%8D%E4%B9%A0%E6%8C%87%E5%8D%97/"},{"title":"javasript异步编程","text":"javascript的异步编程的核心是事件循环，js的运行环境有浏览器和nodejs，两者的异步模型有相似之处，也有不同。这篇文章主要总结javascript在浏览器和nodejs中的事件循环的细节，以及异步编程的解决方案：回调函数、Promise、generator函数、自动执行的generaor函数、async函数。 事件循环javascript的执行是单进程单线程的，不管是在浏览还是在node中。js通过事件循环来处理异步任务。当启动一个异步任务之后，例如发起一个网络请求，该请求会交给js引擎去处理，js引擎会维护线程池来进行处理异步任务。当线程池中的异步任务完成以后，会将该异步任务的回调函数加入到事件队列中。事件队列中的任务会依次执行，当事件队列中的一个回调执行完成以后，js引擎会从事件队列中拿下一个回调函数执行，如此反复。 如果事件队列中的回调执行时又触发了异步任务，那么会继续入队。当事件队列为空时，会执行一个idle任务，该任务一直循环，检查任务队列是否为空，如果不空就会调用该任务。在程序最开始执行的时候，异步队列为空，主线程执行脚本，遇到异步任务时就会处理异步任务并进行入队的处理。 在nodejs中，如果线程池中还有异步任务在执行或任务队列不为空，那么该node进程不会退出，只有所有异步任务都执行完成了进程才会退出。 在事件循环中有宏任务和微任务的区别，js引擎处理任务队列的时候会先处理微任务、再处理宏任务。常见的微任务有Promise的回调、node的process.nextTick等，常见的宏任务有setTimeout、setInterval等。 上面的事件循环是适用于浏览器和node环境的通过规则，但是node和浏览器的事件循环还是有一些区别的，接下来详细分析。 node的事件循环","link":"/2020/05/03/js/javasript%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"title":"js基础：es6对象&#x2F;数组遍历的多种方法","text":"对象属性的遍历ES6一共有5种方法可以遍历对象的属性。 (1) for…infor…in循环遍历对象自身的和继承的可枚举属性（不包含Symbol属性）。 (2) Object.keys(obj)Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含symbol属性） (3) Object.getOwnPropertyNames(obj)Object.getOwnPropertyNames返回一个数组，包括对象自身的所有属性（不含继承，不含symbol，但是包含不可枚举属性） (4) Object.getOwnPropertySymbols(obj)Object.getOwnPropertySymbols(obj)返回一个数组，包括对象自身的所有Symbol属性 (5) Reflect.ownKeys(obj)Reflect.ownKeys返回一个数组，包含对象自身的所有属性，不管是属性名、Symbol或字符串，也不管是否可枚举 以上的5种方法遍历对象的属性，都遵循同样的属性遍历的顺序： 首先是属性名为数值的属性 其次是属性名为字符串的属性，按照生成时间排序 最后是所有属性名为Symbol值的属性，按照生成时间排序 下面按照能不能遍历到继承的属性、能不能获取到symbol、能不能获取到可枚举属性进行分类： 可遍历继承的属性只有for…in可以遍历到可继承属性，其他的都不能遍历到继承的属性 可遍历symbol属性 Reflect.ownKeys(obj)可以获取symbol，属性（可枚举和不可枚举） Object.getOwnPropertySymbols 可遍历不可枚举属性 Object.getOwnPropertyNames可以获取到除Symbol外的所有属性（包括不可枚举属性） Reflect.ownKeys可以获取到所有属性，包括Symbol、可枚举和不可枚举属性 数组属性的遍历 for循环（用length属性区边界) for…in for…of Array.prototype.keys ，返回包含键的一个遍历器对象，可以用for…of进行遍历 Array.prototype.entries，返回包含键值对一个遍历器对象 Array.prototype.values，返回一个包含值的遍历器对象 for+Object.keys，先用Object.keys拿到所有自由属性，然后for遍历 判断一个对象是不是数组假设要判断obj是不是数组实例，可以用下面的方法： obj instanceof Array Array.isArray() Object.prototype.String.call(obj).match(/[object (.*)]/)[1] === ‘Array’ 实战1：数组和对象的深度/广度优先遍历根据我们前面提到的几种获取属性的方法，来实现不同返回的深度、广度遍历。我们根据需要，可以写出遍历包含可枚举属性的版本，也可以写出不包含可枚举属性的版本。在进行遍历的时候，我们需要判断对象的类型，判断对象的类型的多种方法和其比较请参考我的另一篇博客：js判断对象类型的多种方法和比较 不包含不可枚举属性的遍历 深度优先遍历前提是没有循环引用，如果有循环引用，会有无穷遍历的问题，可以给遍历过的每一个对象加上特殊的标记解决这个问题，上代码：12345678function dfs(obj) { let type = Object.prototype.toString.call(obj).match(/\\[object (.*)\\]/)[1] if(type == 'Object' || type == 'Array') { for(let name of Object.keys(obj)) dfs(obj[name]) } else { console.log(obj) }} 广度优先遍历123456789101112131415function bfs(obj2) { let queue = [] queue.push(obj2) while(!(queue.length === 0)) { let obj = queue.shift() let type = Object.prototype.toString.call(obj).match(/\\[object (.*)\\]/)[1] if(type === 'Object' || type === 'Array') { for(let name of Object.keys(obj)) { queue.push(obj[name]) } } else { console.log(obj) } }} 包含不可枚举属性的遍历与前面的代码基本相同，我们只要将Object.keys改称Object.getOwnPropertyNames就行了 实战2：数组和对象的深拷贝对象通过=赋值是浅拷贝，也就是只会拷贝对该对象的引用，修改该对象会导致所有指向该对象的引用的内容改变。 有时候我们希望获得一份独立的拷贝，这时候就需要深拷贝了，js原生不支持深拷贝，我们可以利用深度优先遍历拷贝一个对象的所有属性和方法，包括不可枚举属性。 使用getOwnPropertyNames获取所有的对象属性，然后将其拷贝到一个新对象中，上代码:123456789101112131415161718192021222324Object.prototype.clone = function() { let cloneObj = null, tempObj = null let thisType = Object.prototype.toString.call(this).match(/\\[object (.*)\\]/)[1] if(thisType === 'Object') cloneObj = tempObj = {} else if(thisType === 'Array') cloneObj = tempObj = [] else cloneObj = this ;(function traverse(obj, tempObj) { let names = Object.getOwnPropertyNames(obj) for(let name of names) { let type = Object.prototype.toString.call(obj[name]).match(/\\[object (.*)\\]/)[1] if(type === 'Object') { tempObj[name] = {} traverse(obj[name], tempObj[name]) } if(type === 'Array') { tempObj[name] = [] traverse(obj[name], tempObj[name]) } else { tempObj[name] = obj[name] } } }(this, tempObj)); return cloneObj;}","link":"/2019/07/11/js/js%E5%9F%BA%E7%A1%80%EF%BC%9Aes6%E5%AF%B9%E8%B1%A1-%E6%95%B0%E7%BB%84%E9%81%8D%E5%8E%86%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"tslint基础知识","text":"tslint是一个可扩展的静态分析工具，它检查typescript的可读性、可维护性以及功能性错误。 安装CLI npm install tslint typescript –save-devnpm install tslint typescript -g typescript和tslint是同级的依赖，需要同时安装。 CLI的使用请确保在linter前typescript源文件被正确编译。 使用：tslint [options] [file …] Options:1234567891011121314151617-v, --version output the version number-c, --config [config] configuration file-e, --exclude &lt;exclude&gt; exclude globs from path expansion--fix fixes linting errors for select rules (this may overwrite linted files)--force return status code 0 even if there are lint errors-i, --init generate a tslint.json config file in the current working directory-o, --out [out] output file--outputAbsolutePaths whether or not outputted file paths are absolute--print-config print resolved configuration for a file-r, --rules-dir [rules-dir] rules directory-s, --formatters-dir [formatters-dir] formatters directory-t, --format [format] output format (prose, json, stylish, verbose, pmd, msbuild, checkstyle, vso, fileslist, codeFrame)-q, --quiet hide non &quot;error&quot; severity linting errors from output--test test that tslint produces the correct output for the specified directory-p, --project [project] tsconfig.json file--type-check (deprecated) check for type errors before linting the project-h, --help output usage information 比较常用的选项有： -c, –config, 指定tslint.json配置文件（这个文件是扩展json文件，可以写注释） –fix，自动修复问题，会修改源文件 -i, –init，初始化一个tslint.json文件 -p, –project，指定tsconfig.json文件 使用示例： tslint –fixed -p tsconfig.json tslint会从被检查的文件的目录下赵tslint.json文件，一直向父目录查找。 退出状态码CLI可能以如下的状态码退出： 0: 成功通过检查（可能有warning） 1: 不合法的命令行参数或者组合 2: 有1个或者的更多的规则以error的严重程度检查失败 tslint配置12345678910111213141516171819{ // 值是内置配置预设的名字，表示使用内置的预设配置，比如tslint:recommand extends?: string| srting[], // 自定义规则的路径，使用nodejs的模块解析规则 rulesDirectory?: string | string[], // 规则名字和其配置的匹配 // 1. 应用于.ts和.tsx // 2. 每一条规则于一个对象关联 // 2.1 options: 规则的取值 // 2.2 severity: 严重程度，default,error,warning,off rules?: { [name: string]: RuleSetting }, // 和rules的规则格式相同，适用于.js和.jsx文件 // 当值为true时，使用rules相同的配置 jsRules?: any|boolean, defaultSeverity?: \"error\"|\"warning\"|\"off\", // exclude: 一个模式的数组，满足模式的数组不会被检查 // format: string，默认的lint格式 linterOptions?: { exclude?: string[] }} tslint配置文件示例:1234567891011121314151617181920212223{ \"extends\": \"tslint:recommended\", \"rulesDirectory\": [\"path/to/custom/rules/directory/\", \"another/path/\"], \"rules\": { \"max-line-length\": { \"options\": [120] }, \"new-parens\": true, \"no-arg\": true, \"no-bitwise\": true, \"no-conditional-assignment\": true, \"no-consecutive-blank-lines\": false, \"no-console\": { \"severity\": \"warning\", \"options\": [\"debug\", \"info\", \"log\", \"time\", \"timeEnd\", \"trace\"] } }, \"jsRules\": { \"max-line-length\": { \"options\": [120] } }} 配置预置(preset) tslint:recommanded，稳定的typescript编程推荐的规则集合 tslint:latest，继承自recommanded，但是会随着tslint的版本发布而更新，可能会导致前面的检查通过了，但是更新后不通过的情况 tslint:all，以严格模式打开所有的规则。 规则flags可以通过一些flags来控制tslint的开启和关闭等行为。 源文件中的注释可以通过源文件中的注释来控制该文件中的部分tslint的规则的开启和关闭。 / tslint:disable /：在当前文件的剩余部分禁用tslint / tslint:enable /：在当前文件的剩余部分启用tslint / tslint:disable:rule1 rule2… /：在剩余文件中禁用指定的规则 // tslint:disable-next-line // tslint:disable-next-line:rule1 rule2… 示例代码：12345678910111213141516171819function validRange (range: any) { return range.min &lt;= range.middle &amp;&amp; range.middle &lt;= range.max;}/* tslint:disable:object-literal-sort-keys */const range = { min: 5, middle: 10, // TSLint will *not* warn about unsorted keys here max: 20};/* tslint:enable:object-literal-sort-keys */const point = { x: 3, z: 5, // TSLint will warn about unsorted keys here y: 4,}console.log(validRange(range));","link":"/2019/09/01/js/tslint%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"},{"title":"js基础：判断对象类型的多种方法","text":"概述js中有多种方式可以判断对象的类型，每种判断类型的方式都有自己的优缺点。这篇文章文章中我们一共总结了4种方法： instanceof typeof Object.prototype.toString.call constructor 1. instanceof使用方法：obj instanceof Object，左操作数是对象实例，右操作数是构造函数。 instanceof关键字判断的方式如下，假定o是对象实例、c是构造函数：如果o继承自c.prototype，则o instanceof c的值为true。这里的继承可以是直接继承，也可以是间接继承 也就是说，只要某一个构造函数的prototype在某一个实例原型链上，实例 instanceof 构造函数的值就为true。来个图可能比较好理解： 因为Object.prototype和Array.prototype都在原型链上，那么数组实例，例如:123let array = new Array()array instanceof Array // truearray instanceof Object // true instanceof的缺陷 多窗体中（比如嵌套了iframe），每一个窗体有独立的上下文，在一个iframe中的Array实例，在父窗口中使用instanceof Array的结果是false，因为两者上下文独立，两个Array是相互独立的。（解释一下，iframe有同源策略的限制，所以同源的iframe是可以通过dom访问到的，能够拿到iframe里面的对象，当要处理跨文档的类型判断时，instanceof就会出现问题） 只能判断某一个实例是不是某一个构造函数的实例，不能取到具体的类型。如果我要拿到obj的类型字符串例如’object’，instanceof就无能为力了。 2.typeoftypeof是js内置的一个操作符，后面接一个对象的实例或者原始类型，例如:1234567console.log(typeof '123') // stringconsole.log(typeof 123) // numberconsole.log(typeof false) // booleanconsole.log(typeof null) //objectconsole.log(typeof undefined) // undefinedconsole.log(typeof new Array) // objectconsole.log(typeof (()=&gt;'')) // functiontypeof需要注意几个特殊点： typeof null，返回的是object typeof 函数，返回的是function typeof 对象实例，返回的是object，这里注意，除了函数，其他的实例应该都返回的object typeof是内置的操作符，js不像c++，没有提供内置操作符重写的能力，所以我想让typeof [1,2,3]返回’array’可以吗？答案是不可能。 typeof的缺陷typeof主要为了区分对象类型和原生类型，所以只能用于判断一个变量是不是对象或者是不是字符串等。涉及到对象的具体细节，比如这个对象是哪个构造函数的实例，typeof就无能为力了。 需要注意一下typeof的特殊点：主要是null、function 3. Object.prototype.toString.calljs是有类型的概念的，通过Object默认的toString方法，我们可以拿到类型字符串，比如[object Array]。 但是大部分内置对象，都会重写toString方法，所以我们不能直接调用obj.toString方法，需要调用Object.prototype.toString来访问默认的toString方法。 示例:12345console.log(Object.prototype.toString.call(new Date)) // [object Date]console.log(Object.prototype.toString.call(JSON)) // [object JSON]console.log(Object.prototype.toString.call(Math)) // [object Math]console.log(Object.prototype.toString.call(new f)) // [object Object]console.log(Object.prototype.toString.call(f)) // [object Function]我们要拿到一个对象的类型字符串，可以这么写：123function type(obj) { return Object.prototype.toString.call(obj).match(/\\[object (.*)\\]/)[1]} 缺陷对于大部分的内置类型，我们都可以通过Object.prototype.toString获取到类型字符串。 但是我们不能通过获取到自定义构造函数的具体的类型，在上例中，我们获取new f的类型字符串，返回的是[object Object]。解决这个问题，一种方式是重写f.prototype.toString，让其返回[object f]。但是当我们的toString另有他用的时候（参考Date的toString），这种方式就行不通了，而且每个新的构造函数都要重写toString，很麻烦。 另一种方法就是使用下面的constrcutor方案。 4. constructor我们知道，通过原型对象的constructor属性，可以获取到构造函数，我们能不能通过构造函数取到构造函数的名字呢？构造函数的名字也可以代表类型。 ES6里面提供了函数的name属性，我们可以通过func.name这种方式拿到函数名，例如：12function f() {}console.log(f.name) // fES5及以下怎么办呢？我们可以使用，func.toString拿到函数定义的字符串，然后从中取出函数名。示例：1console.log(f.toString().match(/function(.*)\\(.*/)[1].trim()) constructor缺陷有些函数是没有名字的（匿名函数）。。。。1var range = function(x,y){} // 这个函数是没有名字的 5. 总结总结一下： 如果只是想要判断某一个对象是不是某一个构造函数的实例，使用instanceof 如果希望区分内置对象和自定义对象，可以使用Object.prototype.toString.call 如果希望判断是不是基础类型的或者对象，或者是函数，可以使用typeof 如果希望得到自定义对象的具体的类型的字符串，可以使用constructor 每一种方法都有自己的特点，理解了原理之后，可以根据自己的需要，将几种方式组合起来。","link":"/2019/07/14/js/js%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%88%A4%E6%96%AD%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E7%9A%84%E5%A4%9A%E7%A7%8D%E6%96%B9%E6%B3%95/"},{"title":"js基础：防抖、节流、once","text":"12345678910111213141516171819202122232425262728293031323334353637383940414243// 实现方式1function once(element, event, fn) { element.addEventListener(event, function a() { fn.call(this, ...arguments) element.removeEventListener(event, a, false) }, false)}// 实现方式2function once2(obj,fn) { let called = false; return function() { if(!called) { fn.call(obj, ...arguments) called = true } }}function denounce(obj, fn, delay) { let timer = null; return function() { if(!timer) { fn.call(obj, ...arguments) } clearTimeout(timer) timer = setTimeout(() =&gt; { clearTimeout(timer) timer = null console.log(timer) }, delay) }}function throttle(obj, fn, delay) { let timer = null; return function() { if(!timer) { fn.call(obj, ...arguments) timer = setTimeout(() =&gt; { clearTimeout(timer) timer = null },delay) } }}","link":"/2019/07/25/js/js%E5%9F%BA%E7%A1%80%EF%BC%9A%E9%98%B2%E6%8A%96%E3%80%81%E8%8A%82%E6%B5%81%E3%80%81once/"},{"title":"高数1：函数","text":"下面是复习高数时的一些核心笔记： 函数概念 函数三要素：定义域、值域、对应关系。 一个自变量对应一个因变量。 函数的参数表示：$$\\begin{cases} x = x(t),\\ y = y(t), \\end{cases}t\\in[0,2\\pi].$$ 通过引入一个参变量t，来间接的确定x和y之间的函数关系。 极坐标，与直角坐标x,y的关系如下：$$\\begin{cases} x = r\\cos \\theta\\ y = r\\sin \\theta \\end{cases}$$其中r是(x,y)到原点o的距离，$\\theta$是与x轴的夹角大小，将上面的方程代入，函数解析式可以得到极坐标下的表达式。 有界/无界函数，$\\vert f(x)\\vert \\le M,\\forall x \\in X,\\exists M\\gt0$；无界：$\\vert f(x)\\vert &gt; M,\\exists x \\in X$ 单调函数、奇偶函数、周期函数$f(x+T)=f(x)$ 反函数：如果函数映射是一一对应的，例如$f(x)=y$，能够得到唯一的$f(y)=x$，那么逆过来的映射叫做反函数，$x=f^{-1}(y)$。函数与其反函数的图像关于y=x对称。 复合函数：$y=f[\\phi(x)],x\\in X$，记作$f\\circ \\phi$，条件：$f(x)$的定义域包含$\\phi(x)$的值域。 基本初等函数： 常数函数$y=c$ 幂函数$y=x^u$，u&gt;0时一定有意义，u&lt;0可能无意义($x^{-1}=\\frac{1}{x}$) 指数函数$y=a^x,a&gt;0且a\\not ={1}$ 对数函数$y=\\log_ax$ 三角函数$y=\\sin x,y=\\cos x, y=\\tan x$等等 反三角函数$y=\\arcsin x,y=\\arccos x$等等 由基本初等函数经过四则运算和有限次复合并且可用式子表示的函数是初等函数。 极限 $x_1,x_2,…,x_n,…$称为数列，$x_n=f(n)$的表达式称为通项公式。可以看成1…n…到实数R的一种映射。 数列的界：对于数列中的每一个n，都有$x_n\\le A$，则A为数列的上界，$x_b\\ge B$，B为下界。同时有上界和下界的数列称为有界数列。有界数列的另一种定义$\\vert x_n \\vert \\le M$。 数列的极限：当$n\\rightarrow \\infty$时，$x_n=f(n)$的变化趋势，如果$x_n$趋向于某一个数值，那么$x_n$存在极限。数列极限的定义：，如果存在常数a，对于任意给定的$\\epsilon &gt; 0$，总存在正整数N，当n&gt;N时，$\\vert x_n - a\\vert \\lt \\epsilon$都成立，a称为数列的极限，记作：$\\lim \\limits_{n \\rightarrow \\infty} x_n=a$。存在极限的数列称为收敛数列，不存在极限的数列称为发散数列。 数列极限的性质： 唯一性：如果数列的极限存在，那么其极限唯一 有界性：收敛数列必有界。 保序性：$\\lim\\limits_{n\\rightarrow \\infty}x_n = a$，$\\lim\\limits_{n\\rightarrow \\infty} y_n= b，a\\lt b$，那么存在N，对任意的n&gt;N，都有$x_n\\lt y_n$ 保号性：如果$x_n$的极限是a，如果a&gt;0，$x_n$从某个位置开始大于0；如果a&lt;0，如果$x_n$从某个位置开始小于0。反过来可以得到a的符号。 收敛数列和其子数列的关系：数列${ x_n }$收敛于a的充分必要条件是它的任意数列都收敛于同一个极限a 如果数列的两个子数列收敛于不同的极限，那么数列必发散 数列极限的四则运算法则","link":"/2019/06/18/math/%E9%AB%98%E6%95%B01%EF%BC%9A%E5%87%BD%E6%95%B0/"},{"title":"centos7下安装nginx","text":"这篇文章学习如何再centos 7下安装nignx，并分析安装后nginx目录中的各配置文件及作用。 安装nginx1sudo yum install -y nginx 如果找不到，那么就是设置的repo中没有nginx，参考官方安装教程 安装完成后，输入：nginx -v，如果正确输出版本，则nginx安装成功。 centos 7下，nginx的配置文件默认放在/etc/nginx下。如果没有的话，试试下面几个目录：/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx下。 配置文件目录解析","link":"/2019/11/20/nginx/centos7%E4%B8%8B%E5%AE%89%E8%A3%85nginx/"},{"title":"nginx启用gzip和缓存优化","text":"这篇文章给出了如何在nginx中配置gzip和开启缓存，利用缓存对网站进行优化。gzip压缩能将文件压缩到原大小的30%。 开启nginx中开启gzip直接上配置文件片段：123456789101112http { gzip on; # 开启gzip压缩 gzip_min_length 1k; # 使用gzip的最小文件大小 gzip_buffers 4 16k; # gzip缓存 gzip_comp_level 2; # gzip压缩级别，1-10，数字越大效果越好压缩时间越长 gzip_types text/plain application/x-javascript text/css application/xml text/javascript application/x-httpd-php image/jpeg image/gif image/png application/javascript; # 压缩的类型，可以添加 gzip_disable &quot;MSIE [1-6]\\.&quot;; server { location / {} }} 开启缓存1234location ~* \\.(?:jpg|jpeg|png|gif|ico|css|js)$ { root /data; expires 60s;}","link":"/2019/06/09/nginx/nginx%E5%90%AF%E7%94%A8gzip%E5%92%8C%E7%BC%93%E5%AD%98%E4%BC%98%E5%8C%96/"},{"title":"nginx入门教程","text":"这篇教程给出了一个nginx的基本介绍以及描述了nginx可以完成的一些基本任务。这里假定读者的设备中已经安装了nginx。如果没有，请查看安装nginx。这篇教程描述了怎样启动和停止nginx，以及重新读取配置文件，解释配置的结构并且说明怎样设置nginx来服务静态内容，怎样配置nginx作为代理服务器，以及怎样用FastCGI程序连接它。 nginx有一个主进程和若干工作进程。主进程的主要目的是读取和分析配置以及维护工作进程。工作进程处理真实的请求。nginx使用基于事件的模型和依赖OS的机制来高效地在工作进程中分发请求。工作进程的数量定义在配置文件中并且可以固定在一个给定的配置中或者根据可用的CPU核心来自动调整。 nginx和其模块工作的方式决定于配置文件。默认配置文件被命名为nginx.conf并且被放置在目录/usr/local/nginx/conf，/etc/nginx，或者/usr/local/etc/nginx下。 启动、停止以及重载配置运行可执行文件来启动nginx。一旦nginx被启动了，它可以enginx命令使用-s参数来控制。使用下面的语法： nginx -s signal signal可选的值如下： stop – 快速关闭 quit – 优雅地关闭 reload – 重新读取配置文件 reopren – 重新打开日志文件 例如，为了在等待所有的工作进程完成当前请求后关闭nginx进程，下面的执行被执行： nginx -s quit # 这条命令应该由其定nginx的相同用户来执行 在重新读取配置文件的命令被发送给nginx或者nginx重启之前，在配置文件中所作的更改不会被应用。重载配置请执行： nginx -s reload 一旦主进程受到了重载配置的信号，它会检查新配置文件的语法合法性并且会尝试使用新配置。如果成功应用新配置，主进程开启新的工作进程并且向老的工作进程发送信息，请求他们关闭。否则，主进程会回滚改变并且继续使用旧的配置工作。旧的工作进程，受到关闭的命令，停止接受新的连接并且继续服务当前的请求知道所有请求都被处理了。在此之后，就的工作进程退出。 也可以通过Unix tool的帮助。比如kill命令来向nginx进程发送信号。在这个样例中使用一个给定的进程ID，信号被直接发送给进程。nginx主进程的进程id被默认写在目录/usr/local/nginx/logs或者/var/run下的nginx的pid.conf下。 例如，如果主进程ID是1628，为了发送信号使得nginx优雅地退出，执行： kill -s QUIT 1628 为了得到所有正在运行的nginx进程列表，ps命令被使用： ps -ax | grep nginx 关于向nginx发送信号的更多信息，请查看控制nginx 配置文件的结构nginx由模块组成，在配置文件中的指令控制这些模块。指令分为简单指令和块指令。一个简单指令由名字和参数组成，名字和参数中间由空格分离，结尾使用分号（;）。一个块指令和简单指令有一样的结构，但是它使用大括号({})包括一系列的额外指令而不是使用分号。如果一个块指令可以在其中包含其他的块指令，它被称做上下文（例如：events，http，server，location） 被放在配置文件任何上下文之外的指令被当作是主上下文。events和http指令在主上下文中，server在http中，location在server中。 一行中在#后的所有符号都被认为是注释。 12345678910111213http { server { location / { root html; #站点目录 index index.html index.htm; } } server { location /images { } } } 服务静态内容123456789server { location / { root /data/www; } location /images/ { root /data; }} 如上例，我们在访问/或者images时就能够访问到对应的静态资源。例如我们输入： http://localhost:8080/test.png 这会被定位到服务器上的文件： /data/www/test.png 有时候服务器出错了但是不知道是为什么，可以通过查看access log和error log来定位错误。在配置文件中指定了文件位置。 设置代理服务器nginx最常用的使用场景是作为代理服务器，代理服务器是指接收请求，然后将他们转到代理服务器，然后从代理服务器收到内容然后在发送给请求的客户端。 首先，通过一个或者多个server块到nginx的配置文件中定义代理服务器： 12345678server { listen 8080; root /data/up1; location / { }} 这是一个简单的监听8080端口的服务器。root指令被放在了server上下文中，当location没有root指令是该指令会被使用。 使用proxy_pass指令来实现代理功能，如下： 12345server { location / { proxy_pass http://localhost:8080; }} location指定的路径可以是一个正则表达式。","link":"/2019/05/24/nginx/nginx-beginner-s-guide/"},{"title":"基于node.js的命令行工具","text":"基于node.js编写命令行工具是非常方便的，有很多现有的工具和库能够帮助我们实现。接下来我们着手编写一个自己的命令行工具。 依赖分析我们首先要分析我们可以利用哪些第三方的工具。先看看其他的cli工具用了哪些工具，比如vue-cli：12345678910111213141516171819202122232425262728293031323334353637\"dependencies\": { \"@vue/cli-shared-utils\": \"^4.0.0-alpha.2\", \"@vue/cli-ui\": \"^4.0.0-alpha.2\", \"@vue/cli-ui-addon-webpack\": \"^4.0.0-alpha.2\", \"@vue/cli-ui-addon-widgets\": \"^4.0.0-alpha.2\", \"chalk\": \"^2.4.1\", \"cmd-shim\": \"^2.0.2\", \"commander\": \"^2.20.0\", \"debug\": \"^4.1.0\", \"deepmerge\": \"^3.2.0\", \"didyoumean\": \"^1.2.1\", \"download-git-repo\": \"^1.0.2\", \"ejs\": \"^2.6.1\", \"envinfo\": \"^7.2.0\", \"execa\": \"^1.0.0\", \"fs-extra\": \"^7.0.1\", \"globby\": \"^9.2.0\", \"import-global\": \"^0.1.0\", \"inquirer\": \"^6.3.1\", \"isbinaryfile\": \"^4.0.0\", \"javascript-stringify\": \"^1.6.0\", \"js-yaml\": \"^3.13.1\", \"jscodeshift\": \"^0.6.4\", \"lodash.clonedeep\": \"^4.5.0\", \"lru-cache\": \"^5.1.1\", \"minimist\": \"^1.2.0\", \"recast\": \"^0.18.1\", \"request\": \"^2.87.0\", \"request-promise-native\": \"^1.0.7\", \"resolve\": \"^1.10.1\", \"semver\": \"^6.1.0\", \"shortid\": \"^2.2.11\", \"slash\": \"^3.0.0\", \"validate-npm-package-name\": \"^3.0.0\", \"vue-jscodeshift-adapter\": \"^2.0.2\", \"yaml-front-matter\": \"^3.4.1\" }查了一下各种依赖的文档，总结一下我们需要的依赖，下面列出是必须的，其他的根据需要添加： chalk：终端文字样式，我们在命令行中看到的各种颜色的文字可以用这个工具来实现 commander：命令行工具包，可以帮助我们解析命令行参数，输出帮助信息等等 Inquirer.js：交互式的命令行用户接口，主要用于和用户交互 上面的工具可以帮助我们快速的创建命令行工具，但是要让程序能够在命令行中执行，被安装到path中，我们还需要npm提供的bin字段，它能非常简单的帮我们执行命令行脚本，全局安装时，它会将命令安装到PATH中，局部安装时，它会将命令安装到.nodemodules/.bin/下面。123{ \"name\": \"my-program\", \"version\": \"1.2.5\", \"bin\": \"./path/to/program\" }注意：bin指定的程序需要使用第一行必须是’#!/usr/bin/env node’，否则node不会正常执行 模块分析我们完成了依赖分析之后，知道了我们可以用哪些工具来开发命令行程序，接下面我们分析我们的程序模块。","link":"/2019/07/04/node.js/%E5%9F%BA%E4%BA%8Enode-js%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"title":"跨框架、自定义主题的静态博客系统原型概览","text":"现有的热门的静态博客框架是hexo，hexo主题是基于ejs来开发，比较古老，对于2020年的前端开发者来说，更加习惯使用React、Vue等框架来进行静态博客主题的定制，因此想自行开发一套Spa博客系统，主要特性如下： 支持React和Vue两种框架制作主题，由博客系统提供构建引擎。构建引擎插件化，可以自定义构建引擎，可以编译hexo等已有的主题。 主题可以任意切换，相同的博客源文件无需任何修改就可以使用到任意的主题。博客输入形式插件化，可以是markdown或者其他。 提供多种部署形式： nginx部署方式：直接生成html等静态资源用于部署到nginx上 自有静态服务器部署方式：框架自带静态服务器，编译后启动服务器即可 提供docker镜像：自动生成适配上述两种方式的docker镜像，并提供docker镜像的可配置能力 提供cli工具用于主题发布、项目初始化、资源生成、部署等工程化能力 目前设想的系统输入输出模型如下：","link":"/2020/06/15/opensource/%E8%B7%A8%E6%A1%86%E6%9E%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%8E%9F%E5%9E%8B%E6%A6%82%E8%A7%88/"},{"title":"package.json详解","text":"package.json是nodejs的包管理工具npm的配置文件，package.json文件的内容必须是json格式，而不是一个javascript对象。这篇文章详解package.json里面的所有配置属性。 创建package.json文件 npm init 执行上面的命令会出现命令行交互问卷，让你逐个填入各个字段的值。也可以使用下面的命令，使用默认的package.json文件 npm init –yes 定制package.json问卷（！命令行工具常用）如果你希望创建多个package.json文件，定制自己的init问题和域，生成定制的package.json文件，使用下面的步骤： 在home目录添加.npminit.js文件 如果要添加自定义的问题，使用 module.exports = prompt(“what’s your favorite flavor of ice cream, buddy?”, “I LIKE THEM ALL”); 如果要添加自定义的域，使用：1234module.exports = { customField: 'Example custom field', otherCustomField: 'This example field is really cool'} package.json中的字段必须的name和version字段name是npm包的名字，install的时候使用的是name，version是包的版本，这两者是必须的。 默认package.json中的全部字段 name: 当前目录/项目的名字 version: 版本号，always 1.0.0 description: info from the README, or an empty string “” main: 包的入口，always index.js scripts: npm run命令的脚本，by default creates an empty test script keywords: 关键词，empty author: 作者，empty license: ISC bugs: information from the current directory, if present homepage: information from the current directory, if present package.json中的所有字段没有特殊说明的字段取值都是字符串字段名|描述|备注:—:|:—:|:—:name|项目名称|小于等于214个字符，不要和node核心模块重名，不要使用node或者jsversion|项目版本|使用语义化版本，和name一起决定某一个包的特定版本description|项目描述|keywords|关键字|homepage|项目主页|一个url链接bugs|报告bug的url或者email|可以是github的issuelicense|授权协议|选择的开源协议名称author|作者|值可以是一个对象，这个对象包含name、url、emailcontributors|贡献者|一个数组，包含多个作者的信息files|包含的文件|可以是文件、目录或者glob（\\/*, *），默认是*（包含所有文件），当你的包作为依赖时，这个属性决定哪些文件被安装main|项目的入口文件|直接的说，就是其他的用户require你的包的时候，加载哪一个文件，例如require(‘foo’)，那么加载的是foo项目下main字段指定的文件browser|用于浏览器端???|???不太懂有什么用bin|将npm包作为可执行的命令行程序|bin字段可以填入一个对象{‘name’:’path’}或者字符串’./example/program.js’，只有一个字符串的时候命令行程序的名字和项目的name一致；有多个可执行的命令时，使用对象语法。man|使用man命令查看文档时的文档|可以是一个文件或者数组文件。","link":"/2019/07/04/node.js/package-json%E8%AF%A6%E8%A7%A3/"},{"title":"centos7客户端下远程连接linux服务器","text":"在windows常用putty等工具远程连接服务器，那么在linux下用什么工具呢？还有linux下如何远程连接另一台linux服务器上的myql呢？这篇文章学习这两个知识点。 最简单的就是使用ssh，输入命令：1ssh ip地址 -l 用户名如果没有配置公钥，会让用户名对应的密码，密码正确就能正常登陆了。 下面介绍一下ssh工具的使用。 ssh简介centos7远程连接mysql首先要保证自己安装了mysql客户端，输入：1mysql --version mysql客户端自带远程连接的功能，通过-h选项指定host，-u指定登陆的用户名：1mysql -h 39.106.12.37 -u exploit -p输入密码即可远程登陆。 使用图形化的管理工具那centos 7下如何使用workbench等图形化工具来管理mysql呢？ 需要额外安装mysql-workbench，输入如下命令：1yum install -y mysql-workbench 安装完成之后，输入命令mysql-workbench启动，或者在应用程序列表中搜索workbench点击图标启动。","link":"/2019/11/19/os/centos7%E5%AE%A2%E6%88%B7%E7%AB%AF%E4%B8%8B%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5linux%E6%9C%8D%E5%8A%A1%E5%99%A8/"},{"title":"Smarty块度入门","text":"Smarty快速入门smarty官方中文文档：https://www.smarty.net/docs/zh_CN/what.is.smarty.tpl 1. Smarty是什么？Smarty是一个PHP的模板引擎。类似于java的jsp，javascript使用的ejs等。可以向模板文件中嵌入变量，条件控制，循环，模板继承等，帮助html文档的生成。 主要功能将显示逻辑和业务逻辑分开： 这意味着模板可以包含部分仅作为显示用的逻辑代码。 这些显示逻辑如：包含 其他模板，交替设置表格每行的颜色， 把变量转为 大写字母， 循环遍历数组并 显示出来。 Smarty也不是无论如何也强制分离业务和显示逻辑。毕竟Smarty 无法知道谁是谁，所以，会不会把业务逻辑放到模板也是看你怎么处理。 同时，如果你希望在你的模板里没有任何的逻辑代码，你也可以 把模板写成仅剩下文字和变量。 模板文件中可以创建自己的函数和变量修饰器。 条件判断语句会直接使用php解析，所以if后面可以是简单或者较复杂的表达式。 2. Smarty的基本语法smarty的标签都是使用定界符括起来，默认是{}，但是定界符可以被改变。 任何在定界符之外的内容都是静态的 当Smarty读取到这些标签时（{}），会试图解析他们，并且在对应的位置输出结果。（这意味着，smarty会对标签中的逻辑进行处理，然后在标签所在的位置输出处理结果到文档中，比如输出一个变量，会把变量的值输出到文档中的对应位置） 2.1 注释注释时定界符+’*’： 1{* 这时一个注释 *} 多行注释： 123{***************** 注释内容******************} 注释不能嵌套。 2.2 变量模板变量有美元符号$开头，由字母、数组和下划线组成，类似于php的变量。变量可以引用数组索引（数字和非数字均可）、对象的属性和方法等。 配置变量放在两个井号中间（#marks#），或者使用$smarty.config使用。 双大括号中可以执行执行php函数。12345678910{$foo} &lt;-- 显示简单的变量 (非数组/对象){$foo[4]} &lt;-- 在0开始索引的数组中显示第五个元素{$foo.bar} &lt;-- 显示\"bar\"下标指向的数组值，等同于PHP的$foo['bar']{$foo.$bar} &lt;-- 显示以变量$bar值作为下标指向的数组值，等同于PHP的$foo[$bar]{$foo-&gt;bar} &lt;-- 显示对象属性 \"bar\"{$foo-&gt;bar()} &lt;-- 显示对象成员方法\"bar\"的返回{#foo#} &lt;-- 显示变量配置文件内的变量\"foo\"{$smarty.config.foo} &lt;-- 等同于{#foo#}{$foo[bar]} &lt;-- 仅在循环的语法内可用，见{section}{assign var=foo value='baa'}{$foo} &lt;-- 显示\"baa\", 见{assign} 2.3 函数每个smarty标签都可以是显示一个变量或者调用某种类型的函数。 函数调用： {funcname attr1=”val1” attr2=”val2”} 在定界符内包含函数和其属性。 函数包括内置函数 和自定义函数 都是用同样的语法调用。 内置函数是工作在Smarty 内部的函数, 类似 {if}, {section}和 {strip}等等。 它们不需要进行修改或者改变。 自定义函数是通过插件定义的 额外的函数。 你可以任意修改自定义函数，或者创建一个新的函数。 {html_options}就是一个自定义函数的例子。 2.4 属性函数通过属性来定义或者修改他们的行为。属性类似于HTML中的属性。 属性使用： 123456789101112131415161718192021{include file=\"header.tpl\"}{include file=\"header.tpl\" nocache} // 等同于 nocache=true{include file=\"header.tpl\" attrib_name=\"attrib value\"}{include file=$includeFile}{include file=#includeFile# title=\"My Title\"}{assign var=foo value={counter}} // 插件结果{assign var=foo value=substr($bar,2,5)} // PHP函数结果{assign var=foo value=$bar|strlen} // 使用修饰器{assign var=foo value=$buh+$bar|strlen} // 复杂的表达式{html_select_date display_days=true}{mailto address=\"smarty@example.com\"} 2.5 双引号中嵌入变量 Smarty可以识别出在双引号中嵌套的 变量值，这些变量名称必须只包括 字母、数字和下划线。 参见命名规则。 另外，带有其他字符的，如点号（.）或者 $object-&gt;reference形式的变量， 必须用单引号括起来。 Smarty3中允许在双引号中嵌入Smarty的标签并运行。 如果你需要在双引号的变量上使用修饰器、插件或者PHP函数等，这是非常有用的。 1234567891011{func var=\"test $foo test\"} // 识别变量 $foo{func var=\"test $foo_bar test\"} // 识别变量 $foo_bar{func var=\"test `$foo[0]` test\"} // 识别变量 $foo[0]{func var=\"test `$foo[bar]` test\"} // 识别变量 $foo[bar]{func var=\"test $foo.bar test\"} // 识别变量 $foo (不是 $foo.bar){func var=\"test `$foo.bar` test\"} // 识别变量 $foo.bar{func var=\"test `$foo.bar` test\"|escape} // 引号外的修饰器!{func var=\"test {$foo|escape} test\"} // 引号内的修饰器!{func var=\"test {time()} test\"} // PHP函数结果{func var=\"test {counter} test\"} // 插件的结果{func var=\"variable foo is {if !$foo}not {/if} defined\"} // Smarty区块函数 2.6 数学计算变量值内可以直接进行数学计算 12345678910111213{$foo+1}{$foo*$bar}{* 更复杂的例子 *}{$foo-&gt;bar-$bar[1]*$baz-&gt;foo-&gt;bar()-3*7}{if ($foo+$bar.test%$baz*134232+10+$b+10)}{$foo|truncate:\"`$fooTruncCount/$barTruncFactor-1`\"}{assign var=\"foo\" value=\"`$foo+$bar`\"} 2.7 避免smarty解析 当{}左右两边都是空格的时候，将会被自动忽略解析。 使用{literal}…{/literal}可以让块中间的内容忽略解析。","link":"/2020/06/14/php/Smarty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"vue基础：vue-router使用","text":"简介vue-router时vue.js的官方路由，与vue核心深度集成，提供了特性： 嵌套路由/视图匹配 模块化、基于组件的路由配置 路由参数、query、通配符 vue过渡系统驱动的视图过渡效果 细密度的导航控制 自动激活CSS class的链接 HTML5 history模式或者hash模式，回退IE9方案 定制scroll bar的行为 路由原理浅析vue.js只是一个响应式的框架，通过vue模板配合响应式系统，可以创建数据驱动的单页网站；通过改变数据，就可以改变视图。但是这只是单页程序，点击了页面的一个按钮，可能切换成了另一个界面，这实际上只是vue的组件在切换，Vue会根据数据来改变DOM；如果有多个界面切换，我们需要记住当前是哪个界面，然后判断需要向哪一个界面切换，然后切换不同的组件实现页面切换。但是这样需要在组件中记录界面状态，而且刷新浏览器后一切归0。 这时候我们自然而然就会想将组件切换这一部分能力提取出来，不然每个程序都需要单独编写切换代码。不同的界面我们习惯用不同的路由来表示，我们是不是可以将路由和组件切换结合起来呢？建立路由到组件的映射关系，我们就可以实现根据路由来切换组件，以实现不同界面的切换。但是我们这里的路由和传统浏览器路由是有区别的，因为Vue应用是单页应用，浏览器只会返回一份HTML、CSS、JS代码，其他的所有都交给js处理。所以我们的路由在改变的时候，不能触发浏览器更新——这样会导致当前网站的一切状态清零。 这种单页路由有两种解决方案，一种是将路由放在hash种，因为hash不会导致浏览器刷新重新从服务器获取数据；另一种是html History API，因为history.pushStateAPI会改变浏览器路由，但是不会刷新浏览器；html History API需要而外的配置，因为当用户手动刷新浏览器的时候，传给服务器的是新的路由，这时候需要web服务器兼容各种路由的情况（可以直接返回一个同一个文档）。 前面提到通过建立路由和组件的映射关系，可以实现根据路由来切换组件实现页面调转，那么切换的是哪一个组件呢？Vue Router提供了&lt;router-view&gt;组件，&lt;router-view&gt;会自动匹配路由的层级，并将路由对应的组件渲染到&lt;router-view&gt;的位置。当路由改变时，在&lt;router-view&gt;的基础上切换组件。 映射关系通过初始化router的时候建立，通过配置对象确定路由和组件的关系以及嵌套关系。","link":"/2019/07/10/vue/vue%E5%9F%BA%E7%A1%80%EF%BC%9Avue-router%E4%BD%BF%E7%94%A8/"},{"title":"Vue基础：typescript支持","text":"这篇文章介绍了如何在vue项目使用typescript。vue官方为Vue core、Vue Router、Vuex提供了相应的声明文件。Vue项目的根目录可以使用tsconfig.json来配置typescript编译器的行为，通过vue-cli3可以直接生成启用typescript的项目。最后简要介绍Vue中typescript的基本用法，可以使用基于类的API，也可以使用Vue.component或者Vue.extend。 推荐配置tsconfig.json123456\"compilerOptions\": { \"target\": \"es5\", // 与vue的浏览器支持保持一致 \"strict\": true, \"module\": \"es2015\", \"moduleResolution\": \"node\"}需要引入strict: true（或者至少noImplicitThis: true）以利用组件方法中this的类型检查，否则它始终会被看作any类型。 开发工具链工程创建Vue CLI 3可以使用Typescript生成新工程。创建方式： npm install –global @vue/clivue create my-project-name 在cli中可以选择typescript，脚手架会自动生成支持typescript的项目文件 编辑器支持vscode中有Vetur插件，支持vue的SFC(单文件组件)。 基本用法要让TypeScript正确推断Vue组件选项中的类型，需要使用Vue.component或Vue.extend定义组件： 123456789import Vue from 'vue'const Component = Vue.extend({ // 类型推断已启用})const Component = { // 这里不会有类型推断 // 因为typescript不能确认这是Vue组件的选项} 基于类的Vue组件Vue官方维护的vue-class-component装饰器来使用基于类的API，vue-class-component和vue-property-decorator在单独的文章中介绍。 1234567891011121314151617import Vue from 'vue'import Component from 'vue-class-component'// @Component修饰符注明了此类（MyComponent）为一个Vue组件@Component({ // 所有的组件选项都可以放到这里，比如components等 template: '&lt;button @click=\"onclick\"&gt;Click!&lt;/button&gt;'}) // 注解是修饰这个MyComponent类的export default class MyComponent extends Vue { // 初始数据可以直接声明为实例的属性 message: string = 'Hello' // 组件方法直接声明成实例的方法 onClick(): void { window.alert(this.message) }} 增强类型以配合插件使用vue插件可以扩展vue的全局/实例属性，但是这些扩充的实例属性在Vue官方的类型说明里面并没有。如果我们需要自己制作typescript插件，就需要自己来扩展类型声明。 typescript有一个特性来补充现有的类型，叫做模块补充。 例如，声明一个类型为string的实例属性$myProperty：12345678910// 1. 确保在声明补充的类型之前导入vueimport Vue from 'vue'// 2. 定制一个文件，设置你想要补充的类型，在types/vue.d.ts里有Vue有构造函数类型declare module 'vue/types/vue' { // 3. 声明为Vue补充的东西 interface Vue { $myProperty: string }} 在项目中包含了上述作为声明文件的代码之后（像my-property.d.ts），就可以在vue实例上使用$myProperty了。 12var vm = new Vue()console.log(vm.$myProperty) // 将顺利通过编译 也可以声明额外的属性和组件选项:1234567891011121314import Vue from 'vue'declare module 'vue/types/vue' { // 可以使用VueConstructor接口来声明全局属性 interface VueConstructor { $myGlobal: string }}declare module 'vue/types/options' { interface ComponentOptions&lt;V extends Vue&gt; { myOption?: string }} 标注返回值typescript可能在推断某个方法的类型时存在困难。因此，可能需要在render或computed里的方法上标注返回值。 返回类型一般来说在typescript中可以自动推导，例如a(){return 1;}，a的返回类型会被推导为number，当不自动推断时，需要手动：a():number {return 1;}12345678910111213141516171819202122232425import Vue, { VNode } from 'vue'const Component = Vue.extend({ data () { return { msg: 'Hello' } }, methods: { // 需要标注有 `this` 参与运算的返回值类型 greet (): string { return this.msg + ' world' } }, computed: { // 需要标注 greeting(): string { return this.greet() + '!' } }, // `createElement` 是可推导的，但是 `render` 需要返回值类型 render (createElement): VNode { return createElement('div', this.greeting) }})如果发现类型推导或者成员补齐不工作了，使用–noImplicitAny选项会帮助找到这些未标注的方法。","link":"/2019/09/03/vue/Vue%E5%9F%BA%E7%A1%80%EF%BC%9Atypescript%E6%94%AF%E6%8C%81/"},{"title":"Vue基础：vue-class-component","text":"vue-class-component是为Vue组件提供的注解支持，能够通过注解的方式来来声明组件以及组件的选项等。这篇文章主要学习如何使用vue-class-component，以及vue-class-component和vue2.x的使用对比。 vue-class-component基础vue-class-component使用的是ECMAScript stage 1 decorators，需要在typescript中启用--experimentalDecorators标识。vue-cli3创建的项目下，可以直接使用tsconfig.json来配置typescript编译器。 注意： methods可以直接作为类的方法声明 计算属性可以作为类的存储器声明 data可以作为类的属性直接声明 data、render以及所有的Vue声明周期钩子可以直接作为类的成员方法声明，但是不能直接通过实例调用。 对于所有的其他选项，将它们传给装饰器函数 示例：12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;template&gt; &lt;div&gt; &lt;input v-model=\"msg\"&gt; &lt;p&gt;prop: {{propMessage}}&lt;/p&gt; &lt;p&gt;msg: {{msg}}&lt;/p&gt; &lt;p&gt;helloMsg: {{helloMsg}}&lt;/p&gt; &lt;p&gt;computed msg: {{computedMsg}}&lt;/p&gt; &lt;button @click=\"greet\"&gt;Greet&lt;/button&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import Vue from 'vue'import Component from 'vue-class-component'@Component({ props: { propMessage: String }})export default class App extends Vue { // initial data msg = 123 // use prop values for initial data helloMsg = 'Hello, ' + this.propMessage // lifecycle hook mounted () { this.greet() } // computed get computedMsg () { return 'computed ' + this.msg } // method greet () { alert('greeting: ' + this.msg) }}&lt;/script&gt;如上例，类的所有成员方法，将会被视为Vue2.x中methods中的方法，比如greet()；类的所有属性，将作为data的属性加入响应式系统，比如mgs = 123；类中的生命周期钩子、render、data函数也直接可以直接用类的函数声明（原先是在Vue构造函数的选项中声明）；计算属性通过get/set来声明。 如果不想向@Component传参数，可以通过@prop和@watch等来声明prop和监听属性，但是这些decorators在vue-property-decorators中，需要单独引入，后文会学习这一部分的知识，请继续向下看～！ mixinvue-class-component提供了mixins帮助函数来使用mixins，通过使用mixins函数，可以指明mixins类型并且通过组件形式继承它们。例如：123456789// mixin.jsimport Vue from 'vue'import Component from 'vue-class-component'// You can declare a mixin as the same style as components.@Componentexport default class MyMixin extends Vue { mixinValue = 'Hello'}使用mixin：1234567891011import Component, { mixins } from 'vue-class-component'import MyMixin from './mixin.js'// Use `mixins` helper function instead of `Vue`.// `mixins` can receive any number of arguments.@Componentexport class MyComp extends mixins(MyMixin) { created () { console.log(this.mixinValue) // -&gt; Hello }} 知识回顾：mixins翻译为’混入’，以及就是一个对象将已有的选项和方法等合并进另一个对象中，在vue2.x中mixin是一个js对象，通过Vue的mixins选项传进去（mixins选项接收一个对象数组），mixin如何和被混入的对象中有属性冲突，会合并，不能合并的以被混入的优先，钩子函数会被合成一个数组，均会被调用；通过Vue.mixin()可以定义全局混入；通过Vue.config.optionMergeStragegies=func(toVal,formVal)可以自定义合并逻辑。 在typescript中mixin就是一个组件，在另一个组件中使用mixin的方式是：extends mixins(MyMixin)，通过mixins函数，将MyMixin组件的内容混入到声明的组件中。 创建自定义装饰器可以通过创建自定义的装饰器来继承vue-class-component的能力。vue-class-component提供了createDecorator来创建自定义的装饰器。createDecorator接收一个回调函数参数作为第一个参数，回调函数哦于三个参数： options：Vue组件的选项对象。改变这个对象将会影响对应的组件 key：decorator装饰器应用的属性或者方法 parameterIndex：如果自定义装饰器用作参数，那这个选项表示第几个参数 示例：123456789101112131415161718// decorators.jsimport { createDecorator } from 'vue-class-component'export const NoCache = createDecorator((options, key) =&gt; { // component options should be passed to the callback // and update for the options object affect the component options.computed[key].cache = false})import { NoCache } from './decorators'@Componentclass MyComp extends Vue { // the computed property will not be cached @NoCache get random () { return Math.random() }} 提示：vue-property-decorator就是通过这种方式实现的，我们也可以通过这种方式实现功能更多的装饰器 添加自定义的钩子函数如果使用Vue Router一类的插件，可能会希望类组件识别其提供的钩子函数；通过Component.registerHooks允许你注册这样的钩子：123456789101112131415161718192021222324252627// class-component-hooks.jsimport Component from 'vue-class-component'// Register the router hooks with their namesComponent.registerHooks([ 'beforeRouteEnter', 'beforeRouteLeave', 'beforeRouteUpdate' // for vue-router 2.2+])// MyComp.jsimport Vue from 'vue'import Component from 'vue-class-component'@Componentclass MyComp extends Vue { // The class component now treats beforeRouteEnter // and beforeRouteLeave as Vue Router hooks beforeRouteEnter (to, from, next) { console.log('beforeRouteEnter') next() // needs to be called to confirm the navigation } beforeRouteLeave (to, from, next) { console.log('beforeRouteLeave') next() // needs to be called to confirm the navigation }}可以在组件定义前调用Component.registerHooks方法。 知识回顾：Vue Router的钩子函数 钩子在Router中也称为守卫，钩子函数会在调转到页面前或者调转到页面后被调用；Vue Router中的钩子有全局前置守卫、全局解析守卫、全局后置守卫、路由独享的的守卫、组件内的守卫。router.beforeEach注册全局前置守卫；router.beforeResolve注册全局解析守卫，解析守卫在组件内守卫和异步路由组件被解析值后调用；router.afterEach注册全局后置钩子；在路由配置上定义beforeEnter定义路由独享的守卫（与path、component等同级）；在组件选项对象中添加与template同级的钩子函数（beforeRouterEnter、beforeRouterUpdate、beforeRouterLeave）注册组件内的守卫。 类属性的警示 property中的this值如果定义了一个箭头函数并赋值给类的属性，那么箭头函数中的this不能正确的被访问到。正确的方式是直接定义一个类的方法。 undefined不是响应式的undefined作为初始值的属性不是响应式的。正确方式是使用null来初始化而不是undefined。 vue-property-decorator基础前面提到了，除了属性，方法、钩子函数、render和data函数、计算属性以外，其他的Vue选项都通过Component注解函数的参数传过去。但是如果想对其他的选项也使用注解的方式，可以使用vue-property-component来实现；例如@Prop、@Watch等等，有以下注解： @Prop：@Prop(options:(PropOptions | Constructor[] | Constructor) = {})，options可以是Props的配置对象，或者类型(String，Number等) @PropSync：@PropSync(propName: string, options: (PropOptions | Constructor[] | Constructor) = {}) decorator，123456import { Vue, Component, PropSync } from 'vue-property-decorator'@Componentexport default class YourComponent extends Vue { @PropSync('name', { type: String }) syncedName!: string} 等价于1234567891011121314151617export default { props: { name: { type: String } }, computed: { syncedName: { get() { return this.name }, set(value) { this.$emit('update:name', value) } } }} @Model @Watch @Provide @Inject @ProvideReactive @InjectReactive @Emit：@Emit(event: string)，Emit用于方法，该方法返回值和原有参数会依次作为this.$emit的参数，并在被注解的方法最后调用this.$emit。意味着方法被调用时，会向父组件发送一个事件 @Ref @Component（和vue-class-component提供的相同） 和一个函数： Mixins（和vue-class-component提供的mixins相同） 总结vue-class-component只提供了@Component、mixins、createDecorator和Component.registerHook等方法。vue-property-decorator是对vue-class-component的补充，继承了其所有能力，并且补充了@Prop等额外的注解。当我们使用的时候，只需要import ‘vue-property-decorator’。","link":"/2019/09/03/vue/Vue%E5%9F%BA%E7%A1%80%EF%BC%9Avue-class-component/"},{"title":"vue基础：tips","text":"下面都是使用vue的时候记录下来的小细节 直接操作dom 如果直接删除或者替换dom（文本内容也是），响应式绑定会失效，应该虚拟dom对应的真实dom已经不存在了，当重新使用数据渲染组件时（重新渲染会根据数据创建新的dom并绑定）才恢复响应式（例如v-if切换）。 操作属性，例如class、style，会直接对dom生效，但是当数据改变时，dom会被会被数据修改，直接通过dom设置的属性将会丢失","link":"/2019/07/06/vue/vue%E5%9F%BA%E7%A1%80%EF%BC%9Atips/"},{"title":"vue基础：vue-cli","text":"这篇文章是vue-cli文档阅读的笔记，是一个总结加上自己的理解，vue-cli的详情请看官方文档 Vue CLI是一个用于Vue.js快速开发的完整系统，提供了： 通过@vue/cli提供交互式的项目脚手架 通过@vue/cli+@vue/cli-service-global的零配置快速原型 一个运行时依赖（@vue/cli-service）： 可升级 在webpack之上构建，有合理的默认值 通过项目内的配置文件实现可配置 通过插件扩展 大量的官方插件，集成了前端生态中最好的工具 可视化的用户界面创建和管理Vue.js项目 vue cli保证了各种各样的构建工具平滑地一起工作，通过合理的默认值，你可以专注于书写业务代码而不是花费数天在项目的配置上。 系统中的组件Vue cli主要分成下面三个部分： CLICLI（@vue/cli）是一个全局安装的npm包，在终端中提供了vue命令。它提供了通过vue create快速搭建项目的能力，或者通过vue serve立即原型化新的idea。通过vue ui可以使用可视化的界面管理项目。 CLI Service@vue/cli-service是一个开发环境依赖。其安装在每一个通过@vue/cli创建的项目中。 CLI Service在webpack和webpack-dev-server之上构建。包括了： 加载其他CLI插件的核心服务 为大部分apps优化的内部webpack配置 CLI 插件CLI插件是提供了可选特性的npm包，比如Babel/TypeScript编译，ESLint集成，单元测试，以及端到端测试。@vue/cli-plugin-(内置插件)；@vue/vue-cli-plugin(社区插件)； 在项目中运行vue-cli-service时，它会自动解析和加载package.json中的CLI插件 安装 npm install -g @vue/cli 基础这一部分总结了总结了vue-cli的基础，主要内容包括快速原型开发、创建项目、插件和预设以及CLI Service 快速原型开发有时候我们只想运行和调试单个vue文件，这时候要起一个单独的vue项目吗？为了跑一个文件起一个项目也太麻烦了，所以vue-cli提供了快速原型开发，作用是快速运行单个vue文件。通过vue serve和vue build命令就可以做到这一点。 使用该功能需要额外的依赖：1npm install -g @vue/cli-service-global 使用vue serve --help或者vue build --help获取参数帮助。 通过：12vue serve myvue.vue # 开发环境vue build myvue.vue # 构建就可以运行单个文件。 快速原型开发中也可以使用index.html、postcss等额外的功能，只要给出正确的配置文件 创建项目1vue create hello-world 输入之后会弹出一些选项，选择后cli即可正确生成项目。 初始化的参数（是否选择postcss等）以json格式存在~/.vuerc文件中 使用GUI创建项目1vue ui 会起一个本地网站服务，进入该网站可对当前项目进行可视化的管理。可以新建项目，管理配置、依赖等等。 vue initvue cli 3已经废弃了vue init，使用vue create，如果要使用vue init的功能，执行：12npm install -g @vue/cli-initvue init webpack myproject","link":"/2019/07/03/vue/vue%E5%9F%BA%E7%A1%80%EF%BC%9Avue-cli/"},{"title":"vue实战：popover组件","text":"业务需要，我们需要一个vue的弹出类组件容器，能够自动根据给定的元素定位到视口的固定位置。popper.js的功能比较多，我们需要的功能比较少，这里实现了popper.js的简化版本popsim.js： 仅提供基于position:fixed的实现，不考虑嵌套的scroll的情形 popsim.js不提供任何dom操作，仅作为简单的定位引擎，根据给定的reference进行定位（上下左右，可选位移参数），计算出元素需要显示在相对视口的哪一个位置（左右不溢出边界，当到达边界时（左右边界），自动定位（自身和箭头）。 当滚轮滚动时，会重新计算left和top值，对滚轮进行限流 提供一个vue的混入层，将布局引擎中的功能添加到任何一个vue组件实例中 基于vue的混入层实现popover，渐进式的过渡效果 基于popover实现内部的功能，例如弹出菜单，文字提示…","link":"/2019/07/06/vue/vue%E5%AE%9E%E6%88%98%EF%BC%9Apopover%E7%BB%84%E4%BB%B6/"},{"title":"vue基础：官方文档要点","text":"最近实习中又用到了Vue，过了一遍官方文档复习一下，感觉又有很多收获。记录一下要点。 vue实例每一个Vue应用都是通过用Vue函数创建一个新的Vue示例开始的：1234// vm代表（ViewModel）var vm = new Vue({ // 选项})一个Vue应用由一个通过new Vue创建的根Vue实例，以及可选的嵌套的、可复用的组件树组成。所有的Vue组件都是Vue实例，并且接受相同的选项对象（根实例特有的选项除外） 数据与方法Vue实例创建的时候会将选项中的data对象的所有属性加入到Vue的响应式系统中。选项中data对象会被浅拷贝到Vue实例（后文用vm表示Vue实例）的_data属性上，会拦截vm和data上对应属性的访问，所以改变vm属性对应的值会影响到data，改data也会影响到vm。细节请参考另一篇博客从Vue源码解读Vue实例的初始化过程 实例被创建时传的data参数中的属性的才是响应式的，新增的属性不是。 实例生命周期钩子 Vue实例初始化过程中会调用的一些钩子函数。 钩子函数不要用箭头函数，因为this的问题。 在单文件组件中，模板编译会被提前。 模板语法Vue.js的模板允许开发者声明式地将DOM绑定至底层Vue实例的数据。 底层模板会被编译成渲染函数。 插值 数据绑定语法:{{}}（Mustache)，绑定的数据变化时，DOM会自动更新。 1&lt;span&gt;Message: {{ msg }} &lt;/span&gt; 1. v-once指令可以一次性插值，数据改变不会更新DOM。 2. {{}}会将数据解释成文本，要插入html，使用v-html=\"html code\"。v-html不能复合局部模板，只能是html。 3. {{}}不能作用再HTML属性上，需要用v-bind指令: 1&lt;div v-bind:id=\"dynamicId\"&gt;&lt;/div&gt; 4. {{}}支持支持完整的javascript表达式（只能是单个表达式）。 5. 插值中用到的**单个**表达式（如{{}}插值，指令参数，指令值），**这些表达式会在Vue实例的数据作用域下作为javascript被解析，意思就是说，表达式中使用的变量，会被解析成对应vm实例的属性。全局变量只能访问Math、Date等，不应该访问自定义的全局变量。** 指令指令是带有v-前缀的特殊特性。指令特性的值是单个javascript表达式（v-for是例外情况）。指令的职责是，当表达式的值改变时，将其连带影响，响应式地作用于DOM。 参数：能够接受一个参数，在指令名称后面以冒号表示，然后再接等于号表示指令特性的值。语法如下：12&lt;a v-bind:href=\"url\"&gt;...&lt;/a&gt;&lt;a v-on:click=\"doSomething\"&gt;&lt;/a&gt; 动态参数：从2.6.0起，可以用[]括起来的javascript表达式作为一个指令的参数，下面的例子会对attributeName求值，结果作为指令的参数： 12&lt;a v-bind:[attributeName]=\"url\"&gt;...&lt;/a&gt;&lt;a v-on:[eventName]=\"doSomething\"&gt;...&lt;/a&gt; 约束： 动态参数的求值结果期望是一个字符串，特殊结果可以是null，null可以被显性用于溢出绑定。非字符串结果会触发警告。 动态参数表达式有一些语法约束，因为某些字符，例如空格和引号，放在HTML特性名里是无效的。在html文件中使用动态参数时，如果参数表达式比较复杂，可以使用计算属性代替 修饰符：修饰符是以.指明的特殊后缀，指出一个指令应该以特殊方式绑定。例如.prevent修饰符告诉v-on指令对于触发的事件调用event.preventDefault(): 1&lt;form v-on:submit.prevent=\"onSubmit\"&gt;...&lt;/form&gt; 缩写v-bind和v-on提供了简写：12&lt;a :href=\"url\"&gt;&lt;/a&gt;&lt;a @click=\"doSomething\"&gt;&lt;/a&gt; 计算属性和侦听器计算属性在模板内可以使用任意的表达式，但是这些表达式应该只用于简单运算。对于复杂的逻辑，应该使用计算属性 示例：12345678910111213141516171819&lt;div id=\"example\"&gt; &lt;p&gt;Original message: \"{{ message }}\"&lt;/p&gt; &lt;p&gt;Computed reversed message: {{ reversedMessage }}&lt;/p&gt;&lt;/div&gt;&lt;script src=\"./vue.min.js\"&gt;&lt;/script&gt;&lt;script&gt; var vm = new Vue({ el: '#example', data: { message: 'Hello' }, computed: { reversedMessage: function() { return this.message.split('').reverse().join('') // 先转成数组，string没有reverse方法 } } })&lt;/script&gt;示例中我们声明了一个计算属性reverseMessage。我们提供的函数将用作属性vm.reversedMessage的getter函数。123console.log(vm.message)vm.message = 'Goodbye'console.log(vm.reversedMessage) 计算属性可以像data中的属性一样直接在模板中使用。vue可以知道计算属性中所依赖的属性，并收集到其依赖，当依赖的属性发生变化的时后，计算属性会重新计算 计算属性vs方法 计算属性是基于响应式依赖进行缓存的，只要依赖变化才会重新求值，方法每次调用都会进行求值。如果不希望有缓存（仅仅只是计算而不依赖响应式属性，希望实时更新的时后），使用方法代替计算属性。 计算属性vs侦听属性 Vue提供了一种更通用的方式来观察和响应Vue实例上的数据变动：侦听属性。侦听属性可以观察到vm属性（只能是在data选项中定义的属性）的变化，并调用回调函数。 123456789101112131415161718192021 &lt;div id=\"demo\"&gt;{{ fullName }}&lt;/div&gt;&lt;script&gt; var vm = new Vue({ el: '#demo', data: { firstName: 'Foo', lastName: 'Bar', fullName: 'Foo Bar' }, watch: { firstName: function(val) { // 当firstName变化时，调用该回调函数，传入新的值作为参数 this.fullName = val + \" \" + this.lastName; }, lastName: function(val) { this.fullName = this.firstName + ' ' + val; }, noName: function(val) { // noName没有定义，使用回报错 this.fullName = this.fullName + 'noName'; } } }) 计算属性的setter 计算属性默认值有getter，不过在需要的时候可以提供一个setter： 12345678910computed: { reversedMessage: { get: function() { return this.message.split('').reverse().join('') // 先转成数组，string没有reverse方法 }, set: function(newValue) { this.message = newValue; } } } 侦听器Vue通过watch选项可以监听对应数据的变化，当vm上的实例属性变化时，调用watch选项中指定的回调函数。当需要在数据变化时执行异步或者开销较大的操作时，这个方式时最有用的。例如，在输入框输入值的时候，希望向服务器发送一个请求，获取动态的值，这时候就可以使用侦听器。 Class和Style绑定操作元素的class列表和内联样式是数据绑定的一个常见需求。因为它们都是属性，所以哦我们可以用v-bind来处理他们：只需要通过表达式计算出字符串结果。不过字符串拼接麻烦且易错。在v-bind用于class和style时，Vue.js做了专门的增强。表达式结果的类型除了字符串以外，还可以是对象或者数组。 绑定html class对象语法动态切换class，当isActive是真时，元素添加active类：1&lt;div class=\"static\" v-bind:class=\"{active: isActive, 'text-danger': hasError}\"&gt;&lt;/div&gt;对象中可以有多个class，可以与普通的class共存。","link":"/2019/06/18/vue/vue%E5%9F%BA%E7%A1%80%EF%BC%9A%E5%AE%98%E6%96%B9%E6%96%87%E6%A1%A3%E8%A6%81%E7%82%B9/"},{"title":"vue实战：博客后台——简介","text":"预期成果这一系列文章中，我们使用vue+typescript+postcss+scss+browserlist+ssr+unit test等技术搭建一个简单的博客后台网站。主要目的是为了练手，熟悉前端工具和vue框架的结合使用，同时为静态博客网站添加一个编辑后台。 预期中还会使用docker、hadoop等后端技术实现集群部署，分别部署到腾讯云服务器、阿里云服务器、digital ocean服务器；同时开发发布上线工具，实现一键发布到机器集群上。 我们的主要目的是掌握vue、typescript、postcss、ssr等技术的基础和应用，在开发过程中我们会记录相关的知识点。 进阶技术我们希望能够学习了解集群部署的基本原理和应用，从而在整个互联网服务架构上有更加深入的了解。 这个博客后台的主要功能是能够实现markdown博客的在线编辑，存储和发布。在静态博客系统的基础上能够浏览博客目录、新建博客、删除博客、编辑博客、调整博客目录。后台有登陆功能，未登陆的时候可以浏览目录，但是不能进行任何的编辑操作，当要进行编辑的时候，如果未登陆，则会弹出登陆提示，登陆后才能编辑，同时登陆授权要防御csrf，登陆在一段时间后会失效，失效后需要重新登陆。 后端主要使用的框架是jweb，在开发的过程中，我们会对jweb的核心功能进行改进，优化代码结构，同时丰富并提供更多的功能。 总体来说，这是一个涉及到前端、后端、框架开发、分布式部署的方方面面的实现的练手项目，主要目的是学习，开发的成果是一个hexo静态博客后台编辑系统。 进阶选项进一步预计提供如下的功能： 开发与后台编辑相对应的博客展示页面，做一个轻量级的静态博客系统。细节二期设计，暂时先用hexo。静态博客使用vue搭建。 xss的防御 可以记录网站的pv、uv，点击 分析编辑时间、发布时间、分类、标签，以可视化图表的形式来展现出来。 开发组件 scroll：提供滚动功能，支持以动画的方式滚动到页面的任何位置 menu：菜单组件，支持横向和竖向，支持路由调转，支持自定义菜单项内容 popover：弹出组件，定位引擎层，暴露出设置位置和样式的api。用于tooltip、model、message等等的一系列交互弹出和调用弹出。 markdown：markdown编辑器组件，支持编辑、预览、快捷键、快捷图表。 tree：树形组件、以树型的结构来展示层次型的数据。 开发进度 markdown组件 实现可视化编辑和预览（done） 实现快捷键和图标点击插入 RangeSelection API封装 获取/删除选中区域的文本 插入指定内容（done） 获取/设置光标位置（done） CopyPaste API封装（done） WebWorker API封装 自定义事件 change，内容改变 compile-start，编译开始 compile-end，编译结束 样式可配置 tree组件 目录展开折叠 右键单击弹出菜单 复制/粘贴 重命名 删除 新建 事件 click-left，鼠标左健点击 click-rigt，鼠标右键点击 item-click，点击tree的子节点 collapse，展开/收起 样式可配置 前端防抖同步输入的内容到服务器，websocket 服务器同步文件到多台机器 分布式部署 依赖的库 marked：轻量级markdown编译 github-markdown.css：github markdown样式css normalize.css：统一各浏览器下默认的样式 hightlight.js：代码高亮，内包含各种样式的css ：latex公式支持 font-awesome：图标支持","link":"/2019/08/12/vue/vue%E5%AE%9E%E6%88%98%EF%BC%9A%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E2%80%94%E2%80%94%E7%AE%80%E4%BB%8B/"},{"title":"vue实战：ts踩坑记录","text":"这篇文章记录了使用ts开发vue时遇到的一些问题和解决方案。内容包括如何使用ts开发vue，用到了哪些库以及在开发时遇到的一些问题。 踩坑记录@Component@Component是vue-class-component提供的ts注解，在vue文件中必须使用@Component来将class声明成vue组件，不然成员方法中取到的this就是null。 @Prop传值问题当类成员没有初始化器，并且没有显式的在constructor中初始化时，该类成员不会被定义在示例上。此时编译器会报错，但是Prop又不能初始化，初始化也会报错。两种方式解决这个问题。一个是添加编译选项--strictPropertyInitialization，另一个是在将成员类型加上undefined类型，例如：1@Prop(String) private readonly placeholder: string | undefined vue-ts的底层原理 vue是如何通过webpack构建的？经历了怎么样的过程？ vue的runtime和compiler是如何协同工作的？ ts.vue是如何编译成vue再编译成html、css的，中间经历了哪些过程？ vue router的工作原理是怎么样的？ vuex的工作原理是怎么样的？","link":"/2019/09/06/vue/vue%E5%AE%9E%E6%88%98%EF%BC%9Ats%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"title":"webpack实战：打造同时编译react和vue的构建引擎","text":"vue-cli-service和create-react-app都是单独针对vue或者react的初始化、开发和构建工具，现在想开发一套系统，既可以编译Vue的项目，又可以编译React的项目，提供插件化的机制控制构建过程。不同框架经过引擎后编译得到类似的静态资源结果，引擎提供多种内置的配置，例如sass等，可以通过配置项覆盖默认或者关闭默认配置或者在初始化的时候选择需要的能力和内置主题。 整个系统的构建模型如下：","link":"/2020/06/15/webpack/webpack%E5%AE%9E%E6%88%98%EF%BC%9A%E6%89%93%E9%80%A0%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%91react%E5%92%8Cvue%E7%9A%84%E6%9E%84%E5%BB%BA%E5%BC%95%E6%93%8E/"},{"title":"webpack系列1：webpack概念","text":"","link":"/2019/07/14/webpack/webpack%E7%B3%BB%E5%88%971%EF%BC%9Awebpack%E6%A6%82%E5%BF%B5/"},{"title":"树莓派3.5寸显示器套装安装操作系统","text":"买了一个3.5寸电阻触摸显示屏的树莓派套装（树莓派4B），打算用于操作系统和linux系统的开发，以及计算机组成等方面的学习。新买回来的树莓派没有安装操作系统，不知道能不能用，先装个系统看看。 因为买的是3.5寸屏的套装，又没有mini HDMI的线，就只能选择带LCD驱动的系统镜像了，这样安装以后就能够直接使用了使用操作系统了。先给出系统镜像的下载地址：带触摸屏驱动镜像下载地址)。 系统的安装步骤如下： 下载带有制定驱动的镜像，地址在上面 将镜像写到U盘里面，各系统的写入方式参考官方安装教程的Writing the image章节。本文章只给出Mac下的写入方式。 将U盘插到树莓派上，注意是树莓派的SD card口，而不是用读卡器插到usb口，启动树莓派。应该能看到系统正常启动。 镜像下载和镜像原理系统启动和磁盘远离Mac下用到的命令详解","link":"/2020/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE3-5%E5%AF%B8%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A5%97%E8%A3%85%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"title":"vue进阶：vue-router懒加载的实现原理","text":"这篇文章主要分析vue-router懒加载的实现原理。vue-router的懒加载基于vue的异步组件和webpack的splitCode来实现。接下来首先介绍vue的异步组件和webpack的SplitCode，然后介绍vue-router中懒加载执行的底层步骤。 vue的异步组件有时候我们需要将应用分割成小的代码块，然后按需加载。vue为了简化异步加载的使用，提供了以工厂函数的形式注册逐渐的方式，如下：123456789Vue.component('my-comp', function(resolve, reject) { // 异步操作，成功调用resolve，传入组件的选项 setTimeout(()={ resolve({ template: \"&lt;div&gt;hello world!&lt;/div&gt;\" }) }, 100)})我们看到异步组件的工厂函数类似于Promise，传入resolve和reject函数。 vue官方的推荐用法是和webpack的SplitCode功能一起使用，如下:123456789101112131415Vue.component('my-comp', function(resolve,reject){ // 这里的组件通过ajax异步加载，在构建的时候会 // 自动打包成多个chunk require('./my-async-comp', resolve)})// 或者Vue.component('my-comp', () =&gt; import('./my-async-comp'))// 或者局部注册new Vue({ ... components: { 'my-comp': () =&gt; import('./my-async-comp') }}) 异步组件的工厂函数也可以返回一个如下的对象：12345678910111213const AsyncComponent = () =&gt; ({ // 需要加载的组件 (应该是一个 `Promise` 对象) component: import('./MyComponent.vue'), // 异步组件加载时使用的组件 loading: LoadingComponent, // 加载失败时使用的组件 error: ErrorComponent, // 展示加载时组件的延时时间。默认值是 200 (毫秒) delay: 200, // 如果提供了超时时间且组件加载也超时了， // 则使用加载失败时使用的组件。默认值是：`Infinity` timeout: 3000}) 到这里我们已经了解vue的异步组件的基本使用，Vue内部提供了一种类似于Promise的机制用于组件的异步加载，在注册组件的使用允许使用工厂函数来注册，当使用异步组件的使用，会发送ajax请求来获取异步组件","link":"/2019/08/30/vue/vue%E8%BF%9B%E9%98%B6%EF%BC%9Avue-router%E6%87%92%E5%8A%A0%E8%BD%BD%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"},{"title":"1.系统整体功能和模块设计","text":"这一部分主要是系统设计，主要是设计整个系统包含哪些功能，应该划分成哪些模块。先从整体功能开始，然后到每个模块的具体功能。 总体功能如下图： 系统总体包括前台和后台两个部分，前台主要是信息的展示，首页展示最主要功能的概括，提供进入各部分的入口和一些最重要的信息（例如热点漏洞、最新漏洞等）。前台的其他部分可以通过tab或者首页入口访问，提供漏洞、作者等的详细信息。 后台分权限访问，普通用户只有上传权限，只能够看到自己上传的漏洞（有统计信息、能够进行分类查询）。管理员用户拥有额外的能力，能看到和搜索其他用户上传/自动采集的漏洞，能够对用户上传的漏洞进行审核、对已发布的漏洞进行审核、将某用户加入黑名单等等。超级管理员除了拥有管理员的能力外，还能够授予其他用户管理员权限，并且能够设置自动采集参数。 前台功能除首页和发现外的其他部分基本都是一个列表。 首页首页主要是展示网站各部分的一些重要信息。 发现发现部分主要展示从其他网站上爬取的漏洞、安全相关的新闻、文章、技术总结这些。 后台功能预计的后台功能比较简单，先完成第一版。 权限管理采用简单的角色模型，角色分三级：普通用户、管理员、超级管理员。 网站数据统计需要展示如下数据： 总用户数 用户总上传数 总漏洞数 当日活跃用户及活跃用户趋势图 本周活跃用户及趋势图 当日新增数（上传和爬取分开）和趋势图 本周上传数（同上）和趋势图 模块设计 每一个模块可能用于多个功能之中。","link":"/2020/02/18/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/1-%E7%B3%BB%E7%BB%9F%E6%95%B4%E4%BD%93%E5%8A%9F%E8%83%BD%E5%92%8C%E6%A8%A1%E5%9D%97%E8%AE%BE%E8%AE%A1/"},{"title":"后端权限设计——基于集群","text":"exploit系统的登陆和权限认证基于apache shiro实现，shiro提供了认证、授权、拦截等多种用户管理能力。本文基于shiro的基础能力，设计开发支持后端服务器集群、redis集群的服务器管理模型。主要解决的问题是： 后端服务集群的无状态化：因为负载均衡可能将请求转发到任意一台服务器，而且多次请求可能访问不同的服务器，所以后端服务各自存储用户session会导致用户登陆态的不一致。这里要实现将session管理从单独的服务器抽离，将session态存储在redis集群中。同时shiro的缓存也使用redis集群存储。 shiro和redis集群访问的整合 基于JWT的认证实现 目前是基于cookie和DefaultWebSessionManager来实现，只需要在shiro配置中，将SessionDao的bean配置成基于redis cluster的SessionDao，这一点在shiro-redis包中已经集成了，直接使用即可。同时需要处理的是图片验证码服务，session存在redis中，需要把redis访问改成redis cluster访问。 参考资料org.crazycake.shiro.redis在shiro中集成sessionDao的能力，参考：http://alexxiyang.github.io/shiro-redis/ shiro的session管理参考：https://shiro.apache.org/session-management.html jedis在java中提供了对redis服务器，redis集群访问的api，jedis的参考：https://github.com/xetorthio/jedis/wiki","link":"/2020/03/29/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E5%90%8E%E7%AB%AF%E6%9D%83%E9%99%90%E8%AE%BE%E8%AE%A1%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8E%E9%9B%86%E7%BE%A4/"},{"title":"2.数据库设计","text":"数据库设计要根据前面设计的功能，对系统需要的数据进行建模。重点是要确定数据库要存储哪些信息，这些信息之间的关联。步骤是： E/R建模，根据功能描述建立起E/R联系图，确定实体属性及实体之间的关系。 将E/R图转成关系数据模型。 利用BCNF等关系范式进行分析、消除数据库冗余等异常。 根据设计得到的关系模型编写sql语句，将设计的数据库模式存储到数据库中。完成设计 E/R图设计","link":"/2020/02/19/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/2-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"title":"服务器部署","text":"毕设终于开发完成了大部分的基础功能，接下来就是进行部署了。计划使用三台服务器进行部署，一台用作静态资源服务器和反向代理服务器，另外两台作为后端服务集群，采用容器化方式部署。 主要解决的问题是： 后端服务的架构：mysql、redis、java代码是部署在一台机器上还是分离部署？ 容器如何编排？使用nginx的反向代理还是kubernates？各有什么优势和劣势？ 容器之间的状态如何保持一致？mysql、redis如何保证多台机器上的数据一致性？如何保证用户的登陆态在多台机器上是一致的？ 发布后自动部署 首先我们进行一些基础知识的学习，主要是服务器部署架构的基础知识，主要参考《大型网站技术架构——核心原理与案例分析》，主要学习的知识是大型网站架构的演进，大型网站的指标和主要使用的技术。然后即行docker基础知识的学习。然后是mysql、redis一致性的解决。 大型网站技术架构该部分主要分为以下知识点 概述 大型网站架构演化的发展历程 1.初始阶段的网站架构：用户量小时，一台服务器提供服务绰绰有余。数据库，文件、web服务器运行在一台机器上 2.应用服务和数据服务分离：用户量增加，越来越多的用户访问导致服务器负载越来越高、数据越来越多，一台服务器不够了。这是将数据和服务分离，使用三台服务器，分别部署应用服务器、文件服务器和数据库服务器。不同的服务器拥有不同的能力，应用服务器需要更快的CPU；数据库服务器需要快速硬盘和更大的内存；文件服务器需要更大的硬盘。 3.使用缓存改善性能：二八定律，80%的访问集中在20%的数据上，缓存热点数据可以减少数据库访问压力。缓存有本地缓存和缓存在远程服务器上的分布式缓存。 4.使用应用服务器集群改善网站的并发处理能力：当用户继续增加，一台应用服务器不足以处理所有的请求，这时候就需要使用额外的应用服务器来处理额外的请求。添加应用服务器集群。通过负载均衡服务器来确定提供服务的服务器。 5.数据库读写分离：缓存可以大大减小数据库的压力。但是仍然有一部分操作需要访问数据库（缓存过期、缓存未命中、数据库写操作）。可以通过数据库的主从关系来实现读写分离。写数据访问主服务器，而读数据访问从服务器，通过主从复制同步数据。 6.使用反向代理和CDN加速网站响应：用户规模越来越大，用户可能分布在相距较远的多个地域。在广州的用户访问在广州的服务器，肯定比北京的用户访问广州的服务器延迟低。CDN和反向代理的基本原理都是缓存，区别是CDN部署在网络提供商的机房，用户可以从距离最近的网络提供商获取数据。反向代理服务器部署在中心机房，用于缓存，在应用服务器之前。 7.使用分布式文件系统和分布式数据库系统：一台数据服务器分成两台，当用户量持续增加的时候，两台数据库服务器也不够了，这时候需要使用分布式数据库。只有在单表数据规模非常庞大的时候才使用分布式数据库。不到不得已时，网站更常用的拆分手段是分库，将不同业务的数据库部署在不同的物理服务器上。 8.使用NoSQL和搜索引擎实现数据存储和搜索：全文检索、NoSQL用于解决增长的数据和搜索需求 9.业务拆分：随着业务扩展，系统会变得越来越庞大，可以通过通过业务拆分划分为多个子系统，由不同的团队负责，部署在不同的服务器集群上。例如首页、商品页分开部署，这样可以降低一个系统的复杂度，便于发布和管理。通过消息队列和访问同一个数据存储系统来实现不同模块之间的关联 10.分布式服务：业务继续扩张，拆分的拆分的子系统也会变得越来越复杂，而且子系统中有很多可以共用的部分。这时可以通过提取共用的服务作为底层支撑，并将这些服务进行独立的集群部署。查分的多个业务远程调用这些服务。 大型网站架构模式 大型网站核心架构要素 架构 瞬时响应：网站的高性能架构 万无一失：网站的高可用架构 永无止境：网站的伸缩性架构 随需应变：网站的可扩展性架构 固若金汤：网站的安全架构 案例 淘宝网的架构演化方案 维基百科的高性能架构设计分析 海量分布式存储系统Doris的高可用架构设计分析 网购秒杀系统架构设计案例分析 大型网站典型故障案例分析 架构师 架构师领导艺术 网站架构师职场攻略 漫话网站架构师 后端的服务架构设计虽然只有三台物理服务器，但是每一台服务器上可以部署多个容器，容器可以视作抽象的服务器。按照推荐，每一个容器仅仅只运行一个应用。例如mysql和redis运行在两个不同的容器中，通过配置dockerfile和使用docker命令参数，让他们从容器中暴露出自己的端口，从而能够从外界访问。 推荐使用在一个容器中只运行一个进程，虽然一个容器中可以执行多个进程。如果需要一个容器中执行多个进程，那么最好使用进程管理工具来负责容器中进程的启动和监视。自己使用脚本来启动多个进程也可以，但是需要自己处理进程间信号的转发和进程结束之后的善后处理。 这样从外界看来，虽然只有三台物理机器，但是实际上能够达到模拟若干台机器的效果。当一台机器的计算资源和存储资源有余时，一台物理机器上部署多个服务例如mysql、redis、应用是没有问题的。但是当用户量增大时，会有服务成为瓶颈，这时候需要增加相应的机器，将服务分离开，以提供更多的计算资源、内存资源、硬盘空间。当一台机器的计算资源有余时，部署多个容器是有优势的，能够充分利用一台机器的性能，不会造成资源空闲。 那三台机器，分别部署不同的服务（分别是redis、应用、mysql），还是每台机器都部署服务的一部分做分布式部署呢？这也要看情况，例如在各个服务器部署不同的服务的时候，假设数据服务器的硬盘资源到达了瓶颈，而应用服务器的计算资源和硬盘资源都有富余，那么可以在应用服务器上再部署数据容器，利用应用服务器的资源减轻数据服务器的压力。反过来同理，数据服务器的计算能力有大量富余，那么可以将应用容器部署到数据服务器，以利用数据服务器的计算资源。 总之，具体采取怎样的设计架构需要根据具体资源的分配情况来定，没有决定的优劣。在本次毕设的服务器部署中，设计在两台后端服务器上都部署redis、mysql、应用容器，这些服务器上的容器分别组成应用集群、数据库集群、缓存集群。 集群的引入当然会产生与单机相比更多的开销，例如集群间需要通过网络进行通信，负载调度。但是这些是引入额外的机器必须的开销，两台机器并不能起到一台机器两倍的效果，但是可以起到1.8倍甚至更高的效果。额外的网络通信也会增加一定量的访问延迟，这些都是不可避免的，可以通过引入额外的缓存来尽量减少这些访问延迟。 数据一致性的保证多台机器上的数据如何保持同步？这一块主要解决这个问题。 mysql数据库mysql数据库通过主从复制来保证，在主服务器上写，在从服务器上读，实现读写分离。在java中通过mysql连接中间件实现读写分离，在java端看起来就像只有一个节点，中间件通过对sql语句的分析来决定使用哪一个源，mysql读写分离的需要两部分的支持： mysql数据库开启主从同步机制 java通过中间件连接mysql，然后在中间件中配置读写的mysql数据库地址 mysql数据库运行在docker容器中，使用相同的镜像，保证mysql的版本，环境都是完全相同的。 redisredis也带有读写分离的的机制，但是更高效的方式是使用redis集群 项目发布设计将代码发布到集群上的一台机器上，然后在该机器上重新构建，生成新的image，再将该image通过k8s的更新机制自动同步到该服务的其他的节点。该过程需要以下技术的支持： git hooks：再特定分支上提交代码以后，触发git hooks，通过执行特定的shell脚本触发新的image的build过程。构建成功之后，再通过shell脚本将结果自动更新到集群上。（待添加自动化测试、构建失败的反馈） shell脚本：linux平台上的脚本语言，可以以编程语言的方式执行linux命令。 docker image构建：利用docker create重新从dockerfile和源代码构建一个新的image，这个image通过一个新的版本号标识。容器中只运行打包过后的jar包，而不包括maven等环境，以减少image的大小 k8s更新：通过set image命令告诉k8s集群对特定的部署使用新的image，这个过程k8s会自动热重启 本来想使用k8s做集群部署，但是发现k8s对机器配置有要求，2核2G是最基础的配置，然后最好至少要三个节点，master节点不部署容器（虽然可以通过修改配置部署容器）。k8s是企业使用的大规模容器管理工具，我这low的配置就还是不上了，看了两天文章，当作了解k8s的基础概念了。 现在打算使用docker自带的swarm来实现。在docker 1.12之后swarm已经集成到了docker引擎中，可以很方便的扩展到集群。同时swarm也支持负载均衡，滚动发布等。 部署全过程细节这里记录了部署的全过程步骤，先看一下概览： 学习docker，主要关注docker核心概念，Dockerfile的结构和命令，以及docker命令行工具的常用命令。核心概念包括，镜像、容器、镜像分层、数据卷挂载、端口、网络路由、通过namespace实现进程隔离、通过cgroup实现资源隔离等等。 学习基于docker的集群方案，了解的有swarm和kubernetes，kubernetes是google开源的方案，拥有比swarm更强大的功能，但是对硬件要求高一些。swarm是docker官方的方案，想对来说功能少一些，更简单，硬件要求也低很多。 基于集群规模和机器配置选择swarm进行部署。需要了解swarm的核心概念，包括服务、manager/worker、docker service、docker node命令等、docker config 搭建私有registry，参考官方文档就行，需要使用ssl，或者配制非安全的仓库选项。 学习mysql的主从复制，主要是如何在mysql上开启主从复制 学习mycat的读写分库配置和安装，利用docker.mycat库，以及docker-compose。（这里需要安装docker-compose，从github下载太慢，使用pip安装的又执行不了，最后的解决方案是下载预发布版本 学习redis cluster和redis主从复制方案，redis cluster最少需要3个主节点，因为在spring-boot中实现读写分离需要非常多额外的配置，并不像mycat中那么简单，最后决定使用redis cluster，只启动三个主节点，不启动从节点。这里需要注意，按照官方文档来，在最后一步会卡住，因为官方文档只在单机上运行，多机上需要按照提示，登陆每台机器的redis服务器，执行cluster meet 6379 16379命令。同时注意开放端口，例如阿里云需要在后台配置开放的端口。 nginx集群服务和文件图片上传。nginx中主要存放两部分的资源，一个是nginx的配置文件和https配置；另一个是前端静态资源的配置，前台和后台使用不同的域名访问，前台使用brightasdream.cn域名，后台使用admin.brightasdream.cn子域名，前台和后台的代码都放在一个docker nginx容器中，通过配置文件中配置不同的域名来访问不同的资源。代码通过Makefile基于nginx容器构建新的容器，配置文件也写在源代码中。文件上传使用单独的服务，因为nginx要保持服务的一致性，所以不在单独的nginx服务下提供文件访问的能力，这里启动一个单独的java容器用做图片文件服务器，预览时直接上传图片，删除预览图片则通知文件服务器将图片删除。这里不引入HDFS等分布式文件系统了，因为数据量小，且机器数量和配置有限。 上述的学习资源主要都来自于官方文档和书籍，下面的每一章都会注明参考资料的来源，便于复习参考。 CI/CD的实现Docker有jenkins等框架来帮助CI/CD的实现，我们的需求比较简单就不使用。jenkins是一个单独的Docker容器，当有代码推送到jenkins中，会自动触发自动测试，构建新镜像，推送镜像等，同时提供了web界面。 我们打算使用shell脚本来完全实现CI/CD，通过在swarm的manager节点上建立git仓库，然后将代码推送到该仓库，当仓库接收到提交时，触发git hook，git hook根据commit的的message信息来决定构建哪一个子项目。这里这里应该使用git submodule来实现，但是由于项目开始的时候没想那么多，放在一个git仓库中，又不想丢失commit记录，只能自定一个commit mesasge规范来决定构建哪一个子项目了。 当git commit信息中包含build backend:时，构建后端服务的镜像，包含build frontend时，构建前端镜像，包括前台和admin。 排坑mycat连接时，读没没有问题，写会包Connecttion is readonly错误，解决方案看： https://blog.csdn.net/aa292016616/article/details/82736054。 卡了两天的mycat，最终还是没有解决主键报报NullPointerException的问题，也没有解决多条件查询的问题。最终的解决方案是不使用mycat，在spring boot中做读写分离，配置多个jpa数据源，通过继承AbstractRoutingDataSource自定义jpa数据源路由的选择。要注意几个坑： AOP选择数据源要定义在controller上，而不是service，因为我的controller可能会同时有读写的service，如果在读的service上配置了读库，后面的写就会写到读库上。因为同一次请求用的是同一个数据源 jpa的默认事务是只读的，这也是连接mycat的时候会报conneciton is readonly的原因。在事务开始的时候，不根据当前事务是只读的来选择数据源，因为当前项目没有事务的需求。 实体的属性的名称和数据库表名不一样，那么需要使用@Column来自定义对数据库表名的映射（不会自动转化驼峰式的命名） 参考：https://blog.csdn.net/dusuanyun/article/details/81059535","link":"/2020/03/22/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%83%A8%E7%BD%B2/"},{"title":"毕设概述","text":"马上毕业了，开始做毕设。本科没怎么努力，但是还是学到了很多东西的，也找了一份还过得去的工作，人生接下来的时间不能浪费了，要更加努力才行。 毕设的内容是做一个漏洞管理系统网站。核心功能是漏洞的管理，包括漏洞采集、漏洞发布、漏洞利用代码下载、漏洞补丁下载等功能。额外的功能有漏洞新闻。 前端采用vue、ts等，后端采用spring-boot、mysql等，毕设的每一部分的设计和涉及到的知识点都在毕设系列博客中。 当然毕设完成过程中学习也不能停，复习和总结学过的java、前端、网络、编译、数学等方面的基础知识，并记作博客，每天至少拿出两个小时。 预计整个毕设的过程和排期是： 系统整体功能和模块设计，排期3天，2020.2.18-2020.2.20 各模块数据库设计，排期2天，2020.2.21-2020.2.22 各模块主要界面的原型图，排期3天，2020.2.23-2020.2.25 逐步完成各模块前后端功能开发，该部分带完成各模块之后进行详细排期。 测试 功能测试 性能测试 安全性测试 自动化上线工具","link":"/2020/02/18/%E6%AF%95%E4%B8%9A%E8%AE%BE%E8%AE%A1/%E6%AF%95%E8%AE%BE%E6%A6%82%E8%BF%B0/"},{"title":"排列、组合和子集算法及题解","text":"1. 排列、组合以及子集问题1.1 什么是排列、组合和子集？排列分为全排列和普通排列，全排列表示方法：$A{^n_n}$，表示1到n的阶乘（$\\prod_{i=1}^ni$），普通排列$A{^m_n}$，表示(n-m+1)到n的阶乘。（这时数学里面的定义） 例如：$A{^3_3}=3*2*1 = 6$，$A{^4_2}=4*3=12$ 那全排列有什么应用呢？举个例子，数字排列问题：将1-9排在9个位置，有多少中排法？例如，123456789是一种，213456789也是一种，那么一共多多少种呢？第一个位置有9种情况，第二个位置有8种情况，…，第九个位置有1种情况，总的可能数就是987…*1=$A{^9_9}$. 组合和排列类似，但是组合不考虑顺序问题，也就是123和321其实是一种情况。例如：有四个数，要从中选两个数，有几种选法？数学解法是$C{^4_2}=\\frac{43}{21}=6$， 子集呢？一个n个元素的集合的子集个数是$2^n$个，子集可能是空集，一个元素的集合一直到n个元素的集合。例如集合{1,2}，其子集可能是{$\\emptyset$, {1}, {2}, {1,2}} 2 用深度优先算法解决排列、组合和子集问题2.1 排列2.1.1 问题描述输入一系列数字，例如123，给出所有可能的排列结果，例如对于输入123，输出123、132、213、231、321、312. 2.1.2 算法思路对于123而言，有三个位置，我们可以枚举每一个位置，在深度优先搜索中位置的个数就是深度。在每一个位置都枚举可能取的值，注意数字不能重。 上代码：12345678910111213141516171819202122232425/** * @param {number[]} nums * @return {number[][]} */var permute = function(nums) { var result = []; dfs(0,nums,[],result,[]); return result;};function dfs(depth,nums,temp,result,visited) { if(depth == nums.length) { result.push([].concat(temp)); return; } for(var i = 0;i &lt; nums.length;i++) { if(!visited[i]) { visited[i] = true; temp.push(nums[i]); dfs(depth+1,nums,temp,result,visited); temp.pop(); // 回溯思想，当前数字被处理了后，在其他情况中还可能需要被处理。 visited[i] = false; // 同上 } }} 2.2 组合2.2.1 问题描述给定一个集合{1,2,3}，选出其中的2个数组成新集合，不能重复。例如：输入{1,2,3}，输出[[1,2],[1,3],[2,3]] 2.2.2 算法思路我们还是应用深度优先搜索的思想，只不过示例中的深度是2。第一层我们可以取的值是，1|2|3，第一层取了的第二层就不能取了。而且为了避免重复，加入我们第一层取2，那么第二层就不能取1了，因为12，21是相同的。第二层只能从3开始取。 上代码：1234567891011121314151617var combination = function(nums,m) { var result = []; dfs(0,m,nums,[],result,0); return result;}// spos是下一次遍历数组时开始的位置，如果上一次我们遍历了1，那么下一次要从2开始，这样才能保证不重复function dfs(depth,tdep,nums,temp,result,spos) { if(depth == tdep) { result.push([].concat(temp)) return; } for(let i = spos;i &lt; nums.length;i++) { temp.push(nums[i]); dfs(depth+1,tdep,nums,temp,result,i+1); temp.pop(); }} 2.3 子集2.3.1 问题描述给定一个集合，比如{1,2,3}，求其所有子集。例如：输入{1,2}，{$\\emptyset$, {1}, {2}, {1,2}} 2.3.2 算法思路通过观察我们可以发现，一个集合的子集的元素个数是有规律的，子集中的元素有可能有0个（空集），1个，2个，…，n个。 然后我们就可以将问题缩小了，问题变成了从集合中选出1个（2、3、…n）元素组成新集合？我们发现这变成了一个组合问题了。 所以我们的算法分两步，第一步枚举子集元素的个数，假定当前为i，第二步，求出集合中取i个元素构成的子集，我们可以复用上面组合的代码。 上代码： 1234567891011121314151617181920212223/** * @param {number[]} nums * @return {number[][]} */var subsets = function(nums) { var result = []; for(var i = 0;i &lt;= nums.length;i++){ dfs(0,i, nums,[],result,0); } return result;};// 下面时求集合中取tdep个元素的组合，直接复用了求组合的代码function dfs(depth,tdep,nums,temp,result,spos) { if(depth == tdep) { result.push([].concat(temp)) return; } for(let i = spos;i &lt; nums.length;i++) { temp.push(nums[i]); dfs(depth+1,tdep,nums,temp,result,i+1); temp.pop(); }} 3 思考&amp;总结这里我们总结排列、组合和子集问题的解法。这是最基本的算法，许多问题可能是这几种思想的变体. 例如，leetcode组合求和问题：给定一个数字集合和一个目标数字，求出所有和是这个数字的数字集合：输入[1,2,3]，4那么输出[[1,3],[2,2]]，因为1+3=4,2+2=4，还要保证不重复。 这个问题可以利用我们前面总结的组合问题的思想，我们求[1,2,3]的组合（这里的组合与上面区别是选取元素个数是不确定的，而且元素可以重复，只要值没到4，就可以一直加）。如果组合集合数字和为4，那么输出这个集合，同时还可以采用回溯的思想优化，如果当前的和或者当前数字的值大于目标数字，那就没必要继续算了，直接回溯。 上面讨论了一种变体，还有很多这类问题的变体，理解了关键思想，就都不困难了。","link":"/2019/06/05/algorithm/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/%E6%8E%92%E5%88%97%E3%80%81%E7%BB%84%E5%90%88%E5%92%8C%E5%AD%90%E9%9B%86%E5%8F%8A%E9%A2%98%E8%A7%A3/"},{"title":"C Primer Chapter 1: Getting Ready","text":"C Primer第一章的读书笔记。在这一张将学到： C的历史和特性 写程序的步骤 编译器和链接器的一些知识 C标准 要点记录1. C 1972年出现，设计给专业的程序员编程2. C语言的优势： 对结构强力的控制 快 代码压缩，程序短小 可移植，跨平台 2. 设计特性 高效：配合汇编语言，能有效的控制最大内存和CPU的使用 可移植：一直编写，经过少量或者没有修改，可以在多个平台上执行，只要对应的平台上有C编译器 强有力和弹性：大部分的操作系统和编译器都是使用C写的。C不仅可以用于系统还可以用于电影特效等等。 面向程序员：C能够直接访问硬件，实现对内存每一个bit的精确控制。向C++、java等，C语言的限制更少，你能决定用什么形式来编程。 3. 缺点C语言不容易捕获到错误。C语言的控制能力让程序员担负了更多的责任，来维护程序的稳定。 4. C的用途编写操作系统、电脑游戏、机器人、嵌入式系统、PC程序等等。 5. 计算机做了什么我们编写了C程序，那么C程序是如何在计算机上执行的呢？首先我们要知道计算机的结构，计算机有CPU、RAM、硬盘等，CPU负责计算，RAM负责动态储存，硬盘负责静态存储。CPU读入一条条的指令，每条指令对应的具体的计算和操作。 计算机中只能存储数字，我们存的字符、指令、视频等，在内存中都是二进制数据。 6. 高级语言和编译器计算机只能认识二进制指令，而我们习惯使用高级语言，所以要有一个将高级语言转换成二进制指令的过程。这通过编译器来完成。编译器将人类可读的语言转成机器可读的语言。 7. 语言标准最开始C语言只有语法，对于API没有统一的规范，涉及到操作系统、网络等基础API时，规范不统一，将会使C语言的可移植性大受影响。 C90第一代标准有ANSI和ISO分别在1989和1990年推出，称为C90。制定的基本原则如下： 相信程序员 不阻止程序员做任何事情 保持语言精简 一个方法执行一种操作 尽可能快，即便可能不会保证可移植性 C99C99添加了国际化的支持，例如对其他的字符集的支持。还添加了64位处理器的支持。 主要改进三个方面：国际化、缺点的改正、计算能力的提高。C语言保持精简，“让C++成为大而野心勃勃的语言”。 C11标准添加并发编程的支持。 使用C：7个步骤 定义程序目标，需求 设计程序 编写代码 编译 执行 debug 维护 源代码的编译过程源文件-&gt;编译器-&gt;obj文件-&gt;链接器-&gt;生成的obj+库代码-&gt;可执行文件。 首先编写的代码是源文件，源文件经过编译器编程obj文件(机器代码文件)，没有一个源文件都生成对应的obj文件，然后这些obj文件，以及库文件，通过链接器，链接成一个可执行文件。","link":"/2019/11/04/c-c++/C%20Primer/C-Primer-Chapter-1-Getting-Ready/"},{"title":"1.C语言中的基本元素","text":"一个基本C语言程序包含如下几个部分： 注释，有单行注释和多行注释。注释部分在预编译处理后就不存在了 预处理器 入口函数main 自定义的函数 C语言的头文件用.h结尾，源文件用.c结尾。 C语言中的字符集基本上所有语言的字符集都分为两种，一种是源字符集，一种是执行字符集。 源字符集：编写代码时候用的字符集 执行字符集：构建完源程序之后的目标二进制文件表示的字符集 例如java的源代码文件可能用utf-8编码，但是读入编译器后，使用的是UTF-16，也就是到执行时，一个字符起码占两个字节。 C语言标准允许C语言实现采用多字节字符集。但是是否能够使用多字节字符集进行编码，需要根据编译器的支持程度来看。 C语言中的Tokentoken表示词法元素，输入的源文件会被编译器解释成一个个的token，在这些token上再进行语法分析。 C语言标准中定义token和预处理token，分别用于在编译时和预编译时的符号解析。根据预处理的规则，有一些token会在预处理时被处理掉，根据规则来定，所以下面会有重的，字符串可以在预处理中被替换，也可以是字面常量赋值给变量。 token：关键词、标识符、常量、字符串字面量和标点符号 预处理token：头文件名、标识符、预处理数、字符常量、字符串字面量、标点符号以及空白符号 标识符一个标识符由字母、数字、下划线组成，不能由数字开头。（有的C语言实现可以使用多字节字符作为标识符，例如GCC就支持）。C语言标准没有给出标识符的最大长度，但是具体实现上，标识符是64个字符，外部链接是32个字符（来自《C primer》），低版本编译器的实现可能更少。 关键字数据类型：int、short、long、signed、unsigned、char、float、double、union、struct、enum、_Bool、_Complex、_Imaginary、void循环控制：while、do、while、for、break、continue分支控制：if、else、switch、case、goto、default、return变量声明：static、const、register、volatile、const、extern、inline、auto、restrict、typedef、_Aalignas、_Atomic、_Noreturn、_Thread_local C语言中字面量四种字面量： 整数、浮点数、枚举、字符和字符串字面量 例如：1，1.1，’A’，”中文”。 字符串前可以加上u8或者u或者U来使用utf8或者utf16或者utf32编码方式：1234567891011const char* s1 = \"hello, world!\"; // 默认编码方式const char* s2 = u8\"hello, world!\"; // 采用utf-8编码const char* s3 = \"你好，世界\"; const char* s4 = u8\"你好，世界\";const char* s5 = u\"你好，世界\"; // 采用utf-16编码，返回unsigned short*printf(\"%s %d\\n\", s1, strlen(s1)); // hello world! 13printf(\"%s %d\\n\", s2, strlen(s2)); // hello world! 13printf(\"%s %d\\n\", s3, strlen(s3)); // 你好，世界 15printf(\"%s %d\\n\", s4, strlen(s4)); // 你好，世界 15printf(\"%s %d\\n\", s5, sizeof s5); // 报错，u会转成unsigned short*gcc编译时，会按照c文件的编码进行编码，因为我们的源文件是utf-8编码，所以里面的中文会按照utf-8编码被gcc处理，所以s3和s4在内存中都是15个字节（大部分utf-8编码的中文都是一个字符占3个字节，示例中5个字符）。都能正常显示中文。如果控制台显示乱码，那么需要查看控制台输出的编码方式，输入locale命令可以查看。 使用u或U会把字符串转成unsigned short数组指针或者unsigned int数组指针，u8会将字符串字面量存储为char*。 C语言中的标点符号单目运算符：!、&amp;（用于地址操作符）、*（作为间接操作符）、+（正数符号）、-（负数符号）、～（按位取反）、++、– 双目运算符： 算术运算，+、-、*、/、%、= 逻辑运算，&amp;&amp;、||、&lt;、&gt;、==、!= 位运算，&lt;&lt;、&gt;&gt;、 &amp;、|、^ 预处理：#、## 组合运算，+=、-=、*=、/=、%=、&lt;&lt;=、&gt;&gt;=、&amp;=、|=、^= 三目运算符：? :，例如a?b:c; 其他符号还有：, [] () . -&gt; {} ; : … &lt;: &lt;% %&gt; %: 不同的操作符的优先级不同，同一个表达式中，优先级高的运算符优先运算，优先级相同的运算符从左到右运算。优先级从高到低： 基本表达式：标识符、字面量、圆括号表达式、泛型表达式 后缀操作符：数组下标、函数调用、.和-&gt;、++和–、(int[]){1,2,3} 单目操作符：前缀++和–、&amp;、正负取反等、sizeof、_Alignof等 类型投射 乘除取模 加减 左移右移 关系操作符&lt;、&gt;、&lt;=、&gt;= ==、!= 按位与&amp; | 按位异或^ &amp;&amp; || ？: = , 基本表达式优先级最高，复合表达式第二；单目&gt;双目&gt;三目、算术运算&gt;移位运算&gt;逻辑运算（&lt;、&gt;等）&gt;(==等)&gt;按位运算； 如果不知道优先级关系或者优先级关系复杂，加上圆括号、增强可读性确保不错。因为圆括号优先级属于最高的那一层。","link":"/2019/06/11/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/1.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%85%83%E7%B4%A0/"},{"title":"C Primer Chapter 2: Introducing C","text":"本章将会学到以下内容： 操作符= 函数main、printf 简单的C程序 创建整数值的变量、给其赋值并且在屏幕上展示他们 换行符 如何在程序中包含注释，创建多个函数以及查找错误 什么是关键字 一个简单的示例1234567891011#include &lt;stdio.h&gt;int main(void) { int num; num = 1; printf(\"I am a simple \"); printf(\"computer.\\n\"); printf(\"my favorite number is %d because it is the first\", num); return 0;} 一个典型的C程序的语法结构如下：1234567891011121314|c程序|-#include 预编译语句|-int main(void) 程序的入口| || ---- statements 语句块 |-function a()| || ---- 语句块|-function b()| || ---- 语句块| || ---------- 定义语句、赋值语句、函数、控制语句...|我们看到一个C程序分成两大部分，一个是预编译语句，预编译语句在程序编译之前执行，例如宏定义，include等。另一个是程序代码，其中main是入口，可以定义很多和main同级的函数，函数内部是语句块，可以有多条语句。 main的返回值在不同的操作系统中有不同的意义，在unix和linux中代表程序执行的状态。 C的标识符可以是任意长，但是对于C99、C11，编译器只取前63个字符，对于外部标识符，值有31个字符。对于C90是，分别是31和6。C标准没有规定编译器的行为，如果标识符超长，那么相同的超长标识符，在有的编译器下可能会被认为是不同的标识符。标识符由字母，数字和下划线组成，不能由数字开头。 操作系统和标准库使用双下划线开头的变量，所以自己编程的时候不要使用双下滑线开头的变量 变量声明声明变量的4个好处： 将所有的变量放在一起更好的抓住程序的重点 良好的变量命名和注释可以知道变量的含义 提前声明变量可以防止错误输入等难以发现的bug C编译器在编译时会报错 C90要求必须在块最开头声明变量（这也是一些老的硬件IDE常报的错误，因为其编译器只支持c90），C99和C11和C++保持一直，可以在任何位置声明，但是必须在使用前声明。 使程序可读的方法 选择有意义的命名和注释 换汉和空格隔开 一行一个语句","link":"/2019/11/04/c-c++/C%20Primer/C-Primer-Chapter-2-Introducing-C/"},{"title":"3.C语言的基本运算操作符","text":"算术运算+、-、*、/、%以及+=、-=等 按位运算&amp;、|、^、~以及&amp;=、|=等。分别表示按位与、按位或、按位异或和按位取反 自增自减++、– 逻辑运算&amp;&amp;、||、!。&amp;&amp;和||都是短路运算符。 还有&gt;、&lt;、&lt;=、&gt;=、==、!=等比较运算符。 移位运算符&lt;&lt;、&gt;&gt;、以及&lt;&lt;=、&gt;&gt;=。C语言中如果右操作数是负数或者大于左操作数位宽，那么结果是未定义的。不同的平台可能有不同的行为。算术移位还是逻辑移位在C中根据源操作数是否是带符号数来决定。（在其他语言中可能使用&lt;&lt;&lt;、&gt;&gt;&gt;来表示不带符号移位）。如果是带符号移位，高位填充的是符号位。低位始终填充0. 圆括号操作符用于提升表达式的优先级。圆括号表达式是基本表达式，和字面量常量一样，属于优先级最高的那一层。圆括号表达式可以是左值 sizeof运算符sizeof属于单目操作符，语法： sizeof 表达式 sizeof(类型名，例如int) sizeof 表达式表示表达式的值的宽度。sizeof(类型名)表示类型的宽度。 sizeof返回其操作数的大小（占用多少字节），用一个整数值来表示，C语言实现都是用size_t。sizeof表达式的值不一定是在编译时就能够确定的常量，因为表达式的值可能不是编译时就能确定的，例如从键盘输入的值。预编译时期的sizeof更不是常量，必须到编译时或者运行时才能确定sizeof的值！！！！！ 对于数组，返回的是数组所占的字节数； 对于指针、返回的是指针的宽度（64位系统中是8个字节）； 对于基本类型，返回的是基本类型的宽度（例如int是4个字节）； 对于struct，返回的是struct所占的总大小。注意这里的字节大小是经过字节对齐的。看下面的示例 操作数不能是位域。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;int main() { char *str = \"123中文\"; int a[10]; long t = 10; long* b = &amp;t; int* pa = a; struct Name { char firstName[20]; char* lastName; } s; printf(\"%zd %zd %zd %zd\\n\", sizeof(str), sizeof(a), sizeof(b), sizeof(pa)); printf(\"%zd %zd %zd %zd\\n\", sizeof(struct Name), sizeof(s.firstName), sizeof(s.aaa), sizeof(s.bbb));// 8 40 8 8// 32 20 2 8 return 0;} 在上面的示例中，我们发现sizeof(struct Name)是32而不是28，这是为什么呢？上例中char数组按照1字节对齐，char*按照8字节对齐。firstName占了20个字节，而lastName占8字节对齐。8字节对齐的意思是起始地址必须是8的倍数，所以lastName必须从24开始，占8个字节，一直到32。中间的四个字节填充0。所以struct Name的大小是32字节。关于字节对齐请看后文5.C语言的字节对齐 注意：对成员取sizeof，取到的是对齐前的宽度。 如果我们改成:12345struct Person { int8_t a; int16_t b; int8_t arr[20];}那么总共占多少个字节呢？最大成员对齐宽度是int16_t的2字节。所以对齐宽度是2字节。总字节数是1+2+20 = 23，向上对齐到24字节，填充一个字节凑成24，所以占24个字节；如果在添加一个int8_t d呢？刚好凑齐24字节，不需要填充，总数还是24字节。 如果把int16去掉，只剩下int8数组和int8变量呢？这时候发现占21个字节，没有对齐？因为成员的最大对齐宽度是1字节， 字节对齐和计算机结构相关，总线一般是32位的，按照总线能够传输的位数对齐能够加快传输速率，否则需要重新寻值在访存然后拼接结果。字节对齐出于计算机硬件性能的考虑。 投射操作符投射操作符语法：(type)expression，将表达式投射成指定的类型。投射过程不会改变原对象，而会创建一个新的临时对象，并将其赋值给新的变量。 投射表达式不能当左值。 c11对投射操作符的约束： 用于投射操作的类型名应该指定一个标量类型，即非数组类型，并且可以在该类型前添加_Atomic、const、volatile等限定符。 涉及指针类型的转换，除了允许隐式指针转换的情况，应该显示使用投射操作 指针类型和浮点数不能相互转换。 逗号操作符形式：a,b,c，其中a,b,c可以是任意表达式。逗号表达式将若干表达式按照指定次序执行，返回最右边的表达式的值。 需要注意，逗号表达式的优先级是最低的，一般要用括号括起来。","link":"/2019/11/13/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/3.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%BF%90%E7%AE%97%E6%93%8D%E4%BD%9C%E7%AC%A6/"},{"title":"2.C语言中的基本数据类型","text":"C语言中的基本数据类型分成两个大类，一类是整数类型（包括整数、布尔值、字符），另一类是浮点数类型。 基础数据类型都能进行+、-、*、/。整数还能按位和移位运算、浮点数不支持。 整数类型C语言中的整数类型包括char、short、int、long、long long、_Bool等。C语言没有具体规定每一种类型应占的大小，依据具体的实现来定。常见的规则是（GCC编译器、64位linux操作系统）： char 一个字节 short 两个字节 int 四个字节 long 8个字节 long long 8个字节 C语言规定了short&lt;= int &lt;= long &lt;= long long，在不同的编译环境和系统下，int可能和short一样是16位，而long和long long都是32位。 整数类型的最大值在limits.h中定义。1234567#include &lt;stdio.h&gt;#include &lt;limits.h&gt;int main(void) { printf(\"max int: %d, min int: %d\\n\", INT_MAX, INT_MIN); printf(\"max unsigned int: %u, max long: %lld\\n\", UINT_MAX, LONG_MAX);} 整数类型字面量的表示 int：1、2 unsigned int：1u、2u（U也可） short没有特殊的字面量 char：’A’，或者65均可 long：100l或者1000L unsigned long：1000ul long long：1000ll或者1000LL，limits.h中对应的是LLONG_MAX 除此之外，8进制使用0开头，16进制使用0x开头，二进制(c11)使用0b开头。1234567891011121314int a = 10;unsigned int b = +100u;unsigned c = -1u;// 将-1的二进制表示赋值给无符号整数，补码表示，符号位会保留。printf(\"%u+%u=%u\\n\", a, b, a+b);printf(\"c = 0x%X\\n\", c); // 显示0xFFFFFFFF，因为-1的二进制是100...0001，除了符号位按位取反+1，1111111....0+1 = FFFFFFFF// 上面显示的是补码。16进制显示的都是整数的补码表示。printf(\"%x + %x = %x\\n\", a, c, a+c);// 上面a+c，c是无符号整数、a是有带符号整数，但是+运算和带不带符号没有关系// +会将两个数的二进制表示相加（补码），产生的结果会溢出，溢出的结果被舍弃，所以其结果是9// 这也是补码运算的优势，可以统一正数和负数，有符号数和无符号数的运算规则。 布尔类型使用_Bool来声明，GCC编译器使用1个字节来存储。不能用signed和unsigned来修饰。 c99标准中在stdbool.h这个有文件中使用bool这个宏来代替_Bool，true定义1，false定义0。1234#include &lt;stdbool.h&gt;// ...bool flag = true;printf(\"%d\\n\", flag);因为bool、true、false，定义在stdbool中，所以只有引入这个头文件才能使用。而且bool和true都是宏，分别代表_Bool和1。 _Bool虽然只占一个字节，但是如果将int型作为_Bool，不是直接截断而是计算该int型的值是否等于0；对于浮点数也是同样的处理，看该浮点数是不是==0.0 字符类型char占一个字节，C语言规定至少能够放下基本ASCII字符集。一个char正好能够放下ASCII字符集。有些编译器会默认将char设置成无符号的，我们在编写程序时，如果想使用带符号的char，必须使用signed char。C语言中的signed char、char、unsigned char是不同的。limits.h中定义了char的最大值和最小值SCHAR_MAX等。 C语言中的转义字符：\\’，\\”，\\?，\\，\\123(八进制)，\\x0A(十六进制)，\\a，\\b（游标向前移动一个位置），\\f，\\n，\\r，\\t，\\v，\\0123456789signed char c1 = 100;signed char c2 = -10;// c2是负数（或者说二进制数&gt;127），不对应任何字符，打印出来是问号printf(\"%c - %c = %c\\n\", c1, c2, c1-c2);// 字符字面量可以有多个字符，赋值给char会最低字节截断，赋值给int，按照最低四字节截断（一个字符一个字节），以此类推。int c3 = '\\0cba';// '\\0cba\\刚好4个字节，赋值给int，\\0在高字节。再将int转成char*，变成4个元素的char数组，从低到高分别是abc\\0，打印出来是abc。printf(\"c3 = %s\\n\", (char*)&amp;c3); 宽字符和Unicode字符类型c99引入了wchar_t类型来表示一个多字节字符。wchar_t不是关键字，而是定义在stddef.h头文件中的一个宏类型，一般长度位四个字节，有的是两个字节。 宽字符根据当前操作系统语言环境设置，可能是UTF-16编码、GB2312等，不同的环境显示出来的字样可能不同。在GCC 8.3、linux 64位、zh_CN.UTF-8编码下，宽字符使用的是UTF-16编码。对于大部分中文和所有ascii字符，直接存储的是其码点。例如：123456789101112131415#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;string.h&gt;int main(void) { // gcc 8.3，centos7 64下为4个字节 printf(\"wchar_t size is %zd \\n\", sizeof(wchar_t)); // 宽字符必须使用单引号，然后加上大写的L，不能是小写的L wchar_t zw = L'中'; // 在当前环境下（gcc 8.3、linux 64、zh_CN.UTF-8）存的是UTF-16编码。 wchar_t en = L'A'; char* zw1 = (char*)&amp;zw; // wchar_t是int，4个字节，但是只用了两个字节，另外两个字节是0，所以strlen长度是2。 printf(\"%x %x\\n\", zw1[0], zw1[1]);}那我们怎么把’中’这个字符显示出来呢？首先我们明确，在内存中（不管是C还是其他语言，字符都存在内存中）字符都是数字，不管它如何编码。比如‘中’，用utf-8，在内存中就是3个字节；用utf-16在内存中就是两个字节。如何显示那是显示程序需要做的事情。例如我们把文档存为utf-8，那么文本编辑器使用utf-8解码才能正确显示；如果要在控制台显示，控制台如果使用的是utf-8编码，我们必须使用utf-8编码后的字节流输出到控制台，才能正确显示中文。 上面的代码示例中，L存的是UTF-16，直接使用printf或者puts输出到控制台肯定不能正确存储，只有转成UTF-8编码后（C语言中UTF-8直接使用char来存储，而UTF-16使用unsigned short ，UTF-32使用unsigned int *，c11定义了别名，后面会提到）。 c11引入了Unicode字符类型，在C中可以以UTF-8、UTF-16、UTF-32等方式来存储，通过在字符串前面添加u8、u、U来分别表示utf-8、utf-16、utf-32，如果没有加这些前缀，那么按照默认的编码方式来存储，不同的操作系统下不同的编译器会有不同的行为，Window下可能使用GBK，gcc使用和文件编码相同的方式，如果c文件是utf-8形式，那么存的就是utf-8，也可以通过编译器选项来指定输入编码。 在c11中引入了&lt;uchar.h&gt;头文件，里面定义了char16_t，char32_t来表示utf-16、utf-32编码的字符（utf-8直接使用char）。char16_t和char32_t实际上就是unsigned short 和unsigned int *的别名。 注意如果是四个字节的unicode码，那么utf-16会占两个字符 size_t和ptrdiff_t类型size_t主要用于sizeof操作符的返回类型。c11引入的_Alignof的返回类型也是size_t。size_t定义在stddef.h中。使用size_t的原因是，不同的操作系统返回的地址长度不同，有长有短，Windows下的MSVC在32位系统和64位系统下就不同，分别使用unsigned int和unsigned long long。GCC统一使用unsigned long。因为sizeof返回的数据长度不同，所以使用一个size_t来表示其类型而不是具体的int或者short等，size_t会根据系统的不同使用不同长度的数据。 ptrdiff_t类型用于两个指针相减后的结果类型，是带符号的，在stddef.h文件中定义。其长度和size_t相同，区别是size_t一般是不带符号的。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;int main(int argc, const char* argv[]) { printf(\"%d\\n\", argc); size_t a = sizeof(a); printf(\"%d\\n\", a); size_t *p = &amp;a; int b = 100; int *q = &amp;b; size_t s1 = (size_t)p; size_t s2 = (size_t)q; printf(\"Address of a is:0x%16zX\\n\", s1); printf(\"Address of b is:0x%16zX\\n\", s2); ptrdiff_t diff = (ptrdiff_t)q - (ptrdiff_t)p; printf(\"Address of a minux address of b is: %td\\n\", diff); // 上面输出的值是-4.因为p、q分别是a和b的地址（64位），a先声明，函数中变量从栈中分别，a的地址&gt;b，所以为负。 // 因为声明的b是int，占4个字节，所以是-4.如果将int改称long，那么返回的值将是-8. // 地址是64位的，但是变量长度可能是32位的。 return 0;} 标准整数类型前面提到的int、short、long等等在不同的编译环境下可能长度不同，那么我们想要相同长度类型怎么办呢？c99引入了标准整数类型，定义在&lt;stdint.h&gt;中，主要包含下面几类： 固定长度的整数类型：int8_t、uint8_t、int16_t、uint16_t、int32_t、uint32_t、int64_t、uint64_t。写代码的时候可以优先考虑使用这些标准固定长度类型。 最小宽度整数类型：(u)int_least8_t,(u)int_least16_t,(u)int_least32_t,(u)int_least64_t 最快最小宽度的整数类型：(u)int_fast8_t…。使用该类型的数据可能让编译器适配cpu执行更快速的指令。 能存放对象指针的整数类型：intptr_t,uintptr_t。用于将一个对象的地址或者一个指针对象的值用一个整数存起来。注意这里的intptr_t是一个整数类型而不是指针类型，将地址的值作为一个整数存起来。 最大宽度的整数类型：intmax_t和uintmax_t。存当前c实现支持的最大整数类型的值。 上述宽度除了8,16,32,64等，可能还有24,40,48,56。但是不一定所以编译器都支持。 1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;int main(int argc, const char* argv) { bool b = true; char c = 'A'; int8_t s8 = 10; uint16_t u16 = 100; int32_t s32 = 1000; // 使用ull保证字面量精度不丢失 uint64_t u64 = 10000ULL; int_least16_t l8 = 30; // 声明了至少16位的快速计算类型，在不同的系统下可能是不同的宽度，在gcc 8.3、linux 64下是long uint_fast16_t f16 = 40; // uintptr_t表示指针/地址，长度在不同系统系统中不同 uintptr_t p = (uintptr_t)&amp;b; printf(\"intmax_t size: %zu bytes\\n\", sizeof(intmax_t));} 浮点类型由三种浮点类型：float、double、long double。标准仅仅规定float是double类型精度的子集，double是long double类型的子集。 一般的C语言实现将float设置为32位浮点数，double为64位浮点数，使用IEEE754规格化浮点数。long double在x86架构处理器下是80位，在其他架构下可能和double相同，可能16字节。linux 64、gcc 8.3、intel i7下是16字节。 IEEE754浮点数表示法的细节： 首先明确几个概念：规格化数指没有前导0且小数点左边只有一位整数的采用科学计数法表示的数。在计算机中使用的是二进制规格化数，因为通过移动二进制表示中的小数点可以很方便的找到左边为1的位置。移动的位置数可以确定幂的指数。 然后二进制的浮点数怎么表示呢？使用符号位(s)+指数(e)+尾数(f)，对于32位浮点数，使用1+8+23；对于64位浮点数，使用1+11+52；那么对应的10进制值是$(-1)^s(1+f)2^E$.这里需要注意的是，在IEEE754标准中隐去了前导1，所以要在尾数上加上1. 指数有可能是负数，IEEE使用带偏阶的指数，32位浮点数偏阶是127($2^{8-1}-1$)，64位是1023($2^{11-1}-1$)，最终的计算公式如下：$(-1)^s(1+f)2^{e+b}$ IEEE将特殊的指数和尾数的组合表示特殊对象，例如指数和尾数都为0表示0；指数是255或者2048，尾数是0表示无穷，尾数不是0表示NaN。 将10进制浮点数转成二进制规格化浮点数的步骤如下：1.整数除二取余；2.小数乘2取整，直到结果为0。然后再将规则化的整数用二进制表示，注意隐藏前导1，并给指数加上偏阶。 示例：0.1和0.2的IEEE754浮点数表示。0.1=0.000110011001100110011001100，规格化后是$1.10011001100110011001100_2 * 2^{-4}$，带偏阶的指数是$-4+127=123=01111011_2$，所以0.1的二进制表示是0 01111011 10011001100110011001100。 $0.2_{10}=0.001100110011001100…_2$，规格化后是$1.10011001100…_2*2^{-3}$，带偏阶的指数是$-3+127=124=01111100$，0.2的二进制表示是0 01111100 10011001100110011001100 浮点数的加法： 浮点数相加的计算方法是：1.对齐：小的指数向大的指数对齐；2.尾数相加；3.结果规格化，检查指数上溢或者下溢；4.上溢或者下溢：异常；5.对尾数进行舍入，检查是否是规则化数；6.如果不是，返回第三步。 我们按照上面的规则，将0.1和0.2相加。$0.1=1.10011001100110011001100_22^{123}$，$0.2=1.10011001100110011001100_22^{124}$。1.对齐：$0.1=0.1100110011001100110011002^{124}$；2.尾数相加：10.011001100110011001100100；3.规格化：$1.00110011001100110011001002^{125}$；4.尾数舍入：$0.1+0.2=1.00110011001100110011001*2^{-2}$，换算成10进制就是0.299999982（0.1+0.2不一定总是小于3，在不同语言环境中可能大于3，这里只要只要它可能不等于3就可以了）。 很明显0.1+0.2是不等于0.3的。这是为什么呢？实际上我们看到，有限位的浮点数是不能够精确的表示0.1、0.2还有0.3的，保存的只是其近似值。在将0.1、0.2、0.3保存时，如何近似可能在不同的系统的不一样。而且0.1+0.2会存在舍入误差，在CPU浮点运算中通过保护位、舍入位、粘贴位来实现舍入。总之，近似表示和舍入误差让0.1+0.2!=0.3。浮点数能够精确表示的小数是有限的，因为尾数有限，不能精确表示的保存的都是近似值。 扩展：C语言中的i=0.3那么0.3会怎么存储呢？内存中直接有0.3这个值吗？答案是否定的，内存中肯定不会预先有0.3这个值。C编译器读入文本字符串，拿到了0.3这个字符串，然后会将其转成浮点数0.3。这个浮点数0.3直接存储在了指令内存区域中。 浮点数怎么比较是否相等？浮点数能精确表示哪些数？将两个浮点数相减，如果其差值小于一个给定的误差值，则说明在给定的误差范围内其值相等。javascript在ES6中提供了Number.EPSILON，如果误差绝对值小于这个值，则说明两个相等。浮点数能精确的表示有限个小数和有限个整数，因为其采用$(1+f)*2^e$的形式，尾数始终代表小数。64位浮点数在0-1之间最多能精确表示$2^{54}$个小数，能精确表示$2^{-53}-2^{53}$之间的连续整数。除此之外还有离散的一些整数。 C语言中的浮点数字面量最基本的表示方法就是十进制小数的表示方法，例如1.0、2.0、-0.5等等。如果小数部分为0，也可以写成10.、-5.；如果整数部分为0，可以写成.5。后面添加f表示是float，占32位，如果添加l/L说明是long double，默认是double。 还有就是科学计数法，例如3e5或6E-3。例如0x3.5p2表示$0x3.5*2^2$。p的左边是16进制整数或者浮点数，右边是十进制整数。注意上例中的3.5直接就是0011.1001。 float.h中定义了最大最大最小浮点数，FLT_MIN、DBL_MAX、LDBL_MAX。 数据精度和类型转换一个类型字节宽度越大，其精度越高，或者说“整数转换等级越高”。C语言有以下规定。 任意两个不同类型的整数不会有相同的精度 更高精度的带符号等级越高 同类型无符号和带符号等级相同 long long &gt; long &gt; int &gt; short &gt; char size_t和ptrdiff_t不应该高于long _Bool等级最低 隐式转换等级从低到高是一个隐式转换的过程，编译器会自动进行，例如将int赋值给long，那么int会自动转换成long。 进行运算或者赋值的时候，如果编译时整数溢出，gcc会给出一个warning，并且直接向上进位，溢出符号位部分忽略。浮点数不会有任何提示，会直接截断，如果截断的结果是ieee754的保留码，则会输出0或者inf等。如果运行时溢出，不会给出任何提示，直接进位。 带符号和无符号数之间的转换两个整数类型相互转换时，如果双方精度能够容下两个的所有位（包括符号位），那么所有位都会保留。反正就是那些二进制位，符号位是否表示正负看你是使用signed还是unsigned。 如果被赋值的精度小，那么直接将大精度的值高位截断。如果被赋值的精度大，则要看符号位。如果是无符号类型，高位填充0，如果是带符号类型，高位填充符号位。 123456789101112131415#include &lt;stdio.h&gt;int main(int argc, char* argv[]) { signed char c3 = -1; short s1 = c3; // 扩充1到高位 printf(\"%x %d %u\\n\", c3, s1, s1); short s = -129; unsigned char uc = s; // 截断，取低八位 printf(\"uc = %u\\n\", uc); unsigned short us = 1022; uc = us; // 直接截断，取低八位 printf(\"uc = %u\\n\", uc); return 0;} 类型投射符，使用()+类型进行类型映射，例如(int)a表示将a转换成int型数据 浮点数和浮点数的转换以及浮点数和整数之间的转换 单精度到双精度符号位不变，尾数低位补0，指数使用源指数加上1023（偏阶）。 双精度到单精度尾数和指数都会截断，会产生精度丢失。 浮点数到除布尔外的整数直接丢弃小数。int x = 100.10;x的值是100，.10会被丢弃。如果转换成char，那么先到int，int截断后到char。 整数到浮点数如果精度能够表示整数，值不变，只是变成浮点数。否则会丢失精度。","link":"/2019/11/11/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/2.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"10.C语言程序的编译上下文","text":"这篇文章学习C语言编译上下文相关话题。包括对象、函数以及类型标识符的作用域和名字空间，对象和函数的连接以及对象的生命周期。 作用域和名字空间标识符可以表示一个对象、函数、自定义类型及其成员、typdef名、调转标签名、宏名、宏形参。 C语言允许标识符被覆盖，允许真子集作用域覆盖父作用域中的标识符。 标识符代表的实体可访问的范围称为作用域。C语言一共有4中作用域： 函数作用域 文件作用域 语句块作用域 函数原型作用域 文件作用域文件作用域从当前源文件开始直到文件结束。 文件作用域内只能含有声明语句（包括函数和变量声明），不能含有其他语句。 示例：1234567891011121314151617181920212223242526272829303132333435#include &lt;stdio.h&gt;// OutStruct定义在文件作用域中// OutStruct这个标识符在其定义后的文件中都可用struct OutStruct { int a; // 嵌套定义的InnerStruct也有文件作用域 // InnerStruct这个标识符在其后的文件中也都可见 struct InnerStruct { int i; } inner; // 同上，定义的枚举常量M1，M2也在文件作用域中，可以直接访问 enum MY_ENUM { M1, M2 } e;};// sa也具有文件作用域// 这里能够直接访问嵌套定义的InnerStructstatic int sa = sizeof(struct InnerStruct);static void Test(void) { // 宏定义是文件作用域 #define M 100}int main(void) { struct OutStruct out = { 10, { 100 }, M2 }; struct InnerStruct inner = { 20 }; printf(\"The value is %d\\n\", out.a + out.inner.i + inner.i + sa - M);}要点： 嵌套定义的自定义类型有文件作用域，为了避免命名污染可以使用匿名自定义类型 宏定义有文件作用域 函数作用域调转标签是仅有的具有函数作用域的标识符。而且仅具有函数作用域，不受其他语句块作用域的影响。 goto和标签只能在函数中使用。 函数原型作用域简单来说，就是函数原型的形参列表。例如：123456// 返回类型为int(*)[4]，参数列表为int a, int (*)[4]// 这里定义的a，只在形参列表中可用static int (*Foo(int a, int (*pArray)[sizeof(a)]))[sizeof(int)]// 如果改成这样，就不行了，提示a未定义，因为超出了作用域static int (*Foo(int a, int (*pArray)[sizeof(a)]))[sizeof(a)] 语句块作用域如果一个标识符出现在语句块内，或者在函数定义的形参内，则具有语句块作用域。语句块是{}内的内容。 这里的{}不包括结构体联合体声明时的{}，它们属于声明语句，而不是语句块。 代码和注意事项：123456789101112131415161718192021222324#include &lt;stdio.h&gt;struct MyStruct { int a; // 报错，a未定义，因为a未定义在任何作用域中，它是结构体的一部分 int b[sizeof(a)]; // struct InnerStruct具有文件作用域 // 但是inner不是 struct InnerStruct{ int i; } inner; // 这里能访问strcut InnerStruct int c[sizeof(struct InnerStruct)];};// 这里的argc和argv都是语句块作用域int main(int argc, const char* argv[]) { // 这里的i在for语句块中有效 for(int i = 0;i &lt; 10;i++) { }} 标识符的重定义和叠加如果内部作用域是外部作用域的真子集，那么内部作用域会覆盖外部作用域中的同名变量。 标识符的名字空间前面提到了不同作用域中的标识符覆盖，这里学习同一作用域下的同名标识符的识别——名字空间。 C语言的名字空间和C++的命名空间(namespace)不是一回事。这里的名字空间用于区别同一作用域下不同类别的相同标识符。 有4类名字空间： 调转标签名 自定义类型 结构体成员，通过.或者-&gt;访问的标识符 其他标识符 同一类的标识符无法区分，如果重复定义编译器会报错。例如：12345678910111213int a = 0;// 下面会报错，重复定义aint a;// 下面不会报错，因为struct属于不同的命名空间struct a { int a;}// 下面会报错，struct和enum属于相同的命名空间enum a { A} 全局对象和函数前面学习了作用域和名字空间，下面学习对象和函数的连接，以及全局对象，静态对象等等。 C语言中函数和对象的连接指：一个对象或者函数标识符可以在不同作用域或者同一作用域内进行多次声明，而这些重复声明的作用域可以通过连接来引用同一对象或者函数。 C语言有三种连接：外部连接、内部连接和无连接。后面会分别介绍。 简单来说，连接就是确定不同标识符指向的实体之间的关系。如果是无连接，那么不同作用域内的标识符代表的就是不同的实体，相同作用域内声明相同标识符会报错。如果是外部连接，那么在不同的文件中可以引用同一个实体，只要有一个文件定义了，其他文件引用的都是这个实体，如果多个文件都定义了外部连接的同一标识符，则会报重定义的错误。如果是内部连接，那么该标识符只在该文件中可访问，如果一个函数声明为static，那么其他文件访问不到这个函数（仅只链接的时候，其他文件#include这个文件除外） 外部连接使用extern声明的对象和函数具有外部连接。 当在文件作用域中不使用extern进行定义，extern对象才有实体，并作为一个全局对象。简单来说，使用extern声明，在文件作用域的定义实体是全局对象。可以重复声明，但是只能定义一次。 函数默认有外部连接，也就是对于函数，extern和缺省都表示函数有外部连接。 12345678910111213141516171819202122232425262728293031323334353637383940// test.cextern int ga;extern int ga;extern void test(void);void test(void);void test(void) { ga = 100;}// linkage.c#include &lt;stdio.h&gt;// 对全局对象ga的定义，ga的外部连接声明在test.c中int ga;// 可以重复定义int ga;extern void test(void);// 声明为外部连接的全局对象extern int ma;// ma的定义int ma = 10;// 可以重复声明int ma;// 重复定义会报错// int ma = 20;int main(int argc, const char* argv[]) { // 可以重复声明，声明在该作用域可见 void test(void); // 语句块作用中声明必须带有extern关键字，否则不具有连接 extern int ma; test(); printf(\"result is %d\\n\", ga + ma);} 静态对象和函数用static修饰的对象和函数称为静态对象与函数。 static声明的文件作用域对象或函数具有内部连接。定义在语句块作用域中的静态对象没有连接。 内部连接是什么意思呢？就是说明该标识符表示的对象只在该文件中有效。如果我们在多个文件中定义非static的同名对象或者函数，那么会报重复定义的错误。多文件中的static对象是相互独立的。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162// test.c#include &lt;stdio.h&gt;static int sa = -10;static void SFoo(void) { sa++; printf(\"sa in %s = %d\\n\", __FILE__, sa);}void test(void) { SFoo();}// static.c#include &lt;stdio.h&gt;static int sa;static int sa = 100;static int sa;static void SFoo(void) { // 声明静态对象，只会初始化一次 static int inner = 100; // 报错，重复定义 // static int inner inner++; printf(\"inner = %d, sa = %d\\n\", inner, sa);}int main(int argc, const char*argv[]) { // 报错，非文件作用域内不允许声明静态函数 // static void SFoo(void); SFoo(); SFoo(); extern void test(void); test(); test(); static int sa = 10; printf(\"inner sa = %d\\n\", sa); SFoo(); static int inner = 120; int i = 0; while(i++ &lt; 5) { // 语句块作用域内的static不具有连接，但是在当前作用域及子作用域内是静态对象 // 静态对象的生命周期是整个程序，作用域是其声明的作用域 static int inner1 = 130; inner++; inner1++; printf(\"main while inner = %d，inner1 = %d\\n\", inner, inner1); // 输出131,132,133,134,135 } printf(\"main inner = %d\\n\",inner);} 注意：语句块作用域中的static不具有连接，但是具有静态对象的特性。静态对象的生命周期是全局的，同一作用域内只会被初始化一次。 局部对象函数形参，或者语句块作用域内没有用extern或者static声明的变量是局部变量。 局部变量不具有连接。 之间提到连接是对相同或者不同作用域内同一标识符对同一实体的引用。没有连接就是，没有引用关系，每个标识符代表的内容都是相互独立的。 例如：12345678int func() { // 外部连接 extern int ma; // 下面都是无连接 static int ma1； int ma2；}上面的ma具有外部连接，表示他指向的是全局对象ma的实体，对ma的定义可能在其他文件中。 ma1和ma2都是无连接，他们不会去引用其他实体，他们有自己的内存空间。 扩展：C语言的auto和register，auto告诉编译器该变量自动销毁（C++中的auto用于自动类型推导），C90以后已经废弃。register暗示编译器将该变量放到寄存器中，对于register变量不能取地址，具体存放在哪有编译器决定。 对象的存储和生命周期C语言中的存储区域： 全局数据存放区 栈存储区 动态分配的堆存储区 代码被放到指令存储区；全局变量被放在全局数据区，这里的全局变量是extern或者static在文件作用域中声明的变量；局部对象和函数形参存储在栈存储区；malloc等分配的内存在堆存储区。 _Thread_local对象C11添加了_Thread_local，是一个存储类说明符，表示该对象在任意线程中是私有的。 _Thread_local要么具有外部连接，要么具有内部连接。_Thread_local对象具有线程存储周期，从线程开始，到线程结束。 _Thread_local对象称为线程私有对象。那为什么有线程私有对象呢？因为线程间是共享内存空间的，对于程序的全局地址空间或者堆空间，内存是共享的。使用_Thread_local可以保证不同线程中使用的是独立的对象，不会相互影响。 注意需要使用编译时-l pthread来手动链接pthread库。12345678910111213141516171819202122232425262728293031#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;pthread.h&gt;// 线程私有的对象tastatic _Thread_local volatile int ta = 1;// 线程共有的对象isCompletestatic volatile bool isComplete = false;// 线程调度函数static void* MyThreadProcedure(void* param) { printf(\"Firstly, ta in user thread is %d\\n\", ta); // 因为_Thread_local是线程私有对象，所以这里ta和主线程中的ta是独立的 ta = 100; printf(\"ta in user thread is %d\\n\", ta); // isComplete是共享的 isComplete = true; return NULL;}int main(int argc, const char* argv[]) { printf(\"ta = %d\\n\",ta); ta = 20; pthread_t thread = NULL; pthread_create(&amp;thread, NULL, &amp;MyThreadProcedure, NULL); while (!isComplete) ; printf(\"ta in main thread is %d\\n\", ta);}","link":"/2019/11/20/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/10.C%E8%AF%AD%E8%A8%80%E7%A8%8B%E5%BA%8F%E7%9A%84%E7%BC%96%E8%AF%91%E4%B8%8A%E4%B8%8B%E6%96%87/"},{"title":"5.C语言的字节对齐和字节填充","text":"前面已经涉及到了一些字节对齐的知识。这里更加详细的学习C语言中的字节对齐和字节填充。 对于32/64位系统环境，通常编译器会默认对指令和数据进行4字节对齐。也就是说，一个函数的起始地址以及一个数据对象的起始地址斗会是4字节的倍数。在不同的CPU架构下对齐的字节数也不相同。 N字节对齐指分配该对象存储空间时，起始地址是N字节的倍数 _Alignof操作符一般基本数据类型参照的是其数据类型本身的大小。C11引入了_Alignof来查看指定对象的对齐要求。 _Alignof和sizeof类似，但有两点不同： _Alignof后面必须接圆括号 _Alignof操作数只能是类型名（基本类型、枚举类型等等），而不是一个表达式。GNU语法扩展能够让_Alignof的操作数是表达式。 _Alighof也返回size_t类型。 max_align_t表示当前实现对基本对齐要求的最大对齐的支持，max_align_t是一个类型。通过引入&lt;stddef.h&gt;使用。基本对齐要求指编译器默认对齐要求，对于存储空间很大数组或一个结构体，编译器会按照_Alignof(max_align_t)来对齐 引入对齐头文件&lt;stdalign.h&gt;可以使用alignof宏，和_Alignof等同。 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdalign.h&gt;#include &lt;stddef.h&gt;int main(int argc, char* argv[]) { size_t size = _Alignof(max_align_t); printf(\"size of max_alignof_t is : %zu\\n\", size); // 输出size of max_alignof_t is 16 // gcc 8.3 linux 64下最大默认对齐是16字节 size = alignof(bool); printf(\"Boolean size is : %zu\\n\", size); // 输出1 struct S { int a; float f; double d; long double ld; } s = { 0, 1.0f, 10.5, 1000.005L }; // 只能用alignof(struct S)，而不能用alignof(s) // 因为操作数只能是类型 size = alignof(struct S); printf(\"struct S's size is : %zu\\n\", size); // 输出16，因为long double是16字节，struct的字节对齐不小于其所有成员的字节对齐} _Alignas前面介绍了类型默认对齐以及_Alignof的使用，但是很多情况下默认对齐不能满足需要。通过_Alignas可以显式指定某一个对象以多少字节对齐。 _Alignas的用法和_Alignof类似，但是其操作数是一个常量表达式或者类型名。引入&lt;stdalign.h&gt;后，可以使用alignas宏。 _Alignas也有一些限制： _Alignas的操作数不能小于默认的对齐大小 _Alignas的操作数应该是0,1,2,4等无符号整数（2的幂次方），0表示采用默认对齐 编译器会指定最大可对齐的字节数，Apple LLVM是256MB _Alignas可以对同一个对象多次使用，取最大对齐数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdalign.h&gt;int main(int argc, const char* argv[]) { int a1 = 0; // 这里使用了GNU语法扩展，因为alignof只能接类型，但是这里接了表达式 // GNU扩展提供了表达式支持 size_t align = alignof(a1); printf(\"ai alignment is %zu\\n\", align); int _Alignas(double) a2 = 0; align = alignof(a2); printf(\"a2 alignment is %zu\\n\", align); // 输出8 // alignas可以放在int的前面，也可以放在int的后面 // 这里有多个alignas，取最大对齐 alignas(int) alignas(double) alignas(64) int a3 = 0; align = alignof(a3); printf(\"a3 alignment is %zu\\n\", align); // 0表示默认对齐 double alignas(0) d = 0; align = alignof(d); printf(\"d alignment is %zu\\n\", align); // 使用条件表达式来判断对齐基本要求 long long alignas(alignof(long long) &gt; 8 ? alignof(long long) : 8) ll = 0LL; align = alignof(ll); printf(\"ll alignment is %zu\\n\", align); // 对齐说明符也能修饰结构体 struct { int alignas(16) a; int b; }s = { 0, 6 }; size_t aa = sizeof(s.a), aaa = alignof(s.a); size_t sa = alignof(s), sa1 = sizeof(s); printf(\"%zu %zu %zu %zu\\n\", aa, aaa, sa, sa1); // 输出4 16 16 16 // 只是将a按照16字节对齐，即a的起始地址是16的倍数 // 但是并没有改变int的宽度，还是4 // struct的对齐不小于a，所以也是16 // 因为struct的对齐是16，所以尽管a+b=8字节，但是会填充8个字节的0变成16字节} 结构体成员的字节对齐与字节填充前面有多次提到结构体成员的字节对齐和字节填充，这里更加全面和深入的学习一下。 C语言的结构体的字节填充一般也是根据其成员的字节对齐情况来确定的。C11标准只是提到了一个结构体或联合体对象的每个非位域成员，以实现定义的、适合改成员对象类型的方式进行对齐；在一个结构体或者联合体的末尾可以做字节填充。 结构体的字节填充根据实现来定，对于主流桌面编译器来说。遵守一下规则来判定每个成员的字节对齐和字节填充： 结构体第一个成员所在的偏移地址为0 每个成员根据其类型或者程序员指定的对齐字节数来判定它所在的偏移地址。如果该成员按照4字节对齐，那么它所在的偏移地址是4的倍数，如果不是4的倍数，则向上取整到4的倍数的最小整数 当前成员的偏移地址到上一个成员之间存储空间用0填充 结构体对象的字节对齐与其成员的最大字节对齐要求一致 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdalign.h&gt;#include &lt;stdint.h&gt;int main(int argc, const char * argv[]) { struct { int8_t c; int32_t i; int16_t s; int64_t d; }s = { 0x10, 0x20, 0x30, 0x40 }; printf(\"s alignment is %zu\\n\", alignof(s)); printf(\"size is %zu\\n\", sizeof(s)); // 第一行输出8，第二行输出24 // 内存分布如下： // 0 1 4 8 10 16 24 // c 000i s 00000000 d // 第一个int8占一个字节，一字节对齐，放在[0,1) // 第二个int32占4字节，4字节对齐，所以起始地址必须是4的倍数，放在[4-7] // 中间的三个字节[1-4)填充0 // 第三个in16占两字节，2字节对齐，当前偏移地址是8，对齐了，放在[8-9] // 第四个int64占8字节，8字节对齐，当前偏移地址是10，没有对齐，向上取整8的倍数到16，放在[16-23] // 中间的6个字节[10-15]填充0} offsetof宏C标准中定义了offsetof宏，用于获取当前成员所在的偏移位置。定义在&lt;stddef.h&gt;头文件中。 123456789101112131415161718192021222324252627282930313233343536373839#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;stdalign.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;int main() { // s按16字节对齐，大小是32个字节，末尾4个字节填充0 struct S { // 2字节对齐，起始位置是0 int16_t s; // 4字节对齐，起始位置是4，占1个字节 alignas(int32_t) bool b; // 4字节对齐，起始位置是8，中间的5、6、7三个字节填充0 int32_t i; // 按照16字节对齐，起始位置是16，中间的[12-15]4个字节填充0 // 占12个字节，末尾的4个字节填充0 alignas(16) union { alignas(8) char c; float f; } un; } ss; size_t offset = offsetof(struct S, s); printf(\"s offset is %zu\\n\", offset); offset = offsetof(struct S, b); printf(\"b offset is %zu\\n\", offset); offset = offsetof(struct S, i); printf(\"i offset is %zu\\n\", offset); offset = offsetof(struct S, un); printf(\"un offset is %zu\\n\", offset); size_t size = sizeof(struct S); printf(\"size of struct S is %zu\\n\", size);} C语言会对结构体的末尾进行字节填充，一般来说，是根据当前结构体的对齐字节数来填充的，例如当前结构体的对齐字节数为16，结构体大小是8个字节，那么后面的8个字节填充0.","link":"/2019/11/17/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/5.C%E8%AF%AD%E8%A8%80%E7%9A%84%E5%AD%97%E8%8A%82%E5%AF%B9%E9%BD%90%E5%92%8C%E5%AD%97%E8%8A%82%E5%A1%AB%E5%85%85/"},{"title":"7.C语言中的控制流语句","text":"逗号表达式用于将若干表达式按序执行，并返回最后一个表达式的结果。 ,是一个双目运算符。 条件表达式结构：布尔表达式?表达式1:表达式2 分支语句if-else形式：123456789101112131415161718192021if(expression) 语句// 或者if(expression) { 语句块}// 和if(expression) { statements} else { statements}// 和if(expression) {} else if(expression2) {} else {} C语言一共有以下几种语句：标签语句、复合语句、表达式语句、选择语句、迭代语句、调转语句。 switch-case12345678910111213switch(expression) { case 整数常量表达式1: 语句1; 语句2; ... break; case 整数常量表达式2: ... break; ... default: ...} 要点： case后面只能是整数常量表达式，和js不同，js中是任意表达式都可。 如果没有break，那么会从匹配到的位置执行到switch结尾。 如果要在case中声明变量，必须使用语句块({})包起来 迭代语句使用continue和break可以跳过循环。continue跳过本次循环，直接执行下一次循环。break跳出循环。 while与do…while123456789101112while(expression) 语句；while(expression) { 语句块}do语句;while(expression);do { 语句块} while(expression); for1234for(expr1;expr2;expr3) 语句for(expr1;expr2;expr3) { 语句块} 要点： 三个位置都是表达式 expr2用作布尔表达式，值为true则继续。 每个表达式都可省略，如果省略expr2，则其始终为true 执行顺序是expr1-&gt;expr2-&gt;语句块-&gt;expr3-&gt;expr2-&gt;语句块-&gt;expr3-&gt;… gotogoto、continue、break、return统称调转语句。 continue用于循环，break用于switch和循环。 return用于函数返回。 goto相当于汇编中的jump、branch等。goto需要和标签配合使用：12345678NEXT: for(int i = 0;i &lt; 10;i++) { int a = 10; }if(a &lt; 10) { goto NEXT;}goto限制很少，能够调转到一个函数内的任何位置（因为标签的作用域是函数作用域），调转可能出现没有初始化的情况，而且影响可读性，要谨慎使用。但是用的好有奇效。","link":"/2019/11/19/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/7.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8E%A7%E5%88%B6%E6%B5%81%E8%AF%AD%E5%8F%A5/"},{"title":"C语言标准库","text":"这篇文章学习C语言标准库，包括基本数据类型对应的标准库例如stdbool以及数据结构算法、线程进程、网络等等的库。综合对这些库的介绍和使用示例。 stddef.h定义了以下常用的宏： offsetof：获取结构体成员的偏移位置（字节计数） stdalign.h定义了对齐常用的宏： alignof：_Alignof的别名，获取对象的对齐字节数，必须有括号 alignas：_Alignas的别名，设置对象的对齐字节数，可以放在类型的前面或者后面，可以重复声明多个alignas，取最大字节数 stdbool.h定义了布尔值相关的宏： bool：_Bool的别名，是一个类型，布尔类型，值为0或1，大小占1个字节 true：宏，值为1 false：宏，值为0 stdint.hint在不同的平台下的长度可能不一样，使用stdint可获取一样长度的整数，缺点是可能会影响性能。 定义了标准长度整数相关的宏： int8_t int16_t int32_t int64_t uintptr_t intptr_t wchar.h定义了宽字符wchar_t等 uchar.h定义了char16_t，char32_t等，表示c11新增的编码类型。 stdlib.h定义了malloc等 malloc abort exit stdarg.h函数不定参数获取宏等 stdnoreturn.h定义了noreturn，_Noreturn的别名","link":"/2019/11/18/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/C%E8%AF%AD%E8%A8%80%E6%A0%87%E5%87%86%E5%BA%93/"},{"title":"8.C语言中的函数","text":"借助函数可以写出更良好的结构化、模块化代码。 函数调用者传递参数给被调用函数，控制权交给被调用函数（入栈），被调用函数执行完成以后（出栈），返回到函数调用者。 函数的声明和定义 声明： 1返回类型 函数名(类型1 形参1, 类型2 形参2, ...); 形参可为空。函数给明给出了函数原型。原型中可以给出不完整类型，例如(int[])。 定义 123(extern or static) 返回类型 函数名 (参数列表) { statements} 函数定义如果缺省extern或在static，则默认为extern。 如果函数调用的位置没有发现原型或者函数定义，编译器会警告。最好给函数在最前面声明原型。 函数只能在文件作用域中定义。 函数调用形式：12345funcName(int aa, int bb) {}funcName(a, b);a、b称为实参，aa、bb称为形参，形参和实参是相互独立的。调用的时候，会将实参的值赋值给形参。如果是指针，赋值的是指针的值，但是两个指针是相互独立的。如果是结构体，那么会将结构体的所有成员复制到形参对象中。 调用表达式的执行顺序C语言标准没有说函数标识的计算对于实参的计算之间有顺序，因此对于函数标识的计算和实参的计算谁先谁后是不确定的。 1234567891011121314151617181920212223242526272829#include &lt;stdio.h&gt;void static Func1(int a) { printf(\"f1 a = %d\\n\", a);}static void Func2(int a) { printf(\"f2 a = %d\\n\", a);}static void Func3(int a, int b) { printf(\"f3 b - a = %d\\n\", b - a);}int main(int argc, const char* argv[]) { void (*pFunc[2])(int) = { &amp;Func1, &amp;Func2 }; int i = 0; // 输出f1 a = 1 pFunc[i++](i); // 输出f2 a = 2 pFunc[i](++i); // 输出f3 b - a = 1 Func3(i++, i); // gcc下，先计算标识符的表达式，再计算实参表达式 // 函数调用的时候，先计算前面的实参表达式，再计算后面的实参表达式 return 0;} 不同的编译器的表达式计算顺序情况可能不一样。根本原因是为了再多核心处理器下并行。 对一个函数的调用要经历三个步骤： 对函数标识表达式计算 函数实参的计算 函数调用 函数的栈空间每个函数都有自己独立的上下文存储空间，此存储空间是栈式的。 函数中定义的局部对象在函数调用结束后从栈中弹出。 函数调用的的参数传递和返回结果都存储在栈空间中。 通过形参改变实参的值使用指针（C++中可以使用引用类型）。12345void swap(int *a, int *b) { int temp = *a; *a = *b; *b = temp;} 数组类型作为函数形参如果一个函数的形参是一个数组类型，那么它会被调整为指向该数组元素类型的指针。如果类型还有限定符，在[]中添加，例如：1int main(int argc, char* argv[const]) {} 当然，写成下面的形式也是可以的：1int main(int argc, const char* argv[]) {} 对于函数声明，可以具有不完整类型，例如int[]或者int[*]（表示变长数组类型）。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;static void Func1(int a[*]);// 定义的时候不能在使用int[*]了static void Func1(int a[]) { if(a != NULL) printf(\"a[0] = %d\\n\", a[0]); printf(\"size of a = %zu\\n\", sizeof(a));}// 指定a[10]没有作用，因为a会被转为int*// int a[10]和int a[]没有区别static void Func2(int a[10]) { if(a == NULL) puts(\"Nil!\"); printf(\"size of a = %zu\\n\", sizeof(a));}// GCC下，会被转为const int *，5没有作用// 实参可以传任意长度的数组static void Func3(int a[static const 5]) { int sum = 0; for(int i = 0;i &lt; 5;i++) sum += a[i]; a[0] = 100; // a = NULL; // 报错，a是const，不能被指定为其他值 printf(\"sizeof a = %zu\\n\", sizeof(a));}static void Func4(int a[static const 2][*]);// 这里a的类型是，const int(*)[3]// 所以输出其长度是12字节static void Func4(int a[static const 2][3]) { printf(\"size of a[0] = %zu\\n\", sizeof(*a)); a[1][2] = 20;}int main(int argc, const char* argv[]) { Func1((int[]){1,2}); Func2(NULL); int array[] = {1,2,3,4}; Func3(array); printf(\"array[0] = %d\\n\", array[0]); int darray[][3] = { 1,2,3,4,5,6 }; Func4(darray); printf(\"darray[1][2] = %d\\n\", darray[1][2]);} 对于形参，声明数组的长度没有作用，数组形参都被被转为相应的指针 函数的不定参数C语言函数形参列表的最后可以使用...表示不定长度的参数。 形式：123456void func1(int a, ...);// 错误，前面至少有一个参数void func1(...);// 错误，后面不能再有参数void func1(int a, ..., int b); 因为不定参数的类型不确定，编译器会将精度小于int的实参转为int，float转为double 需要借助&lt;stdarg.h&gt;宏来获取不定形参。涉及到如下宏： va_list：是一个完整类型，保存下面几个宏的状态信息 va_start：初始化va_list对象 va_arg：获取形参，会自动向后移动 va_end：无效化va_list对象 va_copy(dest, src)：src和dest都是va_list对象，将src完全拷贝（包括遍历状态）到dest 示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;#include &lt;stdint.h&gt;static void Mytest1(int n, ...) { va_list ap; // 对ap初始化，并指明形参n是在...之前的形参 va_start(ap, n); int a = va_arg(ap, int); unsigned b = va_arg(ap, unsigned); double d = va_arg(ap, double); // 传了三个实参，但是取了4个形参，gcc下不会报错，但是取出来的内容是任意值 int x = va_arg(ap, int); printf(\"x = %d\\n\", x); va_end(ap); printf(\"a = %d,b = %u,d = %f\\n\", a, b, d);}// 如果直接传一个va_list对象初始化过，则不需要再次初始化static double MyFunc(int n, va_list ap) { int a = va_arg(ap, int); unsigned b = va_arg(ap, unsigned); double d = va_arg(ap, double); return n + a + b + d;}static void MyTest2(int n, ...) { va_list ap; va_start(ap, n); double result = MyFunc(n, ap); va_end(ap); printf(\"result is %f\\n\", result);}struct MyStruct { int a,b; };union MyUnion { char c; short s; };// 对于struct和union也能正确取值static void MyTest3(int a, ...) { va_list ap; va_start(ap, a); struct MyStruct s = va_arg(ap, struct MyStruct); union MyUnion un = va_arg(ap, union MyUnion); printf(\"size of MyUnion is %zu\\n\", sizeof(un)); va_end(ap); int result = a + s.a + s.b - un.s; printf(\"result = %d\\n\", result);}int main(int argc, const char* argv[]) { int8_t a = 10; uint16_t b = 20; // 实参会晋升，a、b都会变成int，10.5f会变成double Mytest1(3, a, b, 10.5f); MyTest2(5, a, b, 10.5f); MyTest3(10, (struct MyStruct) { 1, 2 }, (union MyUnion) { .s = 3 });}要点： va_list能够当作单独的类型使用 不定参数的使用流程如下： 定义va_list对象ap va_start(形参,ap)初始化ap va_arg(ap，类型)获取参数值，自动迭代 va_end(ap)销毁va_list对象 函数的递归调用递归调用是栈式的，如下：123f(3) f(2) f(1) f(0)|---调用-&gt;|-调用-&gt;|---调用-&gt;||&lt;-返回---|&lt;-返回-|&lt;---返回-|递归一定要注意边界，无限递归会造成栈溢出。 深度搜索，归并等算法都使用递归来实现。 内联函数C99标准加入inline关键字。inline和_Noreturn都属于函数说明符，仅用于函数的声明中。 如果一个函数用inline函数说明符进行声明，那么该函数是一个内联函数，暗示编译器对该函数的调用尽可能地快. 具有内部连接的任一函数都可以作为一个内联函数。 下面是内联函数的使用和注意事项：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455#include &lt;stdio.h&gt;inline int Func(int n) { return n * 2;}extern inline int Func2(int n) { // 外部内联函数中出现静态对象编译器会警告 static int s; s += n; return s + n;}static inline int Func3(int n) { // 内部内联函数可以包含static static int s; s += n; return s + n;}// mytest定义在hello.c中extern void MyTest(void);int main(int argc, const char* argv[]) { int result = Func(3); printf(\"result = %d\\n\", result); MyTest(); result = Func2(10); printf(\"result in main is %d\\n\", result); result = Func3(1); printf(\"result 1 = %d\\n\", result); result = Func3(2); printf(\"result 2 = %d\\n\", result);}// hello.c的内容#include &lt;stdio.h&gt;int Func(int n) { return n * 3;}// 这里如果加上extern，就重复定义了，链接器链接的时候会报错inline int Func2(int n) { static int s; s += n; return s+n;}void MyTest(void) { printf(\"value is %d\\n\", Func2(2)); int result = Func2(20); printf(\"result in MyTest is %d\\n\", result);}通过gcc inline.c hello.c，gcc会自动编译两个c文件并链接称可执行程序。 inline的注意点： inline知识给出编译器优化建议，怎么处理有编译器决定 外部连接函数如果用inline声明，那么声明和定义应该在同一个文件中 外部连接的内联函数，不应该使用static对象 函数的返回类型与void记住下面几个要点就行： 返回类型可以是除了数组之外的任意类型，可以使用指针实现返回数组的功能 函数遇到return会立即返回，return的表达式类型必须和返回类型兼容 reuturn后面为空，表示返回void C11引入了_Noreturn，表示该函数体内不应该出现任何return语句，其返回值为void。&lt;stdnoreturn&gt;头文件中定义了noreturn宏 指向函数的指针函数指针类型的通用表达形式：1返回类型 (* 可选限定符const等) (形参列表) 函数指针要求和函数定义的返回类型和形参列表一样，但是可以是不完整类型。 对于void Func()，Func和&amp;Func都表示函数指针，类型是void (*)(void)，但是注意对于void (* pFunc)(void)，pFunc是指针，不是函数标识，所以&amp;pFunc肯定不等于pFunc。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051#include &lt;stdio.h&gt;#include &lt;stdarg.h&gt;struct MyStruct;static struct MyStruct (*p)(struct MyStruct s, int a[*]) = NULL;static void Test(void);static int Foo(int n, ...) { va_list ap; va_start(ap, n); int sum = 0; for(int i = 0;i &lt; n;i++) { sum += va_arg(ap, int); } va_end(ap); return sum;}int main() { void(*pf)(void) = Test; // 也可以使用pf() (*pf)(); pf(); // 对于数组，a和&amp;a也是相等的 int a[] = {1,2,3}; printf(\"a == &amp;a? %d\", (unsigned long)a == (unsigned long)&amp;a); int (*pFunc)(int, ...) = &amp;Foo; int (**pp)(int, ...) = &amp;pFunc; // 下面两种调用方式也是相同的 int result = (*pp)(5, 1,2,3,4,5); int result2 = (**pp)(5, 1,2,3,4,5); printf(\"result == result2? %d\\n\", result2 == result);}struct MyStruct { int a; float f;};static struct MyStruct Func(struct MyStruct s, int a[]) { printf(\"sum = %f\\n\", s.a + s.f + a[0]); return s;}static void Test(void) { p = Func; p((struct MyStruct){.a = 10, .f=.5f}, (int[]){1,2,3});} 注意点： (*pf)()和pf()一样 如果Func是函数标识符，Func==&amp;Func。数组也是a == &amp;a 注意函数指针的类型是 类型 (*)(形参列表)， main函数要点如下： 返回类型应该是int，用于返回给操作系统 可以有两种类型的参数：int main(void)或者int main(int argc, const char* argv[])，argc表示传入字符串的个数。argv是字符指针数组，argv[argc]应该是NULL。argv[0]表示当前程序名，1到(argc-1)是传过来的命令行参数。 main不能是static、inline、_Noreturn 函数与sizeofsizeof不能用于： 函数，但是sizeof(&amp;Func)是合法的 不完整类型表达式 位域 _Alignof不能用于： 函数 不完整类型 sizeof(Func())，返回的是Func返回类型的大小，而不是返回表达式的大小！函数调用也不会发生！","link":"/2019/11/19/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/8.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E5%87%BD%E6%95%B0/"},{"title":"less快速入门","text":"less是一门css预处理语言，添加了变量，mixin，函数等特性，使得css更易维护和扩展。less可以运行于node服务器或者浏览器端。 less完全支持css语法，并在此基础上进行的扩展 变量变量以@开头，只能定义一次，实际上就是一个常量，例子：123456@nice-blue: #3242b3;@light-blue: @nice-blue+#111;#header { color: @light-blue;} mixinminxin其实就是将一个代码片段抽离出来，可以复用，例子：1234.bordered { border-top: 1px solid black; border-bottom: 1px solid black;}然后要复用这一块代码，只需要将.bordered放到另一个代码块中。1234#menu a { color: gray; .bordered;}这里使用class来实现mixin，也可以用id 嵌套规则less允许嵌套规则，例子：123456789#header { color: black; .navigation { font-size: 12px; } .logo { width: 300px; }}利用嵌套规则可以少写很多代码，同时利用嵌套规则可以得到和html类似的即结构。 类似于sass，可以使用&amp;在嵌套中指代父选择器：1234567.parent { color: black; &amp;:after { content: \"\"; display: block; }} 嵌套指令和冒泡media和keyframes这样的指令可以和选择器一样嵌套。向@media、@supports、@document这样的条件指令会冒泡到最顶层，并将顶层的选择器置于他们之间，例子：1234567891011.screen-color { @media screen { color: green; @media (min-width: 768px) { color: red; } } @media tv { color: black; }}编译后会得到123456789101112131415@media screen { .screen-color { color: green; }}@media screen and (min-width: 768px) { .screen-color { color: red; }}@media tv { .screen-color { color: black; }}","link":"/2019/06/11/css/less/less%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"9.C语言预处理器","text":"C语言编译器前端还分为预处理阶段和编译阶段。预处理阶段是通过C语言的各类预处理器将指定的一些字符符号直接替换到即将编译的源代码。通过预处理器可以在不同的平台上插入不同的代码，还可以将某些代码抽象成宏定义。 C语言的三大类预处理指示符： 条件段预处理 控制行预处理，例如宏定义 空指示符 这篇文章学习条件预处理、文件包含、宏替换、行控制、错误指示符、编译指示符(pragma)、空指示符以及C11标准中定义的宏名。 对于预处理指令有一些规则： 对于任意一条预处理指示符，除了_Pragma之外，其他的必须以#开头，并且#必须出现在每一行的最前面（#前面可以有空白字符）。 预处理指令无需加分号 有范围的预处理器的范围是起始指示符的下一行到结束指示符的上一行 宏定义宏定义属于控制行预处理指示符。以#define定义的一个符号称为宏。 C语言的宏定义由两种方式：类似对象的宏定义以及类似函数的宏定义。12345// 类似对象的宏定义#define 标识符 替换列表 换行符// 类似函数的宏定义#define 标识符(参数列表) 替换列表 换行符宏定义用于将标识符替换位替换列表中的内容，其作用范围是从它定义完的那个位置起一直到当前源文件结束。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657#include &lt;stdio.h&gt;/** * 下面是宏定义部分的代码 */#define MY_MACRO#define MY_MACRO1 100#define MY_MACRO2 10 + a// 定义一个宏，宏的内容是一个函数// 如果代码较长，通过\\+换行符表示单行#define MY_MACRO3 static int Foo(void) {\\ return 1;\\}// 预处理时会替换，相当于定义了一个函数MY_MACRO3// 定义了一个宏函数，交换两个实参的值// MY_SWAP与(之间没有空格// 这里假定x和y都是整数类型#define MY_SWAP(x, y) { int temp = x; x = y; y = temp; }static void Dummy(void) { // 两个点： // 1.有空格，不是宏函数而是宏对象 // 2.尽管在函数中定义但是作用范围是其后的整个文件 #define MY_MACRO4 (a,b)}int main(int argc, const char * argv[]) { // MY_MACRO不包含任何替换符号，会被忽略 int a = MY_MACRO MY_MACRO2; // 变成10+a*3 int b = MY_MACRO2 * 3; printf(\"a = %d, b = %d\\n\", a, b); // a = 10, b = 40 a = Foo(); printf(\"a = %d\\n\", a); // a = 1 // 替换成{ int temp = a; a = b; b = temp; } MY_SWAP(a, b) printf(\"a = %d, b = %d\\n\", a, b); // a = 40 b = 1 // 替换成a = (a, b) a = MY_MACRO4; // 这里会输出ok if (a == b) { printf(\"ok\\n\"); }} 在预编译阶段会替换宏定义，同时会合并空白符。 在编译器命令行中也可以使用宏定义，例如-D MY_MACRO=100. 要点： 不管是宏对象还是宏函数都是单行的。如果多行需要\\ 宏函数标识符与(之间不能有空格 宏定义作用域整个文件 宏定义直接替换，在编译之前 替换列表中的前后空白会忽略，但是中间的空白会保留 宏函数中参数的所有空白（包括前后空白）都会保留，#操作符会忽略前后空白 宏定义中的#操作符要点： #用于宏函数定义 #后面接形参名（#和名字之间可有空格），表示将其内容作为字符串字面量表示 预处理符号不同于C语言的标识符，可以作为预处理符号的如下： 头文件名 标识符 预处理数字 字符常量 字符串常量 标点符号 所有非空白符号，并且不是上面的符号 上述所有内容包括标点字符都会保留，但是不能只出现一个’或者”的情况 宏函数前面的参数可以忽略，置空用逗号隔开 1234567891011121314151617181920212223242526272829303132/** * 宏定义中的#操作符 */#define MY_MAFUC(x) #x#define MY_MAFUC2(x, y) #x \"\\n\" #yvoid sharp() { const char* s =MY_MAFUC(10ab); printf(\"this literal is %s\\n\", s); if(strcmp(s, \"10ab\") == 0) { puts(\"Equal!\"); } // 对于#操作的实参的空白符，前后空白符都会被删除 // 同时\"\\\"会被替换成\"\\\\\"，\"和'等也会被转义 s = MY_MAFUC( 10\"ab\\n\" ); if(strcmp(s, \"10\\\"ab\\\\n\\\"\") == 0) printf(\"Equal\\n\"); // 逗号包括在圆括号中不作为实参分隔符 // 都在在''或者\"\"中也不作为实参分隔符 s = MY_MAFUC2((123abc,45;'0'), [1a2b3c:?','=]); printf(\"string is :%s\\n\", s); // 输出string is :(123abc,45;'0') //[1a2b3c:?','=] // 圆括号也会保留 s = MY_MAFUC2(,abcd); printf(\"s = %s\\n\", s);} 宏定义中的##操作符简单来说，##用于拼接。例如#define CONCAT(x) x##10，将10接到x的后面，并且替换后的不是字符串，而是原内容。例如CONCAT(10)，替换后的是1010，而不是字符串”1010”，这和#不同。结果1010可以赋值给整型变量，int x = CONCAT(10)。 ##后面可以接宏函数参数，也可以接常量 1234#define CONCAT(x,y) x##10 + 0x##yint a = CONCAT(10, 16);// 将被替换成 int a = 1010 + 0x16 宏替换 同一文件作用域内，不能出现两个名称相同的宏标识符。但是同一个宏可以重复定义。 替换列表之前和之后的空白符，都不属于替换列表，会被忽略 一个宏定义中可以引用另外一个已定义的宏，宏定义可以连续扩展，但是不能递归，替换顺序如下： 处理替换列表中的#和## 展开掉替换列表中的宏 检查实参是否引用了宏，替换实参宏 用扩展后的实参替换形参宏 宏定义不能递归（包括直接递归和间接递归），递归的宏不会被替换 替换后出现在#define这样的预处理结构，编译器会报错 12345678910111213141516171819202122232425262728293031323334353637383940#include &lt;stdio.h&gt;// 允许定义两个完全相同的宏#define MY_MACRO(x) x + x ## 0#define MY_MACRO(x) x + x ## 0#define LITERAL(x) #x// 替换类标引用了宏LITERAL#define MY_MACRO2(x) LITERAL(x)#define CONCAT(x,y) x ## y ## ELLOint main(void) { // 替换为10 + 100，所a = 110 int a = MY_MACRO(10); printf(\"a = %d\\n\", a); // #和##的优先级最高，所以MY_MACRO(20)，直接当作字符串返回了，不会继续扩展 // s = MY_MACRO(20) const char *s = LITERAL(MY_MACRO(20)); printf(\"s = %s\\n\", s); // 替换顺序是# -&gt; 替换列表的宏 -&gt; 实参宏 -&gt; 形参宏 // 1. 替换MY_MACRO2，得到LITERAL(x) // 2. 替换LITERAL(x)，得到#x。这里的#x是扩展出来的（不是MY_MACRO2替换列表中的），所以不会将实参作为字符串，接下来扩展实参 // 3. 替换MY_MACRO(20)，得到20 + 200 // 4. 替换形参#x得到字符串\"20 + 200\" s = MY_MACRO2(MY_MACRO(20)); printf(\"s = %s\\n\", s); // 这里会得到#defineELLO，得到#开头的预处理指令，编译器会报错 // CONCAT(#, define); // 这里先扩展MY_MACRO2，得到LITERAL(x) // 继续扩展，得到#x，#x不是MY_MACRO2替换列表中的，不会优先处理 // 然后扩展实参CONCAT(if, def H)，得到ifdef HELLO // 替换形参#x得到\"ifdef HELLO\" s = MY_MACRO2(CONCAT(if, def H)); printf(\"s = %s\\n\", s);} 可变参数的宏定义从C99标准起，C语言开始加入了不定参数个数（可变参数）的宏定义。定义可变参数的宏函数时，宏的形参列表使用…来表示。再替换列表中，用VA_ARGS来表示…对应的参数内容。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#define VARIDIC_MACRO1(...) \"the String is: \" #__VA_ARGS__#define VARIDIC_MACRO2(...) (__VA_ARGS__ ## 100)#define VARIDIC_MACRO3(a, ...) (a __VA_ARGS__ 10)#define LITERAL(x) #x#define VARIDIC_MACRO4(X) LITERAL(X)int main(void) { const char *s = VARIDIC_MACRO1(\"Good Luck!\"); printf(\"s = %s\\n\", s); // 这里的参数作为一个整体，而不是三个参数 s = VARIDIC_MACRO1(Say \"Hi\"!, Byebye, Thank you); printf(\"s = %s\\n\", s); // 输出：s = the String is: Say \"Hi\"!, Byebye, Thank you // 替换成int a = (10, 20, 30100)，右边是一个逗号表达式，值为30100 // 输出：a = 30100 int a = VARIDIC_MACRO2(10, 20 ,30); printf(\"a = %d\\n\", a); int b = 0; // 替换成 (++b - 20 + 10) // a = -9, b = 1 a = VARIDIC_MACRO3(++b, -20 + ); printf(\"a = %d, b = %d\\n\", a, b); // 因为第一个参数被忽略，所以其为空，替换成( 30 * 10) // 注意30前面的空格被吃掉了，但是*后面的空格保留了 a = VARIDIC_MACRO3(, 30 * ); s = VARIDIC_MACRO4(VARIDIC_MACRO3(, 30 * )); printf(\"s = %s\\n\", s);} 要点： 宏函数只有…，那么实参会当作一个整体传给宏函数 如果有参数，那么后面的参数会当做一个整体，包括’,’ __VA_ARGS表示的是形参中的…部分 C语言中预定义的宏C语言标准值出了C语言实现（即编译器）必须实现的预定义宏以及可选的预定义宏。 C语言中的预定义宏分为三类： C语言标准强制要求预定义的宏 环境宏，可选实现的预定义宏 条件特征宏，这也是可选的 C语言强制要求的预定义宏 __DATE__：表示当前日志，形式为Mmm dd yyy，Mmm是月份的缩写 __FILE__：当前源文件 __STDC__：如果值为1，说明当前C语言实现遵循C语言标准 __STDC_HOSTED__：主机端实现值为1，独立式实现值为0.主机端实现值当前C源代码最终编译成当前平台目标兼容的二进制代码文件 __STDC_VERSION__：当前C的版本，例如201710，C17版本 __TIME__：当前实现，形式为hh: mm: ss __func_：当前函数名 1234567891011#include &lt;stdio.h&gt;int main(void) { printf(\"The current date is: %s\\n\", __DATE__); printf(\"The current time is: %s\\n\", __TIME__); printf(\"The current file is: %s\\n\", __FILE__); printf(\"The current function is: %s\\n\", __func__); printf(\"The current line is: %d\\n\", __LINE__); printf(\"The current stardard is: %ld\\n\", __STDC_VERSION__); printf(\"The current date is: %d\\n\", __STDC_HOSTED__);} 环境宏确定字符编码支持情况。1234printf(\"The current standard time is: %d\\n\", __STDC_ISO_10646__);printf(\"The current support utf-16 is: %d\\n\", __STDC_UTF_16__);// 支持UTF-32，值为1，上同printf(\"The current support utf-32 is: %d\\n\", __STDC_UTF_32__);_ 条件特征宏C标准中有一些语法特性是C语言编译器可选实现的，编译器根据这些宏来指明自己是否支持这些特性。 例如STDC_NO_THREADS用于指明当前C语言实现支持不支持&lt;threads.h&gt;头文件；STDC_NO_VLA指明当前C语言实现支不支持变长数组。 主流编译器及平台预定义的宏以下预定义宏不是C标准指定的，而是编译器实现的。 _MSC_VER：如果定义了该宏，编译器是MSVC __GNUC__：GCC或者兼容GCC的编译器 __clang__ __i386__：生成目标是32位x86处理器 __x86_64__：x86_64处理器，运行再64位系统模式 __arm__ __arm64__ __APPLE__ __unix__ __linux__ _WIN32 _WIN64 __LP64__ 条件预编译条件预编译用于控制所要编译的代码。条件预编译中的条件为真时，这段代码参与编译，否则不参与编译。 注意：这里的编译不仅仅指编译，也指预处理。如果条件为假，代码块中的预处理指令也不会执行 控制条件包含的表达式应该是一个整数常量表达式。 此外还支持defined表达式，类似于sizeof，有两种形式defined 标识符和defined(标识符)。defined只能和条件控制语句联合起来使用，defined后面的标识符应该是一个宏名，如果该宏已经被定义，其值为1。还可以使用!defined #if和#elif预处理指示符语法:1234567#if 常量表达式 换行符 // 代码块#elif 常量表达式 换行符 // 代码块#else // 代码块#endif 如果常量表达式的值等于0，结果为false，否则为true。 常量表达式可以使用布尔表达式，可以使用==、!=、&amp;&amp;、||、!和算术运算。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566#include &lt;stdio.h&gt;int main(void) { #if 3 + 5 puts(\"No zero expression\"); #endif puts( #if 0 \"0\" #elif 3 - 3 \"1\" #else \"2\" #endif ); #define HELLO #if defined(HELLO) puts(\"HELLO defined\"); #endif #if defined(HELLO) &amp;&amp; defined(HI) puts(\"Both defined~!\"); #endif #define HI 2 #if defined(HELLO) &amp;&amp; defined(HI) &amp;&amp; (defined(HELLO) + defined(HI)) == HI printf(\"HI value: %d\\n\", HI); #endif // aa 不是预处理阶段的标识符 int aa = 100; #if aa == 100 puts(\"aa is defined\"); #else puts(\"aa is not defined\"); #endif // 预处理阶段定义了aa，并且aa的值是20 #define aa 20 #if aa == 20 puts(\"Yep!\"); #endif printf(\"aa = %d\\n\", aa); enum { M1, M2, M3 }; // M2不是预处理阶段的标识符 #if M2 == 1 puts(\"M2 is defined!\"); #else puts(\"M2 is not defined\"); #endif // 下面会报错，因为sizeof只能在编译阶段调用，sizeof不是合法的常量表达式 // #if aa == sizeof(int) // puts(\"Yep!\"); // #endif} #ifdef和#ifndef#ifdef和#if defined类似，#ifndef和#if !defined类似（if not defined）。不同点是#ifdef和#ifndef后面只能跟预处理标识符，而不能跟常量表达式。 ifdef和ifndef后面也要接#endif. #include预处理指示符通过头文件，可以将自己源码中的对外函数接口以及数据类型等共享给其他开发者。C语言的头文件以.h文件结尾，使用#include指令包含头文件。 #include有两种形式： include &lt;头文件名&gt; 换行符 include &quot;头文件名&quot; 换行符 &lt;&gt;指定的文件路仅的搜索是实现自定义的，默认是操作系统存放库头文件的系统路径。也可以通过编译器环境变量和编译器命令行选项来指定。(例如在操作系统实现中，就不使用标准库，自定义了&lt;&gt;的查找位置) &quot;&quot;对指定的文件进行搜索，通常就是当前C语言工程项目下的路径；如果搜索不到，则换用&lt;&gt;进行搜索。 一般来说，对C语言标准库，我们使用&lt;&gt;，而对于自己编写的头文件，使用&quot;&quot;。 #include后面可以跟一个宏名 12345678910111213141516171819202122232425262728293031// 头文件的内容#ifndef defs_h// 用于防止重复include文件或者间接重复include#define defs_h#include &lt;stdio.h&gt;#define MY_MACRO 100struct S { int a; float f;};static void MyFunction(struct S s) { printf(\"The value is %f\\n\", s.a+s.f);}#endif// include文件中的内容#include \"defs.h\"// defs.h中已经包含了&lt;stdio.h&gt;，不需要再次包含，重复包含会报错// 重复包含defs.h没有问题，因为我们在defs.h中做了保护#include \"defs.h\"int main(void) { printf(\"The macro value is %d\\n\", MY_MACRO); struct S s = { 10, 1.5f }; MyFunction(s);} #include指令的作用就是将头文件中的所有内容包含到#include指令所在的文件中。在defs.h中使用了#ifndef，用于防止重复包含，上例中，我们第一次已经将头文件包含进来了，第二次就不会将内容包含进来了。这说明include不是简单的复制，会分析被include文件中的预处理指令，将预处理指令执行完的结果include进来 #error#error指令用于在预处理工程中报出指定的错误诊断信息。其基本形式为：#error 预处理符号 换行符1234567891011121314#include &lt;stdio.h&gt;#ifndef MY_SAFE_MACRO // 报错，#error后面接的是错误信息 #error safe macro not defined!#endif// 直接报错，没有提示信息#error#warning 警告信息int main() {} #line#line用于作为行号控制，形式为：#line 数字序列 换行符后面的数字指示它下一行的行号，而忽略它之前的行号。 还有一种形式可以修改源文件名：#line 数字序列 &quot;源文件名&quot; 换行符 注意，通过__LINE__宏可以获取到当前的行号，__FILE__可以获取到当前的文件名。 #undef#undef用于取消之前定义的宏。 pragma操作符。#pragma只是当前翻译单元使用某种编译特性进行编译。比如，可以指定哪些函数用某个优化选项进行优化，从哪里开始使用标准浮点约定等。形式为:#pragma 预处理符号 换行符 这里的预处理符号就是编译选项，一般有编译器定义，但是C语言标准也定义了若干标准，以STDC作为前缀，形式为：#pragma STDC 编译选项 开关值 换行符。 开关值有三种，分别是：ON、OFF、DEFAULT。 C99引入了_Pragma操作符，语义和#pragma一样，不过可用于宏定义的替换列表中。形式：_Pragma(字符串字面量)。 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;#ifndef MY_SAFE_MACRO // 报错，#error后面接的是错误信息 #error safe macro not defined!#endif// 直接报错，没有提示信息#error#warning 警告信息// 使用遵循浮点数标准的编译选项#pragma STDC FP_CONTRACT ON// 后面的代码启用O2进行优化#pragma O2static void MyFunc(int a) { a += 10; printf(\"a = %d\\n\", a);}#pragma O0// 可用于宏替换列表#ifdef DEBUG#define PRAGMA_OPTION _Pragma(\"O0\")#else#define PRAGMA_OPTION _Pragma(\"o2\")#endifPRAGMA_OPTIONstatic int MyFunc2(int a, int b) { return a * a + b * b;}_Pragma(\"O1\") int main() {} 空指令#直接接换行就是空指令，空指定没有特殊作用。","link":"/2019/11/15/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/9.C%E8%AF%AD%E8%A8%80%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"},{"title":"C语言深入篇1：指向数组和函数的指针","text":"前面我们学习过指针、数组、函数的概念，也了解了指向数组和函数的指针。这里深入理解和学习指向数组和函数的指针。 首先我们从类型的概念入手，每一种指针都有自己的类型，要了解指向数组和函数的指针，首先需要理解这两种指针指向的数据类型。 然后了解这两种类型的变量的声明方式以及理解。 然后学习这两种类型复合类型，例如：指向数组的指针的数组怎么表示？指向函数的指针的数组怎么表示？如果作为函数的参数类型和返回类型？ 如何理解指针的类型C语言中的指针的值是一个地址，在64位系统中，始终是8个字节，那么int *和double *有什么区别呢？前面的学习文章也提到过，区别在于，如何解释指针的值，也就是指向的地址，中的内容。 如果是int *，则将指针指向的地址作为起始地址，到其后4个字节的内容解释为1个int型的整数。 指向数组和函数的指针也是指针，自然也有上面的结论，所以我们知道： 指向数组的指针的值，是一个数组的地址 指向函数的指针的值，是一个函数的地址 学习数组的时候，我们知道int *可以指向一个数组，那和指向数组的指针有什么区别呢？ int *p = &amp;a表示的是指向数组的起始地址，并将起始地址之后的4字节字节作为int解释。所以一种解释是，int*指向的是数组的元素，通过移动int*指针可以访问数组元素 int(*pa)[n] = &amp;a表示的是指向数组的起始地址，并将起始地址之后的4n个字节作为数组解释。所以指针pa指向的是数组，`pa取到是数组，我们要取数组元素怎么办？(pa)[i]，(pa)是数组，加括号是因为运算符优先级的原因。因为*pa和p[0]是等同的，我们也可以写成pa[0][i]` 如果指向数组的指针指向了二维数组呢？例如：12int aa[2][3] = { 1, 2, 3, 4, 5, 6 };int (*pa)[3] = &amp;a;和上面一样理解，pa指向二维数组a的地址；这里我们首先要了解一个概念，二维数组元素也是连续存放的，假设是[1,2,3,4,5,6]，那么(*pa)或pa[0]取到的就是一个数组，其值是[1,2,3]，*(pa+1)或者pa[1]值是[4,5,6] 由此我们也能知道int **p的含义，指针的值还是一个指针。 两种指针的类型和变量声明方式指向数组的指针指向数组的指针的类型是：类型 (*)[n]，这是指向一维数组的。指向二维数组的呢？类型 (*)[n][m]。依次类推。 这里要注意类型很重要，在这两种指针类型作为函数返回类型以及作为形参类型的时候，需要正确书写类型，后面会详细说明 如何声明指针变量呢？类型 (*标识符)[n][m]...，例如：1234// 声明了一个类型为int(*)[3]的指针int (*p)[3];// 声明了一个类型为int(*)[3][3]的指针int (*pa)[3][3]; 如何声明指向数组的指针的数组呢？12// 声明含两个元素的数组，数组成员是int(*)[3]int (*pa[2])[3]; 指向函数的指针类型：类型 (*)(形参列表)。 声明：类型 (*标识符)(形参列表)，类型 (*标识符[n])(形参列表)。 示例：12345// 声明了指向 一个返回类型为int，只有一个int参数的函数 指针int (*func)(int);// 两个元素的数组，成员是函数指针int (*func[2])(int); 作为函数的参数和返回值指向数组的指针 作为函数返回值类型 形式：`类型 (* 标识符(型数列表))[n]`，例如`int (*f(int))[2]`，示例中的`int (* xxx)[2]`表示返回类型为`int(*)[2]`，`f(int)`表示函数名和形参列表的声明。 123int (*func1(int n))[3] { return &amp;(int[]){ 1,2,3 };} 作为函数参数类型 形式：int main(int(*p)[10]); 123456// 参数为int(*)[10]类型的函数声明int func2(int(*)[10]);int func2(int(*p)[10]) { return sizeof(p);} 两者结合起来： 12345678910111213141516171819202122 int (* func3(int(*pp)[10]))[10] { return pp; } ### 指向函数的指针指向函数的指针和指向数组的指针是类似的。将指针类型换一下就行了，我们直接上代码：```c// 函数指针作为返回类型// int(* xxx)(int)，表示返回类型为int(*)(int)，xxx是：函数名(形参列表)int (* func4(int))(int);// 函数指针作为形参int func5(int(*p)(int a)) { p(10); return (*p)(20);}// 两者结合// 返回类型是int(*)(int)// 参数有两个，一个是int(*)(float)，一个是int(*)[10]int (* func6(int(* f1)(float), int(*pa)[10]))(int) {}","link":"/2019/11/20/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/C%E8%AF%AD%E8%A8%80%E6%B7%B1%E5%85%A5%E7%AF%871%EF%BC%9A%E6%8C%87%E5%90%91%E6%95%B0%E7%BB%84%E5%92%8C%E5%87%BD%E6%95%B0%E7%9A%84%E6%8C%87%E9%92%88/"},{"title":"postcss基础","text":"postcss是一个用js插件改变css样式的工具。这个插件可以对css进行语法检查、转义最新的css、添加前缀、内联图片等等。postcss将css文件转成抽象语法树，并且提供了API取访问他们，这些API可以被插件使用，对css进行处理。 postcss提供了大量的插件，这些插件能够对css开发中的方方面面进行处理，最受欢迎的一些插件：插件列表。 使用postcss可以通过多种方式来使用，这里只记录了两种，更多的可以去postcss的仓库看文档： CSS-in-JS通过css-in-js库astroturf来使用postcss。具体操作是在webpack.config.js中加入对css-in-js处理的loader，然后将导出的css文件用postcss处理，添加postcss.config.js配置文件：1234567891011121314151617181920212223// webpack.config.jsmodule.exports = { module: { rules: [ { test: /\\.css$/, use: ['style-loader', 'postcss-loader'], }, { test: /\\.jsx?$/, use: ['babel-loader', 'astroturf/loader'], } ] }}// postcss.config.jsmodule.exports = { plugins: [ require('autofixer'), require('postcss-nested') ]} webpack在webpack中的使用也很简单，对输入的css文件添加postcss-loader，然后添加postcss.config.js配置文件，指定需要哪些postcss插件，并将插件require进来。1234567891011121314151617181920212223242526272829303132//Use postcss-loader in webpack.config.js:module.exports = { module: { rules: [ { test: /\\.css$/, exclude: /node_modules/, use: [ { loader: 'style-loader', }, { loader: 'css-loader', options: { importLoaders: 1, } }, { loader: 'postcss-loader' } ] } ] }}//Then create postcss.config.js:module.exports = { plugins: [ require('precss'), require('autoprefixer') ]} 命令行执行如果不需要集成到现有的工具中，我们可以使用postcss提供的cli工具来对某一个文件或者某一个目录下的css文件进行处理，post-cli postcss-cli安装： npm i -g postcss-cli |npm i -D postcss-cli 常见用法： postcss –use autoprefixer -c options.json -o main.css css/*.css postcss文档核心这里记录以下postcss文档阅读的核心要点： 参数大多数的postcss执行器都接受两个参数： 插件数组 选项对象 通用选项： syntax：提供语法解析和字符串化的对象 parser：特殊的语法解析器，例如scss stringifier：特殊的语法输出生成器，例如Midas map：source map选项 from：输入文件名（大多数执行器自动设置） to：输出文件名（大多数执行器自动设置） 更多的信息可以参考api文档 思考postcss就是一系列的插件的组合，postcss本身不提供额外的功能，只对输入的css进行语法分析，构建AST，然后提供给插件访问AST的api。这些插件输入AST，输出处理过后的css，其中最常用的就是autoprefixer插件，改插件根据browserslist配置自动为css添加前缀。 像postcss-scss等插件不会编译scss，他们只是让scss语法能够通过postcss的语法检查，postcss-scss只是将scss中的mixins、变量、@规则简单的翻译成属性，如果需要编译scss，例如在webpack中，需要安装sass-loader和node-sass，并让其在postcss-loader前执行，这样就可以同时达到预编译和自动添加后缀的效果。","link":"/2019/08/12/css/postcss/postcss%E5%9F%BA%E7%A1%80/"},{"title":"postcss插件:autoprefixer","text":"autoprefixer用于css添加浏览器厂商前缀，以兼容比较老的浏览器。其数据来源是caniuse。 下面看一个实例： 我们在写代码的时候不用考虑浏览器前缀的问题了，直接写成下面这样：1234567891011::placeholder { color: gray;}.image { background-image: url(img@1x.png);}@media (min-resolution: 2dppx) { .image { background-image: url(img@2x.png); }} autoprefixer会按照当前浏览器的流行程度和属性支持来为你应用前缀（根据browserslist的配置来决定，可以通过browserslist的配置来确定需不需要添加前缀以及为哪些浏览器添加前缀）：1234567891011121314151617181920212223242526::-webkit-input-placeholder { color: gray;}::-moz-placeholder { color: gray;}:-ms-input-placeholder { color: gray;}::-ms-input-placeholder { color: gray;}::placeholder { color: gray;}.image { background-image: url(image@1x.png);}@media (-webkit-min-device-pixel-ratio: 2), (-o-min-device-pixel-ratio: 2/1), (min-resolution: 2dppx) { .image { background-image: url(image@2x.png); }} 使用这里只介绍在webpack中的使用，在webpack中我们使用postcss-loader，然后为postcss添加autofixer插件，使用如下：12345678910111213141516171819// webpack.config.jsmodule.exports = { module: { rules: [ { test: /.css$/, exclude: /node_modules/, use: ['style-loader', 'css-loader', 'postcss-loader'] } ] }}// postcss.config.jsmodule.exports = { plugins: [ require('autofixer') ]}autoprefixer还提供了很多其他构建工具的使用方式，需要用的时候查查文档就可以了，这里主要弄清楚autoprefixer的规则。 autoprefixer文档核心这里记录了autoprefixer文档的核心要点： 常见问题： autoprefixer会为ie添加polyfill吗？ autoprefixer可以将现代grid的语法转成IE10和IE11支持的语法，但是这个polyfill不是在100%的case下工作，这也是其默认被禁用的原因。 首先需要选项grid: autoplace或者/ autoprefixer grid: autoplace /控制注释来启用grid前缀。 其次需要在IE中测试你的代码的每个方面 第三，对auto placement仅有很少的支持 第四，如果不是用auto placement特性，最佳的方法是通过grid-template或者grid-template-area。 autofix会添加polyfill吗？ 不会，autoprefixer只添加前缀。可以考虑下面的库来实现一些语法糖的功能： postcss-env：预置polyfill和autoprefixer，用来写未来的css的插件 Oldie：用来处理IE hack的postcss插件（opacity，rgba等等） postcss-flexbugs-fix：修复flexbox问题的插件 autoprefixer为什么没有为border-radius添加前缀？ 开发者们经常惊讶于现在需要添加前缀的属性有多少(特别少的意思）！如果autoprefixer没有为你的属性添加前缀，检查caniuse看它是不是仍然还需要前缀 autoprefixer怎么处理老的有-webkit-前缀的代码？ 只能处理没有前缀的情况，autoprefixer只能将gradient，如果代码中只有-webkit-gradient，将不会添加前缀。可以使用postcss-unprefix来处理有前缀的代码，然后在将其结果传给autoprefixer。 禁用前缀如果你需要一个特殊的hack，只需要自己写上前缀就可以了，autoprefixer不会覆盖已有的前缀：1234a { transform: scale(0.5); -moz-transform: scale(0.6);} 特性启用特性： grid：”autoplace”，在ie10/11下支持有限的grid布局 supports: false，禁用@supports参数前缀 flexbox：false，禁用flex布局属性前缀 remove：false，阻止移除过时的前缀 控制注释如果需要在某个位置启用或者停用autoprefixer，可以通过控制注释（control comment）来实现：1234567891011121314.a { transition: 1s; /* will be prefixed */}.b { /* autoprefixer: off */ transition: 1s; /* will not be prefixed */}.c { /* autoprefixer: ignore next */ transition: 1s; /* will not be prefixed */ mask: url(image.png); /* will be prefixed */}有三种类型的控制注释： / autoprefixer: on|off /，在整个块中启用或者禁用autoprefixer。 / autoprefixer: ignore next /，禁用下一条属性选择或者@规则的参数（不包括@规则的内容） / autoprefixer: autoplace|non-autoplace|off /，在整个块中控制grid布局的前缀，autoplace启用autoplacement的支持。non-autoplace，不支持autoprelacement的前缀，但是支持其他的属性。off，关闭。 总结思考autoprefixer用于给css属性添加前缀，它只添加前缀，不会添加任何的polyfill，需要polyfill可以使用其他的库比如postcss-preset-env等。 autoprefixer使用browserslist配置和caniuse来决定对哪些浏览器添加哪些前缀。 autoprefixer中一个特殊的存在就是grid的处理，针对ie下grid的兼容。 通过给插件传配置参数或者通过控制注释可以对autoprefixer进行一些配置，例如是否对grid autoplacement添加支持等。12345678// postcss配置文件, postcss.config.jsmodule.exports = { plugins: [ require('autoprefixer')({ grid: 'autoplace' }) ]}","link":"/2019/08/15/css/postcss/postcss%E6%8F%92%E4%BB%B6-autoprefixer/"},{"title":"MySQL数据类型","text":"这篇文章主要介绍mysql的数据类型，基于《MySQL技术内幕》的第三章，主要内容是mysql中的详细数据类型、类型转换以及如何对数据进行处理。 要点总结 数据值类别：mysql数据库中能够存储如下类别的数据 数值：包括整数、浮点数、和位域值。其中整数和浮点数可以分成精确值和近似值，用科学计数法（例如.158E8）表示的是近似值，4、1.25这样形式表示的精确值。近似值会有舍入误差，精确值的近似结果是精确的。 字符串值：例如’123ss’，可以值单引号或者双引号（尽量使用单引号）。可以只用\\转义（例如\\’,\\t），使用''也可以转义单引号 日期时间值：可以单独日期和时间，例如（’2012-06-17’、’12:30:43），也可以组合在一起（’2008-06-15 10:30:12.5） 空间值：例如(10,20)这种表示平面中坐标系的 布尔值：常量TRUE和FALSE，分别表示1和0。表达式中的0表示FALSE，非0、非NULL表示真 mysql数据类型 数字类型： TINYINT SMALLINT MEDIUMINT INT BIGINT DECIMAL FLOAT DOUBLE BIT 字符串类型： CHAR VARCHAR BINARY VARBINARY TYNYBLOB BLOB MEDIUMBLOB LONGBLOB TINYTEXT TEXT MEDIUMTEXT LONGTEXT ENUM SET 时态类型： DATE: ‘YYYY-MM-DD’ TIME: ‘hh:mm:ss’ DATETIME: ‘YYYY-MM-DD hh:mm:ss’ TIMESTAMP: ‘YYYY-MM-DD hh:mm:ss’ YEAR: YYYY或YY数据值类别MySQL支持多种常规类别的数据值。其中包括数值、字符串值、日期/时间这样的时态值、空间值，以及NULL值。 数值MySQL能够识别的数字标阔整数、定点数或者浮点数，以及位阈值。 精确值数和近似值数MySQL支持对精确值进行精确运算，以及对近似值的近似运算。精确值包括整数（如0、14、-382）和带小数点的数（0.0、38.5、-18.247）；近似值是采用科学计数法表示的浮点数，他们带有一个底数和一个指数（如1.58E5、-1.58E5）。 整数可以用十进制和16进制两种格式来表示。16进制默认为字符串，但在数值运算的时候，十六进制常量会被视为64位的整数。例如，0x10==16 小数精确值由三部分组成：整数部分、小数点、小数部分，其中整数部分和小数部分都是数字序列。小数点前后的数字序列可以有一个为空，但是不能同时为空。 16进制不能用科学计数法来表示 精确值运算后得到的值也是精确的，只要没有超出精度。近似值的计算是近似的，会有舍入误差。MySQL按照以下规则决定使用精确计算还是近似计算： 只要表达式里有近似值，就会当作浮点（近似）表达式来计算 如果表达式只包含整数精确值，但其中的值带有小数部分，那么它会以BIGINT（64位）精度来计算 如果表达式只包含精确值，但是有小数，会按照65位decimal算法来计算 在表达式里，如果存在字符串必须转换成一个数才能进行计算的情况，那么该字符串会被转换成一个双精度浮点值。该表达式进行近似计算。 位域值位阈值可以写成b’val’或者0bval，其中，bal是一个或者多个0/1组成的数字序列。例如b’1001’或0b1001表示9。 在结果集里面，BIT值会被显示为一个二进制串。将BIT结果+0，或者使用CAST()函数，可以将其转化为一个整数。1select b'1001' + 0, CAST(0b1001 AS UNSIGNED); 字符串值字符串两端的引号既可以是单引号，也可以是双引号。但是推荐使用单引号： SQL标准规定使用单引号 如果启用了SQL模式ANSI_QUOTES，那么mysql会将双引号引起来的值处理成标识符，代表数据库中的表名、数据库名或者表的列名等等。例如，如果开启了ANSI_QUOTES模式，SELECT &quot;last_name&quot; from president;中的&quot;last_name&quot;会被视为president表中last_name字段，而不是一个字符串常量。 上面原因的第二个，两种结果天差地别，如果&quot;last_name&quot;被当成常量，那么选出来的结果中有一列就是常量，值就是&quot;last_name&quot;。如果当成标识符，选的是president表中的last_name字符串的值。 MySQL能够识别出字符串里用来代表特殊字符的转义序列：\\0, \\', \\&quot;, \\b, \\n, \\r, \\t, \\\\, \\z。如果向取消反斜线字符的特殊含义，并把他当作一个普通的字符，需要启用SQL的NO_BACKSLASH_ESCAPE模式。转义序列区分大小写。不是上列转义字符，如果加上\\，会被解释成原字符。 字符串的16进制表示法有两种16进制的字符串表示法，一种是X’val’，val是16进制串，x和val都中的字母都不区分大小写。例如X’4A’表示J：12345mysql&gt; select X'4A', x'4a';+-------+-------+| X'4A' | x'4a' |+-------+-------+| J | J |在字符串上下文中16进制串当作字符串，在数字上下文中，16进制串当作数字：12345mysql&gt; select X'4A', x'4a';+-------+-------+| X'4A' | x'4a' |+-------+-------+| J | J | 另一种就是0x开头的16进制表示法，例如0x0a，其中0x只能是小写。16进制默认是字符串，当用于数字/数学运算时，被解析成64位整数。123456mysql&gt; select 0x61626364, 0x61626364+0;+------------+--------------+| 0x61626364 | 0x61626364+0 |+------------+--------------+| abcd | 1633837924 |+------------+--------------+","link":"/2019/09/25/database/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/MySQL%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"},{"title":"mysql安全性和访问控制","text":"","link":"/2020/02/25/database/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/mysql%E5%AE%89%E5%85%A8%E6%80%A7%E5%92%8C%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"},{"title":"Sass快速入门","text":"1. 使用变量1.1 声明变量 $highlight-color: #F90; $highlight-color就是一个变量，变量的值可以是任何CSS属性值。即可以赋值给css属性的值都可以赋值给变量。 在规则块中定义的变量只能在规则块中使用。 1.2 变量引用凡是css属性可以使用的地方，变量就可以使用： 1234$highlight-color: #F90;.selected { border: 1px solid $highlight-color;} 在声明变量时，变量值可以引用其他变量： 12345$highlight-color: #F90;$highlight-border: 1px solid $highlight-color;.selected { border $highlight-border;} 上例说明变量的值可以是复合值。 1.3 一般使用中划线来分隔变量中的多个词2. 嵌套CSS规则如下例： 1234567#content { article { h1 { color: #333; } p { margin-bottom: 1.4em; } } aside { background-color: #EEE; }} 会使用后代选择器编译，编译后： 1234 /* 编译后 */#content article h1 { color: #333 }#content article p { margin-bottom: 1.4em }#content aside { background-color: #EEE } 2.1 父选择器的标识符&amp;使用&amp;能够在嵌套选择器中指代父元素。 例如： 1234article a { color: blue; &amp;:hover { color: red; }} 会编译成： 12article a { color: blue; }article a:hover { color: red } 注意：&amp;指代当前嵌套的选择器的父选择器，例如 1234#content aside { color: red; body.ie &amp; { color: green }} 会变成: 123/*编译后*/#content aside {color: red};body.ie #content aside { color: green } 而不是只有aside是父元素。 2.2 群组选择器的嵌套123.container { h1, h2, h3 { margin-bottom: .8em }} 会变成： 1.container h1, .container h2, .container h3 { margin-bottom: .8em; } 同理可知： 123nav, aside { a { color: blue; }} 2.3 &gt;、+、~1header + p { font-size: 1.1em; } +选择紧跟在header后面的p 1article ~ article { border-top: 1px dashed #ccc; } ~选择所有article元素后的同层article元素，不管他们中间有多少元素。 可以在嵌套规则中使用： 123456789article { ~ article { border-top: 1px dashed #ccc } &gt; section {background: #eee } dl &gt; { dt { color: #333 } dd { color: #555 } } nav + &amp; { margin-top: 0 }} 2.4 嵌套属性规则可以嵌套，属性也可以嵌套： 1234567nav { border: { style: solid; width: 1px; color: #ccc; }} 嵌套属性的规则：把属性名从中划线-的地方断开，在根属性后面添加一个冒号：，紧跟一个{}块，子属性写在{}中。 得到的结果如下： 12345nav { border-style: solid; border-width: 1px; border-color: #ccc;} 3. 导入SASS文件 css的@import规则会在执行到@import时浏览器才会去下载。 sass的@import规则在生成css文件时就将相关文件导入进来。在被导入文件中定义的变量和混合器均可在导入文件中使用。 可以省略文件后缀（.sass,.scss）。 3.1 部分sass文件这些文件一般只用于导入到其他文件中，比如常用的组件sidebar。 sass局部文件的文件名以下划线开头。这样，sass就不会在编译时单独编译这个文件输出css，而只把这个文件用作导入。 themes/_night-sky.scss =&gt; @import “themes/night-sky”; 3.2 默认变量值 反复声明一个变量，只有最后一处有效且它会覆盖前边的值。 12345$link-color: blue;$link-color: red;a { color: $link-color;} 使用!default实现默认值 1234$fancybox-width: 400px !default;.fancybox { width: $fancybox-width;} 声明后面接!default说明该值是默认值，如果还有其他的赋值，那会使用赋值，如果没有则使用默认值。 3.3 嵌套导入sass运行@import命令写在css规则内（原生css不允许）。这种导入方式下，生成对应的css文件时，局部文件会被直接插入到css规则内导入它的地方。 3.4 原生的CSS导入由于sass兼容原生的css，所以它也支持原生的CSS@import。在下列三种情况下会生成原生的CSS@import： 被导入文件的名字以.css结尾 被导入文件的名字是一个URL地址 被导入文件的名字时css的url值 4. 静默注释“//” 开头的是静默注释，这种注释不会和出现在生成的css文件中。 5. 混合器通过sass的混合器实现大段样式的重用。 混合器使用@mixin标识符定义。这个标识符给一大段样式赋予一个名字，可以通过这个名字来重用这段样式。 12345@minin rounded-corners { -moz-border-radius: 5px; -webkit-border-radius: 5px; border-radius: 5px;} 通过@include来使用这个混合器： 12345notice { background-color: green; border: 2px solid #00aa00; @include rounded-corners;} 相当于在@include的位置将名字代表的那一段代码粘贴进来。 5.1 何时使用混合器 如果发现一直在复制粘贴某一段css代码，这时候需要混合器 如果能为这个混合器想出一个简短的好名字，这时往往能够构造一个合适的混合器。 5.2 混合器中的css规则混合器中不仅可以包含属性，也可以包含css规则，包含选择器和选择器中的属性： 12345678@minin no-bullets { list-style: none; li { list-style-image: none; list-style-type: none; margin-left: 0px; }}","link":"/2020/06/14/css/sass/sass%20%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/"},{"title":"MySql Workbench 生成表关系图","text":"这篇文章学习如何在mysql workbench上，根据已有的表生成关系图。当刚刚上手一个数据库的时候，如果能有该数据库的关系图的话，能够更好更快的掌握数据库各部分的功能及其相互关系。 反向工程已有数据库要从一个已有的数据库创建数据库表的关系图，我们需要使用反向工程来创建一个model，具体操作是： 选择database -&gt; Reverse Engineer然后会出现要连接数据库的界面，选好需要连接的数据库，点next。 在下一个界面选择需要反向工程的数据库，选好后点next 然后点excute。之后一直点next，直到生成了model。 此时就会得到想要的图了，如果没有，点生成的model的界面中的EER Diagram。 中间有一些选项以及model、diagram之间的关系没有深入分析，以后用到的时候补充 参考资料How to create ER diagram for existing MySQL database with MySQL Workbench How to reverse engineer a database with MySQL Workbench","link":"/2019/11/28/database/mysql/MySql-Workbench-%E7%94%9F%E6%88%90%E8%A1%A8%E5%85%B3%E7%B3%BB%E5%9B%BE/"},{"title":"mysql语法1：建立数据库和表","text":"这篇文章给出mysql中建立数据库和表的详细语法。如果不记得详细语法，在mysql客户端中可以通过help create database或者help create table来获取语法参考，如下例：12345678910111213141516mysql&gt; help create databaseName: 'CREATE DATABASE'Description:Syntax:CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_nameCREATE DATABASE creates a database with the given name. To use thisstatement, you need the CREATE privilege for the database. CREATESCHEMA is a synonym for CREATE DATABASE.URL: https://dev.mysql.com/doc/refman/5.7/en/create-database.html 建立数据库语法，采用上下文无关文法表示，其中{}表示是必须的，[]表示是可选的：123456CREATE {DATABASE | SCHEMA} [IF NOT EXISTS] db_name [create_specification] ...create_specification: [DEFAULT] CHARACTER SET [=] charset_name | [DEFAULT] COLLATE [=] collation_name","link":"/2020/02/20/database/MySQL%E6%8A%80%E6%9C%AF%E5%86%85%E5%B9%95/mysql%E8%AF%AD%E6%B3%951%EF%BC%9A%E5%BB%BA%E7%AB%8B%E6%95%B0%E6%8D%AE%E5%BA%93%E5%92%8C%E8%A1%A8/"},{"title":"mysql添加新账户并设置远程可访问","text":"这篇文章学习mysql中的用户创建和权限管理，最终的成果是创建一个新的只拥有某一个数据库访问权限的账户，同时开启这个账户的远程访问权限。参考资料是《mysql技术内幕》的第十三章。 MySQL账户管理参考另一篇博客，mysql安全性和访问控制 示例：添加新用户、授权并开启远程访问 创建新用户 1create user 'valner'@'%' identified by '密码'; 为新用户赋予指定数据库的访问权限 1grant ALL on valner.* to 'valner'@'%'; mysql的账户名有用户名（登陆用的）和主机地址以及字符@组成，格式是'username'@'hostname'。同一个username，但是hostname不一样视为不同的用户，这也是为什么'root'@'localhost'（默认账户）远程登陆不上，因为root只允许在localhost登陆，如果需要开启远程登陆，可以指定’%’表示在所有机器上都可以登陆，也可以指定具体的域名或者ip地址或者通配符。 踩坑记录正常来说按照上面的设置应该是可以正常远程访问的。但是，首先操作系统会有防火墙，mysql使用的3306端口不一定会对外开放；所以一定要在防火墙开放3306端口。在centos7下可以使用firewall、iptables。 其次，我们一般使用的是云服务器，云服务器提供商出于安全的考虑，可能限制服务器开放的端口，需要我们在运营商的后台手动配置开放的端口。我这里买的是阿里云的服务器，阿里云的云服务器就会限制对外网开放的端口，需要手动在阿里云网站的管理后台来手动添加开发的端口。（查了半天这个原因，明明firewall和iptables服务都没有启动，但是3306端口就是不开放。） 还可以通过nmap工具来扫描服务器开放的端口。","link":"/2020/02/25/database/mysql/mysql%E6%B7%BB%E5%8A%A0%E6%96%B0%E8%B4%A6%E6%88%B7%E5%B9%B6%E8%AE%BE%E7%BD%AE%E8%BF%9C%E7%A8%8B%E5%8F%AF%E8%AE%BF%E9%97%AE/"},{"title":"1.数据库系统导论","text":"顾名思义，数据库就是存储数据的仓库，是信息的集合。这些数据一定是能够长期存储的，不会因断电而丢失，所以数据库中的数据一般存储在磁盘等永久存储器材中，而不是RAM（随机访问内存，或者运行内存，断电会丢失数据）中。当然现在有一些No-SQL数据库例如redis用作缓存，是存放在RAM中的，这种缓存数据库和持久数据库不同，这一系列复习笔记主要关注的是持久数据库。缓存数据库在另外的笔记中学习。 数据库漫谈数据库的能力一般通过数据库管理系统来使用，这种软件被称为DBMS（Database Manage System，数据库管理系统），DBMS一般会提供命令行或者图形界面的方式来操作数据库系统中的数据。DBMS中实现了数据库系统的基本能力，例如持久存储，事务处理，提供程序访问接口等。同时能够提供对于数据库进行增删改查的功能、能够有效处理数据库访问时不同用户并发访问的问题。 为了简化数据库的使用和提高数据库操作的性能，一般会提供用于数据库操作的特殊语言，例如用于描述数据库的数据库定义语言，用于查询和更新的语言（比如SQL）。对于文件系统而言，文件系统能够提供持久存储的能力，也能够新增删除数据。但是一般的操作系统，不会提供对于文件系统的查询语言，我们要从数以亿计的文件中找出特定文件中的特定一个数据字段，几乎是不可能的。而且文件系统对于数据模式的支持仅仅限于文件夹。所以文件系统虽然能够提供持久存储和一定的数据访问能力，但是远远到不到数据库系统的要求。数据库系统需要进一步的设计。 个人pc或者一般的linux服务器上使用的数据库，例如mysql，底层是使用文件系统实现的。例如新建一个数据库，DBMS会在操作系统中创建一个新的文件并设置其初始大小，例如4G。数据库的细节存储在该文件中，一般不直接访问硬盘，需要调用操作系统提供的文件系统API。但是特定的数据库服务器上会搭载特定的系统，数据库系统能够直接访问硬盘，以提供更高的数据存储效率。 DBMS的一个很重要的特性就是能够快速存取一些小块的数据，例如对于机票、酒店等订票系统，要能够存取每一个订单的日期、价格、起始地点等等信息，对于银行需要存储客户的信息，以及它们的存款、交易记录等等。数据库系统需要提供能很方便快捷的方式来访问其中的某一条或者数条数据，例如输入一个高级语言语句select age from user where name = 'john'，就能找到john的年龄，而不是在一大堆文件中找john，再去找john的年龄。 相信大家一定都有找一大堆文件找不着需要的文件的经历，是不是耗时耗神还找不着？大家的解决方案是什么呢？是不是一般是分类分文件夹来存放文件，一个文件夹不存放大量的文件。这种行为背后的思想是什么呢？索引。我们要找一个文件，首先找到那个文件夹，其实就是根据文件找到索引，我知道这个文件属于哪一个索引（文件夹），就能快速找到它。数据库的底层其实也是这么实现的，借助了索引树这样的数据结构。大家找文件时的另一问题是，按照什么顺序来找文件呢？从前到后，还是从后到前，还是从中间开始呢？一般都是从前到后或者从后到前，这样的查找方式叫做线性查找，最坏的情况下需要将所有文件过一遍才能找到（因为可能要找的文件在最后面或者最开始）。而如果我们将文件按照文件名进行排序呢？（windows下文件夹下右键可以设置）例如我们要找notes.txt这个文件，它的首字母是n，那么我们是不是可以跳着看呢？先看中间，如果看到了一个l开头的，那么n在l后面，前面的就不用看了，看l后面的文件找notes.txt就行了，如此重复。这种查找方式叫做二分查找，假如有n个文件，最坏只需要看$log_2n$次，而线性查找需要看n次。假如n是128，那么$log_2n=7$，对于128个文件，最多只要次就能找到，想想字典就能理解了。 上面提到的一些技术都是数据库底层使用的技术，索引技术，查找算法。这样的技术也是从日常生活遇到的痛点问题而来中，不仅艺术源于生活，技术也源于生活–。那么在日常的电脑使用中，是不是也可以使用一些个人数据库系统（例如access）来解决一些数据管理的问题呢？答案是肯定的，当然是不是使用是需求而定，当你快要为数据管理而抓狂的时候，就可以考虑使用了。当然利用文件夹分类，名称、时间排序的方式是最简便和最常用的方式，对于大多数人而言。 言归正传，对于目前最流行的数据库，使用的都是关系数据库模式。关系数据库的核心思想是以一种类似表格的方式来组织数据，例如对于机票系统，存储的信息可能是下面这样：123456-----------------------------------------------------airline | name | id-number | price | from | arrive-at-----------------------------------------------------gh2634 | bright | 430xxx | 639 | CS | Tianjin....-----------------------------------------------------关系数据库将一条记录的相关信息组织成“一行”，当我们查找某些数据，例如bright将乘坐的航班的“price”的时候，先找到bright所在的那一行，然后再在这一行中找相应的price。“表头”称为模式，模式在数据库表建立的时候确定，可以在建立之后更改。那么问题又来了，既然数据库也是以“表格“的形式来存储，为什么不直接用excel呢？首先，两者用途不同，excel是个人电脑上的办公软件，而数据库一般是运行于服务器上的服务器软件。其次，存储的数据量不同，excel表格最多也就存几万条数据，而商用数据库中的数据都是数以亿计。两者具有相似的存储模式，但是用途不一样决定了两者的功能和实现天差地别。 前面提到的一些例子都是文本，但是在实际中我们会遇到很多非文本数据例如视频、音频等。这些多媒体数据在数据库中如何存储呢？一种方式就是存储多媒体文件的路径，还有一种方式是将多媒体文件直接存入数据库中。后面文章会详细讨论多媒体数据在数据库中的存储和读取问题（以mysql为例）。 数据库管理系统前面提到了数据管理系统（DBMS）是数据库管理的软件，提供了完整的数据库功能。对于数据库用户而言提供的最重要的几个功能是： 数据查询和更新 数据模式定义 事务管理 上述的功能是用户关心的，用户只需要输入特殊的命令或者语句，就能定义数据模式，查询更新数据，开启事务，而不关心数据库底层的的运行。而对于数据库实现，则需要对输入的命令进行解析然后执行。同时要能够进行并发控制、事务管理、日志恢复等。一个DBMS的结构一般如下：12345678910111213141516171819202122232425用户/应用程序 数据库管理员 | \\ | DDL命令 |查询 \\ 事务命令 | |更新 \\ | | \\ |查询编译器 事务管理器 DDL编译器 | | \\ / | -------|--------------/ | / | \\-----------|执行引擎----&gt;日志与恢复 并发控制 | | | | | | | |索引/文件/ 存有索状态的表（在内存中）记录管理器 | |缓冲区管理器 | |存储器管理器 | | 存储器上图显示了一个数据库系统的详细结构，接下来自顶向下分析： 最顶层是用户/应用程序，和数据库管理员。可以将他们统一认为是数据库用户，不过一个操作数据，一个操作数据库 下一层是直接与上一部分对接，查询编译器用于编译用户输入的命令语句，编译成树结构并制定查询计划。事务管理器用于进行事务调度，调用下一层的并发控制模块。DDL编译器将DDL命令翻译成语法树结构并提交给执行引擎 再下一层是执行引擎、日志恢复、并发控制。执行引擎用于执行用户输入的各种命令，会与其他的大多数模块打交道，例如调用调度器避免并发修改数据；调用日志模块回滚事务。同时会调用底层的功能，实现对具体数据的访问。 下面的存储器管理器和缓冲区管理器主要的功能是控制存储器和缓冲区的访问。 用户见到的最影响系统性能的DBMS部分是查询处理器，查询处理器包括两个部分： 查询编译器：将查询转为内部使用的查询计划，查询计划是在数据上的操作序列。通常查询计划中的操作数用“关系代数”实现。查询编译器由三个模块组成：查询分析器、查询预处理器、查询优化器。查询编译器利用元数据和数据统计确定哪种操作序列最快，例如，如果数据模式中使用了索引，那么将使用索引相关的操作大大检查查询时间。 执行引擎。执行引擎负责执行查询计划的每一步。执行引擎和系统中其他的大部分模块交互。因为用户的命令编译后在执行引擎中执行，执行引擎必须访问日志模块以读写日志实现事务的一致性。必须访问调度器来避免访问已加锁的数据。 事务管理数据库中一个非常重要的部分就是事务处理，事务具有的特性有原子性（Atomic）、隔离性（Isolation）、持久性（duration）、一致性（Consistence）。一般用ACID来表示，具体如下： 原子性（A）：事务要不全部执行，要不不执行 隔离性（I）：表现为同时只有一个事务在执行，多个事务可以同时执行，但是必须保证同时执行的部分是互不影响的。看起来和单独按序执行没有区别 持久性（D）：事务一旦完成，影响是持久存在的。 一致性（C）：一致性是指事务中的数组元组之间的联系具有一致性，例如一个表中的id，是另一个表中的外键，那么这两个值应该是严格相等的。范围更广的一致性还包括数据的合法性，例如金额一般不是负数等。 事务管理要解决的三个问题是： 记日志：日志用于数据库崩溃后的恢复和事务失败回滚的恢复。 并发控制：控制数据的并发访问，一般是使用锁的方式。 消除死锁：利用锁来控制数据的并发访问可能会导致死锁的问题，所以事务管理器一定要能够消除死锁并将系统恢复到一个一致的状态。 数据库系统研究概述数据库系统的研究方向主要有以下三个： 数据库设计：如何设计一个数据库，包括数据库应该存什么样的信息？如何组织？数据项之间如何链接？如何设计没有冗余、一致的数据结构？ 数据库程序设计：研究如何在应用程序中使用数据库提供的功能，包括如何使用事务管理等功能？数据库设计如何与普通程序设计结合？常用的web系统都属于此类 数据库系统实现：研究数据库系统的底层实现，包括如何实现事务管理？如何实现日志系统？如何实现锁机制、采用何种锁？数据如何存储在磁盘上？ 这一系列复习笔记参考了《数据库系统大全》一书，会全部涉及到上面三个方向，从数据库设计方法原则，到数据库程序设计，再到数据库底层的实现。 数据库设计上会复习E/R模型、关系数据库模型、函数依赖和设计范式、对象数据库设计和XML等。数据库程序设计上会复习关系代数、SQL语言、高级语言访问数据库。数据库系统实现主要关注三个方面：1.存储器管理。2.查询处理。3.事务管理。 总结这篇文章主要概述了数据库系统解决的问题，主要包括以下几个方面： 持久存储数据、高效查询更新数据、自定数据模式 事务处理的ACID原则 数据库的几个研究/学习方向 接下来的复习，希望能深入理解数据库系统从外到内的方方面面。从数据库设计到数据库应用程序设计，再到数据库底层的实现原理，都能了然于心。","link":"/2020/02/05/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%85%A8%E4%B9%A6/1-%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%AF%BC%E8%AE%BA/"},{"title":"centos 下安装mysql","text":"安装client yum install mysql 这会安装client，这时如果输入mysql，会显示： ERROR 2002 (HY000): Can’t connect to local MySQL server through socket ‘/var/lib/mysql/mysql.sock’ (2) 查了一下，发现并没有/var/lib/mysql/mysql.sock这个文件，可能是并没有安装mysql-server。 接下来我们我们安装server 安装server yum install mysql-community-server 安装完成后，启动mysql。如果提示没有找不到安装包，说明默认的git仓库中没有mysql-community-server这个软件包，解决方案有两个，第一个是直接去mysql官网下载安装包，然后用yum localinstall来按照；第二个是添加有mysql-community-server的仓库；第三种是参考官方网站上的安装教程，官方给出了包含安装仓库和密钥的rpm包。下面给出官方示例： 下载仓库rpm：wget https://dev.mysql.com/get/mysql80-community-release-el7-3.noarch.rpm 本地安装rpm：yum localinstall mysql80-community-release-el7-3.noarch.rpm 安装mymsql-server：yum install -y mysql-community-server 【官方教程地址】(https://dev.mysql.com/doc/refman/8.0/en/linux-installation-yum-repo.html) 保存后重新执行yum install mysql-community-server就可以了。 service mysqld start 完成安装。 mysql client连接远程数据库 mysql -h 远程地址 -u root -p 配置mysql安装完mysql后，mysql默认是不会启动的，所以我们在控制台输入mysql命令，会报错。接下来我们手动启动mysql服务，并添加到开机自启动。 启动mysql服务： systemctl start mysqld.service 然后执行： systemctl status mysqld.service 如果看到输出中提示mysql server处于running中，说明mysql启动成功。mysql启动后会有一个默认的密码，我们要找出这个默认的密码，输入： grep “password” /var/log/mysqld.log 结果如图： 修改默认密码使用默认密码登陆mysql： mysql -u root -p 输入默认密码 然后必须修改默认密码才能进行操作，修改默认密码输入如下指令： alter user ‘root‘@’localhost’ identified by ‘密码’;","link":"/2019/05/24/database/mysql/centos-%E4%B8%8B%E5%AE%89%E8%A3%85mysql/"},{"title":"3.关系数据模型","text":"前面学的E/R模型是对于现实世界进行建模的一种很好的方式，但是其不好实现。现今的数据库实现通常使用关系数据模型。关系模型只有一个概念：“关系”，即组织数据的一种二维表。E/R符号用于设计数据库并阐述数据之间的关系，关系数据模型用于数据的实际存储，如何将E/R符号转为关系数据模型也是本片笔记的复习重点。 复习要点本章的复习要点如下，需要补充的部分在后文补充，点击连接即可跳转。 1.关系模型的基础：关系模型通过一种称为关系的二维表描述数据，类似于表格。 属性：关系模型的”表头”称为属性。 模式：关系名和属性名集合的组成称为这个关系的模式。例如Movie(title, year, length, filmType)。关系模式的集合称为数据库模式。 元组：除”表头”(属性名所在行)之外的行称为元组。元组之中的元素的顺序要和属性顺序对应上。 域：关系模型要求元组的每个分量具有原子性，必须属于某种元素类型，例如string或者integer。 关系的等价：关系是集合而不是列表，可以改变元组或者属性的顺序来得到等价的关系。 关系实例：一个给定关系中元组的集合称为关系的实例。实例会随数据库的修改而改变。 2.从E/R图到关系设计：数据库设计实践中，一般先设计E/R模型，再转为关系模型，会更加简单，而不是直接使用关系模型设计。 E/R模型到关系模型的通用转换规则：1.每一个实体集合转化为具有同一属性集合的关系。2.用关系代替联系，该关系的属性是连接的实体集的键集合和联系的属性。 考虑特殊情况：1.弱实体集需要考虑支持键。2.”isa”联系和子类要特殊对待。3.有时需要把两个关系合成1个，尤其是在转化多对一联系时。 组合关系：有些情况下可以将多个关系合成一个关系，例如多对一联系。假设R是E到F的多对一联系，可以将R的关系合并到E的关系中，合并的属性具体是，F的主键，R的属性。 处理弱实体集：核心思想——需要添加其他实体集的支持键。1.从弱实体集W得到的关系R需要添加所有的支持键作为属性。2.与W相连的非支持联系需要添加W的所有支持键作为属性。3.支持联系不需要转为关系，支持联系的属性作为R的属性。 子类结构到关系的转化： 1.E/R方式转化：每一个子类都转为关系R（包括根实体集），R的属性是子类的属性加上根实体集的键属性。新增实体时，子类关系和根关系都需要插入元组。 2.面向对象方式：每一个子类都转为关系R（不包括根实体集），R的属性是子类的属性加上根实体集的所有属性；同时如果有组合的子类，例如既是卡通电影，又是恐怖电影，则新建一个关系，这个关系包含卡通、恐怖、根三个实体集的所有属性。新增实体时，只在对应的关系中插入元组。 3.空值方式：只建立一个关系，将所有的子类的属性都添加到这个关系中。添加某一个子类的实体时，关系中不属于该子类的属性设置为空值。 各种方式比较：1.”空值”方式只使用一个关系，查询效率最高，但是会占用额外的内存空间，因为有很多空值。2.查询“范意义”时，例如仅仅针对电影，E/R方式效率比面向对象高，因为只需要查根关系。而面向对象需要查所有子类关系。3.查询跨越多个子类的关系，E/R方式效率更低。 总结：三种各种各有优劣，需要根据查询的实际情况合空间情况、关系数量情况进行权衡。 3.函数依赖：单值依赖称为函数依赖（缩写为FD），如果属性集合A确定，那么属性集合B也确定，则说明A函数决定B，记作A-&gt;B。 关系的键：能函数决定关系中其他所有属性的最小化属性集合（即没有满足条件的集合是其真子集）。如果能函数决定关系中其他所有属性，但是不是最小化属性集合，则称为超键。关系可以有多个键，但是只有一个主键，在关系模式中画下划线表示。 4.函数依赖的规则：如何从已知的函数依赖推断除其他函数依赖。 1.分解结合规则：A-&gt;B1B2 =&gt; A-&gt;B1和A-&gt;B2，反过来也正确。 2.平凡依赖规则：A-&gt;B，且B是A的子集。如果有A-BC，B是A的子集，可以直接去掉B，得到A-&gt;C。 3.属性集合的闭包：给定一个属性集合{A1,…,An}，如果有FD：A1…Am -&gt; B，则将B加入到集合中，重复直到没有更多属性能够假如到集合中，最终得到的属性集称为集合{A1,…,An}的闭包，记作{A1,…,An}+。如果{A1,…,An}+ = 所有属性，那么{A1,…,An}是关系的超键，可以根据这条规律来从FD计算关系的键。 4.传递规则：如果有A1…An -&gt; B1…Bm，B1…Bm -&gt; C1…Ck，那么有A1…An -&gt; C1…Ck。简记为A-&gt;B，B-&gt;C，则A-&gt;C。 关系的基本FD集：如果一个FD集合能够推断出关系的所有FD，改FD集合称为关系的基本FD集。如果改集合没有真子集是基本FD集，那么其实最小化的基本FD集。 函数依赖的投影：关系的投影就是去除一部分属性后剩余属性组成的关系，函数依赖的投影就是原关系的所有FD中，左右两边的属性都在投影的到的关系中的FD集合。 5.关系数据库模式设计：E/R模型转为的关系模型可能会有冗余等异常，需要进一步的设计分析消除异常。 异常：1.冗余：同一数据多次存储。2.更新异常：只更新了一个元组而没有更新其他元组中的相同信息。3.删除异常：删除一个元组会导致其他不需要删除的数据丢失。 分解关系：一般用分解的方式来消除异常。将{A1,…,An}分解成{B1,…,Bm}和{C1,…,Ck}且{A1,…,An}={B1,…,Bm}并{C1,…,Ck}。那么采用什么样的分解方式，能消除什么样的异常呢？下面的范式给出了分解规则。 1.BCNF范式：如果关系R满足BCNF，那么R中的每一个非平凡FD，如果左边的属性都是超键，则满足BCNF范式。如果有一个非平凡FD左边不是超键，那么该FD违反BCNF范式。分解规则是：假如{A1…An}-&gt;{B1…Bn}违反BCNF，那么求S={A1..An}+，将S的所有属性作为新的关系R，{A1..An}和除开S外的其他属性作为另一个关系，如果另一个关系违反BCNF，则继续分解。BCNF分解后的多个关系连接后能够正确恢复。 2.第三范式：BCNF分解后得到的关系，可能不能保持FD。例如在原关系R中有AC-&gt;B,分解得到了关系R1(A,B)和R2(B,C)。那么满足R1和R2的元组重新连接后可能不满足AC-&gt;B这个FD了，也就是分解成R1和R2会导致丢失AC-&gt;这个FD。第三范式稍稍放松了BCNF的限制，可以解决这个问题。如果关系R中有A-&gt;B，那么要么A的超键，要么B是主属性（主属性是键包含的属性）。三范式能够消除大部分的冗余，但是不是全部，如果要全部消除冗余，需要分解到BCNF范式。三范式的分解方式和BCNF相同。 3.第四范式：解决多值依赖的问题，知识点在下面。 6.多值依赖：是两个属性或属性集合之间相互独立的断言。是广义上的FD，每个FD也是一个多值依赖。 属性独立及其冗余：例如R(a,b,c,d,e)，abcde相互独立，R中不存在FD，那么不违反BCNF范式，但是abcde可以随意组合，假设元组中a相同，bc有两个值，de有三个值，那么需要6个元组来存储这些值，bc的两个值要存储3次，de的三个值要存储2次。 多值依赖的定义：给定一个属性集合的值，存在有与关系中其他属性值独立的属性值。记作A-&gt;-&gt;B。 多值依赖规则：1.平凡依赖规则：如果有A-&gt;-&gt;B，且C是B的属性与A的1个或者多个属性的并，则有A-&gt;-&gt;C。相反的，去掉B中属于A的属性也成立。2.传递规则：如果有A-&gt;-&gt;B，和B-&gt;-&gt;C，那么有A-&gt;-&gt;C（去掉C中同时属于B、C的属性）。3.多值依赖不遵循分解规则，遵循合并规则。 非平凡MVD（MVD=多值依赖）：A-&gt;-&gt;B是非平凡MVD，那么，B中不含A中的任何属性且R中存在A、B之外的属性。3.互补规则：有A-&gt;-&gt;B，则有A-&gt;-&gt;C，C是不属于AB的所有属性。 第四范式：在R中，如果有非平凡MVD A-&gt;-&gt;B，那么A是超键。 分阶段扫第四范式：对于违反四范式的A-&gt;-&gt;B，分解成AB，以及A和AB外的全部属性。如果分解后的关系不满足四范式，则继续分解。","link":"/2020/02/07/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%85%A8%E4%B9%A6/3-%E5%85%B3%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"},{"title":"4.关系代数","text":"前面复习的是数据库设计，包括如何建模（E/R模型），如何转化为实际的数据库模型（关系模型）以及设计消除冗余等异常的关系（BCNF，四范式、散范式）。这里开始复习数据库编程的设计，即用户如何查询和修改数据库的内容，从关系代数开始。 关系代数能够描述关系上的操作，包括并、差、笛卡儿集、选择、投影、连接等。关系代数能够描述如何从给定的关系中查询和修改特定的元组，sql等高级语言就以关系代数作为工具来对关系数据库进行查询和修改。 复习要点 一般系统将关系看成包而不是集合，包允许重复的元组（没有键约束的情况下）基于集合的关系代数 关系代数基础：代数一定有操作符和原子操作数，关系代数的操作数是关系，操作符是关系操作。 关系代数的原子操作数是：1.代表关系的变量。2.代表有限关系的常量。 操作符是：1.并、交、差。2.除去某些行或者列的操作；选择是除去行，投影是除去列。3.组合两个关系元组的操作；有笛卡儿运算（两个关系所有可能的元组配对方式）、连接（两个关系选择一些元组配对）。4.重命名，改变属性的名称或者关系的名称 关系代数的表达式称为查询。 关系代数的所有操作得到的结果集合都会去重。 1.关系的集合操作：并（union）、交（intersection）、差（difference）。所有集合操作会将结果去重！！ 并（$R \\cup U$）：得到R中、U中以及R和U中都有的元组组成的关系。 交（$R \\cap U$）：得到R和U中都有的元组组成的关系。 差（$R-U$）：得到在R中但是不在U中的元组组成的关系。 上述运算需要添加条件才能进行：1.R和S必须是具有同样属性的关系。2.R和S的列必须是一一对应的。如果要对属性个数相同、但是名称不同的关系进行集合操作，需要使用重命名操作。 2.投影（projection）：投影用来生成新的关系，这个关系只包含原来关系R的部分列。$\\pi_{A_1,A_2,…,A_n}(R)$表示R在${A_1,A_2,…,A_n}$上的投影，即投影得到的关系由${A_1,A_2,…,A_n}$这些属性组成。 3.选择（selection）：通过选择的条件筛选元组得到新关系。$\\sigma_{c}(R)$表示R中满足条件c的元组组成的关系。c是条件表达式，可以使用$=\\gt\\le$等比较符以及AND、OR等连接符。 4.笛卡尔集：表示为$R\\times S$，表示R和S中所有元素的组合，如果R中有两个元组，S中有三个元组，那么$R\\times S$有6个元组。 5.连接：笛卡儿集是两个关系中元组任意组合，而连接是只将满足条件的特定元组组合。连接分为： 自然连接：如果两个关系有相同的属性，那么在两个关系中满足相同属性的值相同的元组会被连接。例如R(A,B)和S(B,C)，关系R和S有相同属性B，那么自然连接将R和S中B相同的元组连接起来。得到的关系是$R\\Join S=T(A,B,C)$，B只会出现一次。注意R和S中每两个元组都需要尝试进行配对。 $\\theta$连接：将满足给定条件的元组进行连接，记作$R\\underset{C}{\\Join} S$，相当于：1.求$R\\times S$。再选择满足条件C的元组。R和S中的相同元素会出现两次，例如T(A,R.B,S.B,C)。 6.组合上述操作：通过组合上述操作，可以得到任意复杂的表达式。例如$\\pi_{title,year}(\\sigma_{length\\ge 100}(movie))\\cap (\\sigma_{starName=’Fox’}(movie))$，表示取movie中的length大于等于100的且starName=’Fox’的元组，然后将这些元组投影到title和year上。 7.重命名：$\\rho_s(A_1,\\ldots,A_n$)(R)，表示将关系R重命名成S，且属性名对应改成$A_1,\\ldots,A_n$。重命名不会修改关系中的属性个数和元组数据，只会改名。如果不改属性名，属性名可以不写，变成$\\rho_s(R)$。 8.基本操作集：有一些操作能够从由若干其他操作代替，不能由其他操作代替的操作的集合称为基本操作集，有连接、差、投影、积运算和重命名 包上的关系操作 包上的关系操作：包和集合的区别是，包允许重复的元组。常见的DBMS中基本是基于包实现的，因为包上的关系操作有更高的效率，不需要去重。而且投影时，如果得到的是相同的若干元组，例如(1,2,3)，(1,2,4)投影前两个会得到(1,2)和(1,2)，如果采取集合对结结果去重，那么聚集操作会丢失数据。 包的并、交、差： 1.并：包的并要将相同元组出现的次数相加，如果两个包中一个包含元组r次，另一个包含同样的元组m次。求并后得到的包含元组r+m次。 2.交：包的交取相同元组出现次数的最小值。$\\min(r,m)$ 3.差：包的差取相同元组出现次数的差。$\\max(0,r-m)$ 包的投影操作：投影直接得到原关系的每一个元组，不过元组只包含投影的属性。不去重。 包的选择：和集合上的选择相同，不去重。 包的笛卡儿集：和集合上的笛卡尔集相同，不考虑重复元组的问题。例如两个包中分别有r和m个重复元组，那么笛卡尔集结果中有r*m个元组。 包的连接：和集合上的连接相同，区别是不去重。 关系代数的扩展 前面的是经典的关系代数，现代查询语言包含更多的关系代数操作，这些操作称为关系代数的扩展 1.取重操作符$\\delta$：去除重复元组 2.聚集操作：例如求和、求平均值等。被分组操作使用，对某一组中所有元组进行聚集。有SUM、AVG、MIN、MAX、COUNT等。 3.分组操作$\\gamma$：根据一个或者多个元素的值进行分组，这些元组称为分组元素，分组元素的值相同多元组被分成一组。 4.排序操作$\\tau$：根据一个或者多个属性排序，只改变元组的顺序 5.扩展投影：可以以原来的列进行计算，得到新的列。 6.外连接：自然连接会出现悬挂元组，即一些没有配对成功的元组。外连接分成左外连接和右外连接，会填充左边或者右边关系的悬挂元组的空属性为null。 关系的约束 引用完整性约束：规定某个上下文中出现的值也必须在另一个上下文中出现。例如关系中一个关系R的某个属性A引用另一个关系S中的某个属性B，当R中取某一个元组具有属性值a时，a值也必须在S中某个元组中存在。如SQL中的外键约束。 其他约束：例如域约束等等。","link":"/2020/02/11/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%85%A8%E4%B9%A6/4-%E5%85%B3%E7%B3%BB%E4%BB%A3%E6%95%B0/"},{"title":"2.实体-联系数据模型","text":"复习要点大全本篇复习笔记的要点，分成大概下面几个部分： 1.E/R图的基础知识：E/R的组成、表示及其细节等 数据库建模的步骤：构思-&gt;E/R模型-&gt;关系模型-&gt;关系DBMS E/R模型的三个要素：实体集、属性（带下划线的属性是键）、联系 E/R图的图形表示：矩形表示实体集、椭圆表示属性、菱形表示联系 联系的多样性：两个实体集中的联系可能存在一对一，多对一，多对多。重点是这三种关系的理解。 多路联系：多个实体共享相同的联系，例如多方签合同 联系中的角色：一个联系中，一个实体集可以出现多次，每次表示不同的角色。通过命名联系来区分角色。 联系的属性：有时候需要给联系添加属性，例如合同有签订薪水，这份薪水与合同（联系）相关，而于任何实体集不相关。 多路联系化二元联系：将多路联系化成实体集，原来的联系与实体集的连线变成新的二元联系。 E/R模型中的子类：子类有父类公共的属性以及自生额外的属性。子类与父实体集通过isa的联系相连，isa用顶角向上的三角形表示。isa联系不标箭头，但是都是1对1联系。E/R图中子类上只连接自己特有的属性。子类拥有父类的属性和联系。 2.设计原则 忠实性：设计要忠于现实世界，以及实际情况。 避免冗余：相同的数据避免存储两次。冗余可能导致：1.浪费空间。2.修改时没有全部修改导致不一致。 简单性考虑：设计尽可能简单，除非绝对需要，否则一定不要添加额外的成份。 选择正确的联系：实体集可以以多种方式联系起来。联系是否需要首先取决于实际情况，其次取决于联系是否是冗余的——即该联系可以由其他联系导出。 选择正确的元素种类：属性是最容易实现，当然是使用实体集还是使用属性来进行建模，是根据实际情况确定的。 约束的建模 E/R图中的元素只能表示结构上的约束，不能表示数据上的约束。数据上的约束需要额外的建模。 约束一般有： 键约束：唯一标识一个实体的属性或者属性集。E/R图中通过带下划线的属性表示键。父实体集必须拥有所有的键属性。 单值约束：属性值在某种情况下具有唯一性要求。键约束也是单值约束；还有多对一联系等 引用完整性约束：被引用的某个值在数据库中必须存在。E/R图中通过连线的圆角表示引用完整性约束。 域约束：属性只必须在一个值集或者范围内。 一般约束：任意定义的任意的约束。例如要求影星不超过10个。 弱实体集 一个实体集的键是由另一个实体集的部分或者全部属性构成，这样的实体集称为弱实体集。 弱实体集主要由两个来源：1.一个实体集E和另一个实体集F处于层次结构中，但是不是子类的关系，E的键要通过F才能唯一确定。例如球员编号，只有知道是哪个球队的多少号才能确定一个球员。2.连接实体集，例如多路联系中转为二元联系时新建的实体集，这种实体集没有自己的键，其键由多个实体集来确定。 弱实体集的要求：1.只能通过多对一联系来获取其他实体集的键属性作为键。2.该多对一联系必须有引用完整性。3.多个多对一联系，每个联系都会提供键 弱实体集的符号：1.弱实体集用双边矩形来表示。2.弱实体集的多对一支持联系用双边菱形表示。 上面的是要点总结，忘记细节看本文后面的详细知识点细节。 概述实体-联系模型也叫E/R模型，是数据库设计方向的研究范畴。数据库设计最要的是设计出要存储的信息以及信息组成部分之间的关系。通常数据库的结构称为数据库模式，一般以某种语言或者符号来描述。除了E/R模型以外，还有关系模型、对象模型、半结构化模型等。 在实际的数据库建模中，E/R模型并不直接作为数据库管理系统的直接模式，原因是E/R模型是一种抽象模型，并不是足够有效的数据结构。最常见的DBMS采用的模型是关系模型。所以实际数据库建模的步骤一般如下：1思想 ---&gt; E/R设计 ---&gt; 关系模式 ---&gt; 关系DBMS一般的数据库设计步骤是：先明确要存储的数据，利用E/R模型设计出数据实体属性以及数据实体之间的联系；然后通过一定的规则将E/R模型转为关系模型；最后将关系模型转成DBMS支持的输入，例如sql语句，输入DBMS建立真实的数据模型。 E/R模型的要素E/R模型一共有三个要素： 实体集 属性 联系 实体集是某一个抽象事务的集合，从面向对象的角度来说，“实体”和“对象”很相似。“实体集”和“对象类”也有相似性，但是“实体集”只包含属性，而不包含对属性的操作。以电影举例，每部电影是一个实体，所有电影构成实体集，电影都有主演、制片人、导演等等属性。 实体集具有属性，属性是实体集中的实体所有的性质。例如电影实体中可能有title、length这些属性来表明电影的标题和时长。 联系是两个或者多个实体集之间的连接。例如Movie和Stars是两个实体集，那么Star出演Movie，那么两个实体集之间就具有了某种联系Star-in。例子中的联系是二元的，E/R模型支持多路联系。在转为关系模型时，多路联系会转成二元联系，后面的笔记会详细讲述这一部分。 实体-联系图上面讨论了E/R模型的三个要素，可以以图形的形式来描述实体集、属性和联系。每一种元素都用不同的图形来表示，使用实线来连接属性、联系和实体集。三个要素分别用下面的图形来表示： 矩形表示实体集 椭圆表示属性 菱形表示联系 如下例：！E/R模型图例 上图中的有三个实体集：movies、stars、studios，这些实体集用矩形表示。每一个实体集都有自己的属性，属性用椭圆表示。三个实体集之间有两个联系，联系用菱形表示。实体集、属性、联系之间均以实线相连。 E/R模型并不会直接存入数据库，但是在进行数据库设计之前，先想一下E/R模型，确定数据对象的属性和其联系，能够帮助我们更好的进行数据库设计。 联系一般表示两个实体之间某些属性之间的对应关系，例如star和movie具有star-in的联系R，表示某一个明星出演某一步电影，R的可以元组可能是Alice Starwar，表示Alice出演了Starwar这部电影。通过在联系中将star的name属性和movies的title属性关联，就能确定不同实体集之间的实体的关系。 联系的多样性上面举的联系的例子中，两个实体集之间的实体的关系可能是一对一的关系，即仅一个明星出演仅一部电影，但是可能存在一个演员至多出演一步电影且一部电影可以请多个演员，这种关系就是多对一。也可能存在一个明星参演多部电影，一部电影多个明星演，这种关系就是多对多。所以我们说联系具有多样性，联系可能是一对一、多对一、多对多。向下详细说明这三种联系的定义： 多对一：如果实体集E中任一实体通过联系R至多与实体集F中的一个实体联系，那么R称为E到F的多对一联系 一对一：如果E到F是多对一联系，F到E也是多对一联系，那么R称为E到F的一对一联系 多对多：即不是多对一也不是一对一 为了便于理解，可以从函数的角度来理解，E看作定义域，F看作值域。定义域中取一个值，如果值域值多有一个值相对应，那么是函数。所以多对一和函数的定义其实是相同的。取一个x，最多一个y。如果反过来也成立，取一个y最多一个x，那么x和y就是一一对应的了，即一对一的关系。 E/R图中使用箭头来表示联系的多样性，简单来记就是：箭头指向一，即如果R是E到F的多对一联系，那么R到F的联系要打箭头。用上例的图，如果stars到movies是多对一联系，那么图如下： 给定一个演员，最多一部电影，但是多个演员可以出演相同的电影。 多路联系上面给出的联系都是二元联系，但是联系可以是多路的。举个例子，假如有三方签合同，三方分别是三个实体集，那么这三个实体集肯定都共享“合同”这个联系，如下例：上例中的箭头也表示多对一的关系，表示一个明星最多签约一家制片公司，一部电影也最多签约一家制片公司。 联系中的角色同样，一个实体集在一个E/R图中可能多次出现，例如电影和其续集的关系。电影和电影的续集都属于电影这个实体集，那么在电影到电影续集这个联系中，同一个实体集（电影）充当了两个角色。人们一般给联系的联系来命名来区分角色，如下例： 联系的属性","link":"/2020/02/06/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%85%A8%E4%B9%A6/2-%E5%AE%9E%E4%BD%93-%E8%81%94%E7%B3%BB%E6%95%B0%E6%8D%AE%E6%A8%A1%E5%9E%8B/"},{"title":"模式匹配：KMP算法","text":"","link":"/2019/08/25/datastructure/String/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D%EF%BC%9AKMP%E7%AE%97%E6%B3%95/"},{"title":"5.数据库语言sql","text":"《数据库系统全书》读书笔记，主要包括书中有关sql部分，主要是的第六章和第七章。这里记录了最常用的sql语法及其详细的语法规则。这一系列读书笔记作为数据库系统原理课程同步复习笔记，综合了课程所学和书中所述，同时尽量添加自己的个人理解。 复习要点SQL语句是数据库系统中最普遍使用的对于数据库进行操作和修改的语言。查询部分的功能类似于前面学习过的扩展关系代数，关系代数是sql实现的工具。除此之外包括数据库定义和修改等，SQL既是DDL（数据定义语言）又是DML（数据描述语言）。 简单查询：SELECT attrNames FROM tableNames WHERE condition。 SELECT对应扩展投影，后面接投影属性名，*表示所有属性。 WHERE对应选择，选择关系中满足condition的元组（condition可以使用$+-*/$和比较运算符$\\ge$、$\\gt$、$\\le$、$\\lt$、=、&lt;&gt;，&lt;&gt;表示不等于。 字符串用单引号括起来。字符串比较的几种方式：1.比较，包括等于、大于、小于等。2.匹配，使用s (NOT )LIKE p的形式，s是字符串，p是模式可以使用%(任意长度字符，包括0)和_(任一个字符)。 多关系查询 子查询 去重、分组和聚集 关系增删改查 数据库、关系定义 查询sql中的简单查询sql中最简单的查询是找出关系中满足特定条件的元组。简单查询使用三个保留字：SELECT、FORM、WHERE来表示一个SQL查询语句。例如：1234567SELECT *FROM MovieWHERE studioName = 'Disney' AND year = 1990# 形式SELECT col1, col2, ...FROM relation1, relation2,...WHERE cond1 and/or cond2, ...上面的语句从数据库的关系模式Movie中找出studioName=’Disney’和year=1990的元组（就是在Movie中找出某些列满足特定条件的行），select *表示选择所有列。简单总结就是：from确定从哪些关系中查询，where确定要取的行，select确定取到的行中的哪些列。 todo select from where的所有可能取值的总结1234select 逗号隔开的属性列表|*|属性 as 别名|常量 as 别名from 逗号隔开的关系列表|元组变量例如Movie m|where 布尔表达式 and/or/not 布尔表达式|is not null|a in b|order by 属性列表 1. sql中的投影 select * 会选择满足where条件的关系中的所有的元组（行）中的所有属性（列），但是有时候我们不需要所有的列，这个时候可以使用投影，select title选择元组中和title属性，然后将其投影到结果列title上。 如果我们希望将选择的列投影到不同的列上我们可以使用as，例如：select title as name，这样选择的元组中对应的title属性会被投影到结果表的name列。 select还可以用表达式取代属性，例如select length*0.66667 as duration，这将选择的元组中的length属性乘以0.6667的结果投影到duration，这样我们在结果表中拿到的length对应的列就是计算后的结果duration。 还可以添加常量到select中，例如：select ‘.html’ as ext 2. sql中的选择 where后面接一个条件表达式，和c中的表达式类型，其求值结果是布尔值。 值比较：使用6中常用的比较运算符：=、&lt;&gt;（不等于）、&lt;、&gt;、&lt;=和&gt;=。常量和跟在from后面的关系的属性都是可以比较的，也可以通过算术运算比如+、-、*、/来计算后比较。通过||可以连接字符串（’foo’||’bar’=’foobar’。 布尔运算：上面提到的比较的结果可以通过and,or,not来进行布尔运算 3. 字符串比较 当两个字符串里面的字符序列完全相同时，称两个字符串相等。sql允许固定长度和可变长的字符串。 字符串的大小比较是比较其字典顺序，按照其逐个字母的先后比较。 sql提供了简单的字符串模式匹配的功能：like，例如：s NOT LIKE p其中s是字符串，p是模式。模式的形式是字符串+特殊字符串(%表示匹配任意长度的字符串，包括0，_表示匹配任意一个字符)。当s符合模式p的时候表达式才为真。 sql规定单引号是字符串的开始和结束，如果要在字符串内部使用单引号，那么使用两个单引号，例如: ‘%’’s%’=%’s%。 4. 日期和时间 sql的实现版本通常将时间和日期作为特殊的数据类型。日期常量是由DATE保留字+单引号+特定字符串，例如date’1948-05-14’，时间是time’15:33:14’，时间日期是timestamp’1948-05-14 12:00:00’。可以直接用比较运算符对时间日期进行运算 5. 空值的比较 SQL允许属性的值为特殊值null。where中要考虑null空值带来的影响： null和其他任何数据（包括null）算术运算+-得到的结果依然是空值 null和其他任何数据（包括null）比较运算=或&gt;，结果都是unknown值。 正确判断是否空值的方式是使用x is null或者x is not null。 6. 布尔值unknown 前面提到涉及到null的比较运算结果是unknown，那么我们布尔值的可能就有三种了：true、false、unknown。而前面又提到，布尔值可以通过AND、OR、NOT进行运算，那么这三种情况的运算结果是什么呢？ 一种方式是将true看成1，false看成0，unknown看成0.5，三者的and运算取值的最小值，例如true AND unknown值是0.5，也就是unknown。or取最大值，例如false or unknown值是unknown。not取1-v，not unknown = 1-0.5=0.5=unknown。 综上，unknown and false = false，unknown or false = unknown，not (unknown or false) = unknown。 但使用where查询时，只有值时true才有效，false和unknown都无效。 7. 输出排序 可以基于任何一个属性（或者多个）来进行排序，并将其他的属性跟在它后面进行约束。当第一属性相同时，按照第二属性排序，以此类推。 order by 属性列表，逗号隔开 多个关系上的查询关系代数的强大在于它能够通过连接、笛卡尔积、并、交和差来组合多个关系。在SQL中也可以做相同的操作 1. SQL中的积和连接查询多个关系：在from后面接逗号隔开的多个关系，在select和where中可以使用任何出现在这些关系中的属性 例如：123select namefrom Movie, MovieExecwhere title = 'Star Wars' and producerid = certid; 该语句的执行过程是：1234| | | ||-----|- | || | \\-&gt;|-----|| | | | 遍历两个关系的所有元组对 找出所有满足关系的元素对，将元组对合成一个元素返回。 执行的结果是：12|-----||----||-----||----| 2. 属性歧义如果两个关系中有同名属性，可以通过table1.name=table2.name这种添加表名限定的形式来实现区分，包括在select和where中都可以这么区分 3. 元组变量可以对同一个关系进行多次查询，也就是说，对于关系R，可以from R r1, R r2, ...，这里的r1，r2就代表R的两个拷贝的不同元组。 例如，找出Star表中所有地址相同的star（s1.name &lt; s2.name是为了去重）:123select s1.name, s2.namefrom Star s1, Star s2where s1.address = s2.address and s1.name &lt; s2.nametips：这里看起来是根据address进行分组，但是其实不是，sql中的分组只能select分组的属性和其他属性的聚集操作。我们要找到同一个表中的某一项相同的不同元组，只能通过同表的多表查询来实现。 4. 多关系的解释多关系的连接书中给了多种解释方案，比如嵌套循环——看成两个元组集合的二重循环；并行赋值——两个不同实例将可能的元组赋值给各自的元组变量，然后比较这两个元组变量；关系代数——先取笛卡尔积（笛卡尔积是《离散数学》中的概念，在我的《离散数学》复习篇博客中会涉及），然后对结果进行筛选。 这多种解释的结果是相同的，只是过程不同，结果都是将两个关系的元组进行组合，并进行筛选。上面给的解释只是组合前筛选和组合后筛选的区别。 5. 查询的并、交、差sql中的union、intersect和except分别表示并、交、查。可以直接用这三个关键字，将多个括号括起来的查询的结果组合起来。 只能对列数相同的结果关系集合进行操作 例如：1(select bookid, bookname from book) union (select majorid, majorname from major);结果是：1234567+--------+--------------------------+| bookid | bookname |+--------+--------------------------+| b001 | 货币银行学 || m2 | 信息安全 || m1 | 计算机科学与技术 |+--------+--------------------------+注意：mysql中只支持union，不支持intersect和except，需要使用group by或者not in来模拟 子查询当某个查询是另一个查询的一部分时，称为子查询。子查询可以拥有下一级的子查询。例如上例中通过两个子查询的union得到最终的查询结果。使用子查询的其他方式： 子查询可以返回单个常量，这个常量能在where中和另一个常量进行比较 子查询可以返回关系，该关系可以在where子句中以不同的方式使用（in、not in、exist、all等等） 像许多存储的关系一样，子查询形成的关系能够出现在FROM子句中。","link":"/2019/08/17/database/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B3%BB%E7%BB%9F%E5%85%A8%E4%B9%A6/5-%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AF%AD%E8%A8%80sql/"},{"title":"idea添加热重载支持","text":"spring-boot提供了dev-tools工具用于热重载，在vscode中直接保存就能自动热重载，但是在idea中不行，因为idea会自动保存。在idea中实现自动热重载的步骤如下：12345678910111213141516171. include the spring-boot-devtools dependencyMaven&lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt; &lt;/dependency&gt;&lt;/dependencies&gt;Gradledependencies { compile(&quot;org.springframework.boot:spring-boot-devtools&quot;)}2. enable “Make project automatically” in the compiler preferences for automatic restarts to work.enter image description here3. enable the compiler.automake.allow.when.app.running registry setting in IntelliJ. You can access the registry in IntelliJ using the shortcut Shift+Command+A, then searching for registry. 其中第三步需要输入registry，然后在registry中找到对应的选项。 更改完需要重载的时候执行build-&gt;rebuild project就可以自动更新了。","link":"/2020/02/28/java/spring%E5%AE%9E%E6%88%98/idea%E6%B7%BB%E5%8A%A0%E7%83%AD%E9%87%8D%E8%BD%BD%E6%94%AF%E6%8C%81/"},{"title":"shell script基础","text":"这里总结shell的基本语法，包括了shell中的一些基本元素/变量，shell脚本语法。 使用多个命令之前在命令行中都是输入一个命令，那么如果输入多个命令呢？很简单，将多个命令用分号“;”隔开就可以了，例如： date; who 创建shell文件通过分号的方式，我们可以一次性执行多条命令，但是如果下一次我还想执行相同的命令序列怎么办呢？这时候我们可以将命令存到一个文本文件中，然后赋予该包含了shell脚本的文件可执行的权限。 创建shell文件的步骤如下： 创建一个文本文件，输入shell命令，例如 touch test.shvim test.sh然后输入: 123#!bin/bash date who 赋予该文本文件可执行的权限 chmod u+x test.sh 执行该文件 ./test.sh 注意shell脚本文件的第一行用于指定脚本使用的shell程序，在示例中是#!bin/bash，这一行是必须的。 显示消息在shell中输出消息，使用echo命令，例如： echo $PATH 输出当前系统环境变量，当第三方命令需要被配置到path中才能够只能从命令行或者shell脚本中执行。 使用变量变量可以存储临时性的信息，在shell中我们也可以使用变量，变量有自定义变量和环境变量，环境变量是系统定义的，通过环境变量我们可以访问到特定的系统信息，例如$HOME可以访问当前用户的目录，$USER是当前已登陆的用户名，$PATH是shell查找程序的搜索路径。 在shell中可以自定义变量，语法是:varname=value，这三者之间不允许出现空格，例如： var1=10;echo $var1; 注意，在定义var1的时候没有$，使用变量的时候才有$。 如果我想在一条命令中引用另一条命令的输出怎么办呢？有两种方式： 使用反引号 使用$() 例如，我想定位到当前工作目录下子目录bin下，可以这样写： cd $(pwd)/bin #或者是 cd pwd/bin 重定向输入和输出使用&gt;、&gt;&gt;、&lt;、&lt;&lt;可以重定向输入和输出。原来我们的输出例如，echo $PATH，直接将path输出到了屏幕上，我们要向将它重定向到文件中怎么办呢？使用echo $PATH &gt; path.log，”&gt;”创建一个新的文件path.log，如果该文件已存在，则会擦去该文件的所有内容而填充新的内容。如果希望能够将输出添加到文件的尾部，使用&gt;&gt;。下面对四种重定向进行一下总结： >重定义输出到文件，覆盖文件 >&gt;重定向输出到文件，添加到文件尾部 &lt;将输出重定向到文件。原来我们输入内容可能是从键盘输出，使用重定向可以将输入定位到文件，例如，我想统计某一段文字中的字数，该怎么处理呢？wc &lt; _config.yml &lt;&lt;是内联重定向符，不是从文件读入，而是从命令行读入，可以执行结束的标志位，例如： wc &lt;&lt; EOFstring1strgin2EOF 管道一个命令的输出可以作为另一个命令的输入，这种叫做管道，使用|，例如netstat -anp|grep :8080，将netstat的结果——网络端口情况的输出，作为grep的输入，从中查找”:8080”。 执行数学表达式shell中不能直接写数学运算表达式，要进行数学运算有下面两种方式。 expr命令 expr 1 + 5 expr只能执行一些简单的运算，例如：+,-,*,/,%,&gt;,&lt;,&gt;=,&lt;=,!,|,&amp;。如果要在shell脚本文件中使用： result=$(expr 1 + 5) 需要把expr命令执行的结果赋值给result。 使用方括号bash shell中可以使用$+方括号将数学表达式包裹起来。 result=$[1+5] 浮点运算上面的两种方式只适用与整数运算，如果要进行浮点运算，需要考虑下面的解决方案，使用bc： bc基本用法bc是内建的bash计算器，允许在命令行中输入浮点表达式，然后解释并计算该表达式，最后返回结果。能够识别数字（整数和浮点数）、变量、注释、表达式、结构语句（比如if else）、函数。输入bc访问bash计算器： bc 123456789bc 1.06.95Copyright 1991-1994, 1997, 1998, 2000, 2004, 2006 Free Software Foundation, Inc.This is free software with ABSOLUTELY NO WARRANTY.For details type `warranty'. 12*5.4 #输入的表达式64.8 #计算结果3.1456*(3 + 5)25.1648quit #quit命令退出 浮点运算是由内建变量scale控制的。必须将这个值设置为你希望在计算结果中保留的小数位数。print语句允许你打印变量和数字。 1234563.44 / 50scale=4var1=3.44 /5print var1.6880 在脚本中使用bc可以使用变量替换，将某一个命令的输出赋值给其他变量: variable=$(echo “options; expression” | bc) options部分允许设置变量，expression参数定义通过bc执行的数学表达式。也可以使用脚本中定义好的变量。 如果计算表达式比较长的话上面这种写法就不太好了，可以使用内联输入重定向： 123456varible=$(bc &lt;&lt; EOFoptionsstatementsexpresstionsEOF) 这样可以让表达式放在不同的行中，增加可读性。 退出脚本如果我们想要在脚本中中途退出怎么办呢？有时候由于一些特殊的情况，我们不希望继续执行下面的脚本了，这时候我们可以使用exit命令，exit命令后面可以接一个数字，表示退出状态码，正常退出为0，使用$?可以常看上一次的退出状态码。 综合演练接下来我们用到这一篇里面的所有知识，来创建一个能够从文件读取计算表达式，然后将计算结果输出到文件的shell脚本。 创建shell.sh，并赋予执行权限 编辑shell.sh12result=$(bc &lt; input)echo $result &gt;&gt; output 编辑input12345scale=4var1=3.14*2scale=0var2=11%10var1+var2","link":"/2019/06/19/os/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8Cshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/shell-script%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95/"},{"title":"spring-boot添加shiro的支持","text":"shiro是Apache公司开源的Java授权认证包。提供了登陆认证、授权验证、Session管理等多种功能，能够方便的用于用户登陆态维护、授权管理等等方面。 这篇文章主要记录如何在spring-boot中使用shiro，并给出对应配置的简单说明以及详细参考资料的链接。 需要做哪些事情？","link":"/2020/02/27/java/spring%E5%AE%9E%E6%88%98/spring-boot%E6%B7%BB%E5%8A%A0shiro%E7%9A%84%E6%94%AF%E6%8C%81/"},{"title":"typescript踩坑指南","text":"typescript中继承的属性和方法只有public或者protected的方法可以通过super来访问，不能使用super来访问父类中的属性；","link":"/2019/10/13/js/%E6%B7%B1%E5%85%A5typescript/typescript%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"title":"Linux下的基本命令","text":"这篇文章总结了linux下常用的命令，包括文件处理、进程处理、网络通信等等。主要基于《linux shell和脚本编程》的第三章和第四章。 文件系统linux系统下提供了完整的文件操作的命令，包括新建、删除、移动、赋值、压缩文件和目录。这里我们列举一下linux文件系统下的各目录的作用，常用的文件操作命令。 linux文件目录名称和作用 目录 用途 /|系统的根目录，所有目录都是其子目录/bin|二进制目录，存放很多用户级的GNU工具，一些系统常用的shell命令的二进制文件会放在这里/boot|启动目录，操作系统启动的配置文件会放在这里，这里的文件丢失或者损坏可能会导致不能开机/dev|设备目录，计算机上挂载的设备（例如USB磁盘）都会在该目录下创建一个设备节点/home|主目录，各非root用户的用户根目录是其子目录/lib|库目录，存放系统和应用程序的库文件/media|媒体目录，可移动设备的常用挂载点（没有挂载的目录时该目录是空的，磁盘挂载的时候可以可以挂载到任意目录，可移动设备挂载到这里只是常用的方式）/mnt|挂载目录，另一个可移动设备的常用挂载点/opt|可选目录，常用于存放第三方软件包/proc|进程目录，存放现有硬件及当前进程的相关信息/root|root用户的主目录/sbin|系统二进制目录，存放许多系统GNU管理员工具/run|运行目录，存放系统运作时的数据/sys|系统目录，存放系统硬件信息的相关文件/tmp|临时目录，在该目录中创建和删除临时工作文件/usr|用户二进制目录，存放用户GNU工具和数据文件/var|可变目录，用以存放经常变化的文件比如日志文件 linux文件目录linux中提供了文件链接，分为符号链接和硬链接。如果需要在系统上维护同一个文件的多分副本，除了保存多分单独的物理文件副本之外，还可以采用保存一份物理文件副本和多个虚拟副本的方法。 符号链接就是一个实实在在的文件，它指向存放在目录中的某一个地方的另一个文件 硬链接会会创建独立的虚拟文件。其中包含了原始文件的位置和信息 符号链接和硬链接的区别是，符号链接类似与windows下的快捷方式，通过一个独立的文件指向被符号链接的文件，访问链接文件就等于访问源文件，当源文件被删除后，再访问链接文件会报错。硬链接是对文件的一个虚拟拷贝，相当于多个指针指向同一个文件，删除其中一个硬链接不会影响其他的硬链接，硬链接不会创建新的文件，他们都共享同一个文件inode，本质上是同一个文件，只是创建了多个指针指向同一个文件，只要有一个文件指针在，文件就不会被删除。 文件遍历： cd：遍历目录，.代表当前目录，..代表父目录 ls：输出当前目录下的文件列表，-R选项显示子目录，-F选项区分目录和文件 文件操作: touch：新建文件 cp [source] [destination]：复制文件，通过-R选项可复制目录 ln：-s选项创建符号链接，不带选项就是创建硬链接 mv：移动或者重命名文件。mv只会影响文件名，不会影响时间戳和其他的文件属性。 rm：删除文件，-i提示，-f强制删除，-r递归删除子目录 vim [file]：使用vim编辑器修改文件 目录操作： mkdir：创建目录，要同时创建目录和子目录，需要使用-p参数 rmdir：删除目录，但是只能删除空目录，要删除非空目录，需要使用rm -r 文件查看： file：查看文件类型 cat：查看整个文件 more：分页查看 less：more命令的升级版 tail：查看文件尾部 head：查看文件头部 进程管理探查进程——psps命令能够探查进程，ps默认情况下不会输出很多信息，需要自己携带选项来获取更多的信息。例如，使用ps -ef来输出所有进程的详细格式。 ps只能显示某个特定时间点的信息，给出的是系统某一个时间点的进程信息片段，如果想观察进程的动态变化，ps命令就力不从心了。 实时检测进程——top直接在控制台中输入top，会打印动态变化的进程信息，大概每隔一秒钟变化一次。 其中注意几个特殊的结果参数： %CPU：进程使用的CPU比例 %MEM：进程使用的内存占可用内粗年的比例 PR：优先级 NI：进程的谦让度 VIRT：进程占用的虚拟内存总量 RES：进程占用的物理内存总量 SHR：进程和其他进程共享的内存总量 S：进程的状态（D：可中断的休眠状态，R：运行状态，S：休眠状态，T：跟踪状态或停止状态，Z：僵化状态） 结束进程当进程挂起时，如果重新激活进程，如何强制关闭进程。 linux采用信号来进行通信。进程如何处理信号是由开发人员通过编程来决定的。linux有两个命令可以向运行中的进程发出进程信号。 kill命令kill命令可通过进程ID（PID）给进程发信号。常用的方式是，使用ps -ef|grep &lt;名称&gt;找到进程id，然后通过kill pid来发出关闭进程的信号（一个TERM信号，表示尽可能终止） 用户管理查看系统信息1lsb_release -b","link":"/2019/08/05/os/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8Cshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/Linux%E4%B8%8B%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"},{"title":"ucore-os实验1：lab1练习2","text":"练习1我们已经学习了make的基本语法，ucore-os是如何编译生成的。这个练习我们我们来学习ucore-os是如何启动的。包括内核如何被加载到内存中，内核加载后执行了哪些操作。重点详细学习启动过程中涉及到的硬件知识。部分汇编语言细节不深究，只了解操作系统宏观一些的概念和过程，以及各部分所起到的作用。汇编细节后续有时间再深入学习。 练习2：使用qemu执行并调试lab1中的软件重点是熟悉qemu和gdb的调试，进行如下练习： 从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行 在初始化位置0x7c00设置实地址断点，测试断点正常 从0x7c00开始跟踪代码运行，将单步跟踪反汇编得到的代码于bootasm.S和bootblock.asm进行比较 自己找一个bootloader或内核中的代码位置，设置断点并进行测试 答案答：先对实验过程进行分析和记录，最后给出练习体的到答案 启动qemu并于gdb联调首先我们学习硬件模拟器的一些命令和调试方法。通过qemu的命令行参数，可以指定模拟硬件的参数，例如硬盘、显示器等等属性信息。下面首先分析一些命令行参数信息。 Makefile中有：123456789101112131415qemu-mon: $(UCOREIMG) $(V)$(QEMU) -no-reboot -monitor stdio -hda $&lt; -serial nullqemu: $(UCOREIMG) $(V)$(QEMU) -no-reboot -parallel stdio -hda $&lt; -serial nullqemu-nox: $(UCOREIMG) $(V)$(QEMU) -no-reboot -serial mon:stdio -hda $&lt; -nographicTERMINAL :=gnome-terminaldebug: $(UCOREIMG) $(V)$(QEMU) -S -s -parallel stdio -hda $&lt; -serial null &amp; $(V)sleep 2 $(V)$(TERMINAL) -e \"gdb -q -tui -x tools/gdbinit\"debug-nox: $(UCOREIMG) $(V)$(QEMU) -S -s -serial mon:stdio -hda $&lt; -nographic &amp; $(V)sleep 2 $(V)$(TERMINAL) -e \"gdb -q -x tools/gdbinit\"选项分析如下： -no-reboot：退出不重启 -parallel stdio：将模拟器的并行端口重定向为stdio -hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像 -serial null：将模拟器的串行端口重新向为null -monitor stdio：将显示器重定向到stdio -S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作 -s：-gdb::1234的缩写，等待连接到端口1234 相关命令分析如下： gnome-terminal -e command：启动一个新的gnome-terminal终端，-e command表示在该终端中将command字符串作为命令执行 gdb：运行gnu调试器，可以调试C程序 -q：不打印copyright信息 -x file：从文件中执行gdb命令 sleep 2：延迟两秒 gdbinit中的内容如下（通过命令行输入gdb进行gdb命令模式，然后输入help file等查看命令详情）：1234file bin/kernel # 表示调试bin/kernel文件，会读取文件中的符号表。该文件要使用-g选项生成才包含调试使用的信息。target remote :1234 # 连接到目标机器或者进程break kern_init # 在函数或者行数打断点continue # 继续执行 学习上面的命令行参数，我们得到两个问题的答案： 如何在qemu中启动我们生成的ucore.img镜像？使用-hda命令行参数，将ucore.img作为qemu的启动硬盘。启动后qemu模拟硬件会直接开始执行，通过-S参数可以暂停执行。 如何实现源码级调试？通过-s参数，开放qemu的1234端口，让gdb通过target remote命令来连接qemu开发的1234端口。连接以后就可以在gdb窗口中源码级远程调试qemu。 注意：远程调试必须在gdb中手动加载可执行文件，例如file bin/kernel。生成可执行文件的时候必须使用-g参数添加调试信息。调试bootloader时，只能使用逐指令调试（nexti）。调试内核时才能使用逐语句调试（next），推测可能bootloader是用汇编写的。 实验的预备知识这里学习一下计算机开机以后经历的过程。包括BIOS启动、BOOTLOADER执行、操作系统启动等过程。 保护模式和分段机制bootloader执行的时候，还处于实模式运行状态，此时是16位的运行状态，只能访问1MB的内存（这些都是由硬件控制的，在硬件层面提供保护）。 实模式将内存分段，代码和数据位于不同的区域（和保护模式的分段不同）。每段最大$2^{16}$字节。通过段地址*16+偏移直接访问物理地址。且不区分操作系统内存和用户程序内存。程序指针能任意改变内存中的任意地址中的内容。 保护模式启用32位运行状态，能够访问4G的线性地址空间和物理地址空间。通过分段存储机制和分页管理机制提供保护。不同的段有不同的特权优先级（硬件层面进行），访问没有优先级的内存CPU将会触发异常。 保护模式下有两个段表，GDT和LDT。ucore中只用了GDT。GDTR和LDTR两个48位寄存器分别存储了GDT和LDT的起始地址。 GDTR，GDTR图：1247 16 0|-----基址-------|-段表长度-|LDT是GDT的下一级，如果段寄存器（cs、ds、ss、es、gs、fs等）中的GDT描述符的TL位是1，则说明存在LDT中，此时会先找GDT，GDT对应项的内容时LDT的索引，然后找LDT中的对应项。LDT中的段地址+偏移地址=线性地址。 如果TI=0，则直接从GDT中找。（硬件进行的） 逻辑地址、线性地址、物理地址： 逻辑地址由段地址和偏移地址组成，段地址存在段寄存器中，偏移地址存在EIP中。逻辑地址也叫虚拟地址，程序中使用的是虚拟地址（指针中的只是逻辑地址中的偏移，还要加上段地址才能得到线性地址。不同程序的段地址不同，这就是硬件提供的保护机制）；段地址和偏移地址的地址表示形式就是逻辑地址。段地址+偏移地址=线性地址。线性地址在页处理机制处理后，就得到了物理地址。如果不启动分页机制，线性地址就是物理地址。 GDTR存的是GDT的起始地址和长度。GDT表的表项是64位，其中包括段基地址32位，段界限20位，各种段属性。段寄存器中存的是选择子：123段选择子15 3 2 0|----索引---|TI|RPL| 索引：表示第几个描述符（0开始），在转成地址的时候要*8（因为一个描述符8个字节） TI：1则表示在LDT中，0表示在GDT中 RPL：请求优先级，0最高3最低。ucore是使用了0和3。在段选择符被加载进寄存器时就会触发特权检查，只有当前代码段以及段选择符特权均小于等于GDT中描述符中的特权位时，才允许访问，否则CPU会出现保护异常。（硬件判断）","link":"/2019/11/30/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A02/"},{"title":"ucore-os实验1：安装并启动ucore-os","text":"我们需要了解很多的预备知识，可以先简略的过一遍基础知识，留个印象，很多东西比较抽象也记不下来，后面用到的时候再回过来看，并进一步查找资料，会有更好的学习效果。 本次实验的预备知识实验1的目的是完全掌握操作系统的编译和镜像生成（如何编译和链接）、IO设备访问（硬盘、键盘、显示器等）、内存访问机制、中断机制、BIOS启动、bootloader、实模式和保护模式（内容和如何切换）、elf文件格式等。这些基础知识也是后续实验所需要的基础知识。 主要涉及到的专业课程： 计算机接口技术：串行端口、中断控制器、时钟控制器等的访问。 编译技术：GCC编译器的使用、ld链接器的知识、make知识 计算机组成原理：计算机CPU、外设、内存、缓存等之间的关系 数据结构和算法：二分查找、链表等基础知识的运用 编程语言：C语言、汇编语言 本实验需要掌握的基础知识： GCC基础和linux命令 qemu与GDB调试 BIOS和bootloader启动过程 elf可执行文件结构 实模式和保护模式 串行端口的访问，访问磁盘、显示器、键盘等 磁盘的基础知识 中断机制 安装实验环境以下所有的安装步骤都是在centos 7下进行。其他环境下的安装请参照其他资料。 安装gcc、qemugcc是编译器，qemu是硬件模拟器，通过编译器编译生成.img文件，然后通过qumu硬件模拟器来启动编译后的操作系统。第一次实验的主要目的是： 了解gcc编译内核的过程 学习make&amp;makeFile的使用 在qemu上调试内核 了解bootloader的代码 在centos 7中，使用yum安装： sudo yum install gcc gcc-c++ qemu 安装完成后在命令行输入qemu，提示无命令，这是因为默认安装的命令是qemu-system-i386，可以创建一个链接文件qemu链接到qemu-system-i386: cd /usr/bin sudo ln -s qemu-system-i386 qemu 提示：如果编译过程中出现错误，请尝试升级gcc编译器版本。 获取实验代码在这里获取代码，直接git clone下来就ok。 编译&amp;调试内核进入到clone下来的项目下的lab1目录下，执行： make 会生成bin文件夹，该文件夹下有.img文件。 下一步我们开始调试内核： 首先我们在qemu中启动内核，注意要使用-S -s操作来暂停cpu执行，因为我们要等待gdb调试程序的接入： qemu -s -S -hda ./bin/ucore.img -monitor stdio 打开另一个命令行窗口： target remote:1234break memsetcontinue 这时候就会暂停在断点位置，使用next，可以继续执行内核代码。如果想进一步了解qemu和gdb的细节，可参阅上面提供的学习笔记。","link":"/2019/06/16/os/ucore_os/ucore-os-lab1%EF%BC%9A%E5%AE%89%E8%A3%85%E5%B9%B6%E5%90%AF%E5%8A%A8ucore-os/"},{"title":"ucore-os实验1：lab1练习1","text":"练习1：理解通过make生成执行文件的过程要求如下： 操作系统镜像文件ucore.img是如何一步一步生成的？（需要详细解释Makefile中每一条相关命令和命令参数的含义，以及说明命令参数导致的结果） 一个被系统认为符合规范的硬盘主引导扇区的特征是什么？ 答：先分析Makefile的整体结构，整个Makefile大概分成下面几个部分（从前到后）： 变量定义：定义大量和编译、链接、linux命令、环境变量定义等相关的变量 include：包含了function.mk，function.mk中定义了很多和编译相关的工具函数 函数定义：基于function.mk中的函数再封装了一些函数，用于生成规则并修改前面定义的变量等 规则生成：使用前面定义的函数生成规则，分别生成lib、kernel、bootblock、sign等的规则 ucore.img生成：定义ucore.img生成的规则 通用规则定义：定义了清楚、打分、qemu调试等等规则 然后我们从make默认的入口开始——TARGETS。在makefile中有：12TARGETS: $(TARGETS).DEFAULT_GOAL: TARGETS上面说明了输入make，找的是TARGETS规则，而TARGETS规则依赖的是变量TARGETS扩展后的值。 然后我们找TARGETS变量，发现TARGETS是一个全局变量，其值在function.mk中定义的函数中改变。当调用create_target时，就会向TARGETS后面添加内容。Makefile中对create_target包装了一层create_target_cc，将最后两个参数设置成CC和CFLAGS。我们看看create_target的实现： 1234567891011121314151617# add packets and objs to target (target, #packes, #objs[, cc, flags])define do_create_target__temp_target__ = $(call totarget,$(1))__temp_objs__ = $$(foreach p,$(call packetname,$(2)),$$($$(p))) $(3)TARGETS += $$(__temp_target__)ifneq ($(4),)$$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$$@) $(V)$(4) $(5) $$^ -o $$@else$$(__temp_target__): $$(__temp_objs__) | $$$$(dir $$$$@)endifendef# add packets and objs to target (target, #packes, #objs, cc, [, flags])create_target = $(eval $(call do_create_target,$(1),$(2),$(3),$(4),$(5)))create_target_host = $(call create_target,$(1),$(2),$(3),$(HOSTCC),$(HOSTCFLAGS)) 该函数的作用就是由传进来的参数构建出一个规则。规则生成的方式是：将传进来的target参数扩展成target，packs+objs参数扩展成prerequisites。然后如果有第四个参数，添加编译的recipe，否则使用默认的。 接着我们分析用到了create_target的代码，看看有什么效果，例如：$(call create_target,kernel)。这里只传了target为kernel，那么得到的结果是：12TARGETS += bin/kernelbin/kernel: | bin然后我们看到代码中总共有四次使用到了create_target，分别是：1234$(call create_target,kernel)$(call create_target,bootblock)$(call create_target_host,sign,sign)$(call create_target,ucore.img)根据上面的分析，我们得到运行结果：123456TARGETS = bin/kernel bin/bootblock bin/sign bin/ucore.imgbin/kernel: | binbin/bootblock: | binbin/sign: __objs_sign | bin @gcc -g -Wall -O2 __objs_sign -o bin/signbin/ucore.img: | bin上面的-g -Wall -O2分别表示输出调试信息，输出警告，采用二级代码优化。-o指定输出的文件名。 所以对于入口TARGETS: $(TARGETS)我们可以得到TARGETS: bin/kernel bin/bootblock bin/sign bin/core.img。接下来我们找kernel和bootblock等为target的规则。 对于kernel，有：12345678910KOBJS = $(call read_packet,kernel libs)kernel = $(call totarget,kernel)$(kernel): tools/kernel.ld$(kernel): $(KOBJS) @echo + ld $@ $(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS) @$(OBJDUMP) -S $@ &gt; $(call asmfile,kernel) @$(OBJDUMP) -t $@ | $(SED) '1,/SYMBOL TABLE/d; s/ .* / /; /^$$/d' &gt; $(call symfile,kernel)扩展变量之后的结果是：123456789kernel = bin/kernelbin/kernel: tools/kernel.ldbin/kernel: $(__objs_kernel) $(__objs_libs) @echo + ld bin/kernel @ld -nostdlib -T tools/kernel.ld -o bin/kernel $(__objs_kernel) $(__objs_libs) @objdump -S bin/kernel &gt; kernel.asm @objdump -t bin/kernel | sed '1,/SYBOL TABLE/d; s/ .* / /; /^$$/d' &gt; kernel.sym通过这里我们知道了kernel的编译规则（这里其实是链接），依赖于$(__objs_kernl)和$(__objs_libs)(待会儿说这个是啥)。recipe中的第一行说明当前链接的文件。第二行指定tools/kernel.ld脚本链接，链接$(__objs_kernel)和$(__objs_lbs)，生成bin/kernel。后面的objdump反编译bin/kernel，提取出汇编代码和符号表中的内容。 接下来我们看看这个__objs_kernel的内容是什么。看function.mk中，第一行就是：1OBJPREFIX := __objs_然后发现于下面的几个函数有关：1234567891011121314151617181920212223242526packetname = $(if $(1),$(addprefix $(OBJPREFIX),$(1)),$(OBJPREFIX))# add files to packet: (#files, cc[, flags, packet, dir])# define定义了一个多行变量，作为一个自定义函数。$$是因为eval扩展一次，作为make语法解析的时候扩展一次# 如果想在作为make解析的时候扩展，使用$$define do_add_files_to_packet__temp_packet__ := $(call packetname,$(4))ifeq ($$(origin $$(__temp_packet__)),undefined)$$(__temp_packet__) :=endif__temp_objs__ := $(call toobj,$(1),$(5))$$(foreach f,$(1),$$(eval $$(call cc_template,$$(f),$(2),$(3),$(5))))$$(__temp_packet__) += $$(__temp_objs__)endef# add objs to packet: (#objs, packet)define do_add_objs_to_packet# __temp_packet值为__objs_$(2)__temp_packet__ := $(call packetname,$(2))ifeq ($$(origin $$(__temp_packet__)),undefined)$$(__temp_packet__) :=endif$$(__temp_packet__) += $(1)endefadd_files_cc = $(call add_files,$(1),$(CC),$(CFLAGS) $(3),$(2),$(4))分析代码知道，$(__temp_packet) = __objs_$(4)，__temp_objs值为$(1)将后缀改为.o的文件名。如果是do_add_files_to_packet则还有一个将files编译的过程。 大致知道了__objs_xxx是从哪设置的，接下来具体分析，从Makefile中调用的位置开始：1$(call add_files_cc,$(call listf_cc,$(LIBDIR)),libs,)会得到（不是最终结果，稍微扩展了一下便于分析）：12345678910__temp_packet = __objs_libsobj/libs/*.d: libs/*.c | obj/libs/ @cc -Ilibs ...obj/libs/*.o: libs/*.c | obj/libs/ @echo + cc $&lt; @cc -I/libs ...__objs_libs += obj/libs/*.o 这下我们知道__objs_libs的来源及其值了。可以理解了整个项目的构建过程： 从TARGET: $(TARGETS)作为入口的rule TARGETS的值通过create_target函数改变，最后的结果是TARGETS: bin/kernel bin/bootblock bin/sign bin/ucore.img。targets总共有四个依赖 四个依赖分别扩展成： bin/kernel: __objs_kernel __objs_libs：__objs_kernel和__objs_libs分别是kernel和libs文件夹下c文件编译后得到的.o文件。生成.o文件的规则通过add_files_cc添加。 bin/bootblock: obj/boot/*.o | bin/sign：其中，obj/boot/*.o，通过$(foreach f,$(bootfiles),$(call cc_compile,$(f),$(CC),$(CFLAGS) -Os -nostdinc))生成规则。注意bin/bootblock的recipe中只是生成了obj/bootblock.out，在脚本中执行了bin/sign，sign将obj/bootblock.out作为输入，输出了bin/bootblock bin/sign：$(call add_files_host,tools/sign.c,sign,sign)生成如何生成.o文件的规则。$(call create_target_host,sign,sign)生成bin/sign: __objs_sign | bin这里的__objs_sign也是在前面add_files_host的时候设置，其值是sign依赖的.o文件 bin/ucore.img：到了最关键的ucore.img的生成了，规则是：$(UCOREIMG): $(kernel) $(bootblock)依赖于上面的kernel和bootblock的结果。其recipe脚本为dd命令，拷贝一个文件并转换格式到目标文件。有三条dd命令，第一条是$(V)dd if=/dev/zero of=$@ count=10000拷贝仅仅10000个block。后面两条使用相同的形式将bootblock拷贝到第一个块，kernel拷贝到后面的块，生成了ucore.img 再次总结一下，ucore.img的编译过程是： 分别设置bin/kernel、bin/sign、bin/bootblock、bin/ucore.img四个文件的规则。kernel和sign的prerequisites都被设置成临时变量objs_xxx。生成过程就是就objs_xxx表示的.o文件链接成可执行文件。 临时变量__objs_xxx和全局变量TARGETS在add_files、add_target等工具函数中设置和改变；add_files函数还有从.c到.o文件的编译规则。 bootblock只生成obj/bootblock.out，在bin/sign脚本执行下才会生成bin/bootblock。所以在bootblock的依赖中添加了bin/target作为前置依赖，保证先生成bin/target。 当kernel和bootblock都生成好了以后在生成ucore.img。ucore.img其实只是将bootblock放在了第一个block，kernel放在了后面的block 接下来我们分析编译和链接中的选项的意义。包括从.c到.o以及.o链接成结果中使用的选项。首先是gcc：123CFLAGS := -march=i686 -fno-builtin -fno-PIC -Wall -ggdb -m32 -gstabs -nostdinc $(DEFS)CFLAGS += $(shell $(CC) -fno-stack-protector -E -x c /dev/null &gt;/dev/null 2&gt;&amp;1 &amp;&amp; echo -fno-stack-protector) -march=i686：生成对应i686指令集的机器码 -fno-builtin：不使用内置函数，除非是使用__builtin_开头的函数 -fno-PIC：跟硬件有关，暂时没有找到其用处 -Wall：输出警告信息 -ggdb：产生用于gdb的调试信息 -m32：生成32位环境下的代码，此时int和long都视为32bit -gstabs：使用stabs格式产生调试信息，不需要GDB扩展 -nostdinc：不在系统目录中查找header文件，只有-I等指令指定的目录被搜索（在操作系统开发中不使用标准库，而自己编写适应目标处理器架构的标准库，此时需要这个指令，将对标准库的搜索重定向到自定义的目录） -fno-stacl-protector：-fstack-protector的作用是生成额外的代码用于buffer溢出检查。no的意思应该是不生成额外检查的代码。 -I添加头文件检索目录 然后是ld：123456LDFLAGS := -m $(shell $(LD) -V | grep elf_i386 2&gt;/dev/null | head -n 1) # 结果是elf_i386LDFLAGS += -nostdlib$(V)$(LD) $(LDFLAGS) -T tools/kernel.ld -o $@ $(KOBJS)$(V)$(LD) $(LDFLAGS) -N -e start -Ttext 0x7C00 $^ -o $(call toobj,bootblock) -m elf_i386：仿真仿真链接器 -nostdlib：链接的时候仅仅只搜索命令行指定的目录（因为操作系统不使用标准库） -T：使用链接脚本，指定的链接脚本将替换默认的链接脚本 -N：将代码段和数据段设置成可读和可写的。同时不将数据段按页对齐，同时仅用共享库的链接。 -e start：将start这个明确的符号作为程序开始执行的入口，而不是使用默认的入口。如果没有名字位start的符号，将会视图将entry翻译成数字，并作为入口地址。 -Ttext：将.bss、.data、.text放到指定的绝对地址，例如0x7C00 ucore-os的Makefile还是比较复杂的，定义了很多自定义函数，层层嵌套。而且在没有接触过make等相关gcc编译工具的基础上，更加困难了。但是通过产看make、gcc、ld等工具的文档，一边分析，一边学习。通过一周的努力，终于弄清楚了ucore-os内核和bootloader的编译链接并生成img文件的过程。里程碑！ 第二问：分析构建bootblock的sign.c源码：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;errno.h&gt;#include &lt;string.h&gt;#include &lt;sys/stat.h&gt;intmain(int argc, char *argv[]) { struct stat st; if (argc != 3) { fprintf(stderr, \"Usage: &lt;input filename&gt; &lt;output filename&gt;\\n\"); return -1; } if (stat(argv[1], &amp;st) != 0) { fprintf(stderr, \"Error opening file '%s': %s\\n\", argv[1], strerror(errno)); return -1; } printf(\"'%s' size: %lld bytes\\n\", argv[1], (long long)st.st_size); if (st.st_size &gt; 510) { fprintf(stderr, \"%lld &gt;&gt; 510!!\\n\", (long long)st.st_size); return -1; } char buf[512]; memset(buf, 0, sizeof(buf)); FILE *ifp = fopen(argv[1], \"rb\"); int size = fread(buf, 1, st.st_size, ifp); if (size != st.st_size) { fprintf(stderr, \"read '%s' error, size is %d.\\n\", argv[1], size); return -1; } fclose(ifp); buf[510] = 0x55; buf[511] = 0xAA; FILE *ofp = fopen(argv[2], \"wb+\"); size = fwrite(buf, 1, 512, ofp); if (size != 512) { fprintf(stderr, \"write '%s' error, size is %d.\\n\", argv[2], size); return -1; } fclose(ofp); printf(\"build 512 bytes boot sector: '%s' success!\\n\", argv[2]); return 0;}sign.c从main接收两个参数，一个是输入文件名argv[1]，另一个是输出文件名argv[2]。首先从获取argv[1]文件的文件信息，通过struct stat获得。然后输出argv[1]的大小并进行判断。如果size &gt; 510则过大，报错退出。然后从读出argv[1]中的内容，并判断读出的内容的大小是不是和stat中st_size属性值一致。如果不是，报错退出。再把前512个字节中的最后两个字节设置成0x55和0xAA。然后把这512个字节写入到argv[2]。 从上面的流程可以看出，规则是： 总大小为512字节 最后两个字节空出来填充0x55和0xAA，bootloader的内容必须小于510字节。","link":"/2019/06/17/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A01/"},{"title":"ucore-os-lab8：SFS文件系统设计和实现","text":"","link":"/2020/01/23/os/ucore_os/ucore-os-lab8%EF%BC%9ASFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/"},{"title":"ucore-os-lab1：练习3、练习4","text":"练习三需要分析如何从实模式进入保护模式，重点是： 为何开启A20以及如何开启A20？ 如何初始化GDT表？ 如何使能和进入保护模式？ 详细的解释请看ucore-os笔记4：bois和bootloader。这里只给出简单解释： 在实模式下只能访问1MB的内存，这是为了向下兼容，所以实模式下禁用了第21根地址线保证最大只能访问1MB内存。为了硬件设计成本的考虑，A20的控制放在键盘控制器中，需要设置键盘控制器内部输出端口的对应位来开启。如果不开启A20，第21根地址线就无法使用，保护模式下不能完整的访问4G内存。 需要将GDT表放置到内存中，表项是8字节大小，按照一定的结构存储。然后需要将GDT表的入口地址（线性地址）和大小放到GDTR寄存器中，使用lgdt指令可以设置GDTR寄存器，lgdt指令只能在特权为0的情况下使用 使用保护模式，需要设置CRO寄存器中的PE位来开启保护模式，然后通过ljmp设置cs寄存器，mov设置其他的段寄存器。之后的内存访问就使用分段机制了。 练习4分析bootloader如何加载ELF格式的OS。这里需要了解： ELF格式的结构？ 如何读取硬盘扇区？ 如何加载ELF格式的OS？ 详细信息都在ucore-os笔记4：bois和bootloader中。下面是简单的回答： ELF格式分成ELF header和多个段。ELF可以分成可执行、链接库等等格式，可执行中最终要的elf program header。elf header中给出了elf program header的偏移和项数，elf program header是一个数组，每一项表示一个段的偏移、大小和起始虚拟地址，通过偏移+文件大小可以知道段在elf文件中的位置，将其加载到内存中对应的虚拟地址的位置即可。（虚拟地址是由链接器决定的，在编译时就确定了在其地址空间的哪一个部分，通过设置链接器可以改变放置的虚拟地址的位置）。 硬盘只能按扇区对齐读取，一个扇区是512字节。通过访问硬盘控制器并设置相应的命令和参数，就可以从键盘控制器中读取到内存中。 分析ELF结构，从program header中知道段的数量和在磁盘中的位置，通过这些信息将其加载到内存中。","link":"/2019/12/22/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A03%E3%80%81%E7%BB%83%E4%B9%A04/"},{"title":"ucore-os-lab2：实验准备","text":"经过实验1的学习和练习，我们应该能熟练掌握下面的知识： 操作系统的基本硬件知识：分段、中断、计算机加电后的执行过程、IO设备初始化过程（选学） 软件知识：函数堆栈、x86常用汇编指令、bootloader的工作原理、ELF格式、操作系统的初始化过程 工具知识：make、gdb、gcc、qemu、shell、c和汇编的混合编译和链接 实验2需要掌握的知识： 硬件：分段分页机制结合 软件：分段分页机制下的bootloader和操作系统的初始化过程、双向链表 工具：链接器生成的虚拟地址以及如何生成虚拟地址 下面的相关笔记会介绍一些相关的知识： diff和patch命令的使用 diff和patch命令的使用diff是linux命令用于比较文件和文件夹的差异，patch也是linux命令，可以通过patch应用diff得到的结果，将差异应用到目标文件夹中。类似git的merge功能。 例如：123diff -r -u -P proj_a_original proj_a_mine &gt; diff.patchcd proj_bpatch -p1 -u &lt; ../diff.patch上面的diff将proj_a_mine相对于proj_a_original的修改输出到diff.patch文件中。proj_a_original表示修改之前的文件夹，proj_a_mine表示修改之后的文件夹。 后面的patch将a文件夹的修改应用到b文件夹。例如我们在完成了实验1后，可以用diff比较我们修改的实验1和原始实验1文件夹的差异，然后将修改应用到实验2，这样就能在实验2的文件夹中使用实验1的结果了。 下面对diff和patch的参数做一个分析，diff： -r：递归处理子目录 -u：在合并的上下文中输出行号 -P：显示每一个修改的C函数 patch： -p1：去除文件名前面的一个component，这个用于子目录同步，例如./lab2/xxxx和当前为lab3目录下，就需要使用p2，因为差了两级目录，如果是lab2/xxx，就用p1，因为只差了一级目录（从’/‘分割来看，尽管./lab2/xxx和lab2/xxx表示的路径相同） -u：作为一个整体的差异翻译patch文件 这里需要注意patch也需要&lt;来从文件重定向输入。","link":"/2019/12/30/os/ucore_os/ucore-os-lab2%EF%BC%9A%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87/"},{"title":"ucore-os-lab1：练习5、6、挑战练习","text":"练习5 函数堆栈调用实验5需要实现函数调用堆栈，请参考ucore-os-lab的要求。 这里我们需要了解函数调用的堆栈变化原理才能完成该练习。函数调用的堆栈变化与两个寄存器相关，ESP和EBP： ESP是栈指针寄存器，存储了当前栈的位置 EBP是基址指针寄存器，存储了当前函数的栈的起始位置 调用一个函数时，执行的压栈顺序如下：参数、返回地址、EBP寄存器。后面再压栈的时当前执行的函数的局部变量。12345678910-------- 栈的高位地址...参数3参数2参数1返回地址上一层ebp &lt;- 当前ebp寄存器的值局部变量...-------- 函数调用的汇编代码其实就是多个push（参数push）和一个CALL，CALL自动将返回地址和ebp压栈，并更新ebp的值 了解了上述的基础知识以后，就可以进行练习的开发了。练习5需要输出ebp、返回地址和参数，并输出源代码的位置，如下例：12345678910111213141516ebp:0x00007b28 eip:0x00100992 args:0x00010094 0x00010094 0x00007b58 0x00100096 kern/debug/kdebug.c:305: print_stackframe+22ebp:0x00007b38 eip:0x00100c79 args:0x00000000 0x00000000 0x00000000 0x00007ba8 kern/debug/kmonitor.c:125: mon_backtrace+10ebp:0x00007b58 eip:0x00100096 args:0x00000000 0x00007b80 0xffff0000 0x00007b84 kern/init/init.c:48: grade_backtrace2+33ebp:0x00007b78 eip:0x001000bf args:0x00000000 0xffff0000 0x00007ba4 0x00000029 kern/init/init.c:53: grade_backtrace1+38ebp:0x00007b98 eip:0x001000dd args:0x00000000 0x00100000 0xffff0000 0x0000001d kern/init/init.c:58: grade_backtrace0+23ebp:0x00007bb8 eip:0x00100102 args:0x0010353c 0x00103520 0x00001308 0x00000000 kern/init/init.c:63: grade_backtrace+34ebp:0x00007be8 eip:0x00100059 args:0x00000000 0x00000000 0x00000000 0x00007c53 kern/init/init.c:28: kern_init+88ebp:0x00007bf8 eip:0x00007d73 args:0xc031fcfa 0xc08ed88e 0x64e4d08e 0xfa7502a8&lt;unknow&gt;: -- 0x00007d72 – 结合上面函数调用栈的规律，看下图：123456789101112-------- 栈的高位地址 ... |-&gt;上上一层ebp的地址 | ... | 参数3 | 参数2 | 参数1 &lt;- ebp+8 | 返回地址 &lt;- ebp+4，该函数调用的参数、返回地址、ebp都是4个字节 |---上一层ebp的地址 &lt;- 当前ebp寄存器的值是栈中的地址 局部变量 ...--------栈中的ebp就像一个链表，通过ebp的链接关系，我们就可以得到栈调用关系。看代码：1234567891011121314151617181920212223242526272829303132333435voidprint_stackframe(void) { /* LAB1 YOUR CODE : STEP 1 */ /* (1) call read_ebp() to get the value of ebp. the type is (uint32_t); * (2) call read_eip() to get the value of eip. the type is (uint32_t); * (3) from 0 .. STACKFRAME_DEPTH * (3.1) printf value of ebp, eip * (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4] * (3.3) cprintf(\"\\n\"); * (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc. * (3.5) popup a calling stackframe * NOTICE: the calling funciton's return addr eip = ss:[ebp+4] * the calling funciton's ebp = ss:[ebp] */ uint32_t ebp = read_ebp(), eip = read_eip(); int j = 0; while(ebp &amp;&amp; j &lt; STACKFRAME_DEPTH) { cprintf(\"ebp:0x%08x eip:0x%08x args:\",ebp, eip); uintptr_t ptr = ebp+8; for(int i = 0;i &lt; 4;i++) { cprintf(\" 0x%08x\", *((uint32_t*)ptr+i)); } cprintf(\"\\n\"); print_debuginfo(eip-1); // 这里取的是栈中的ebp和返回地址，所以必须先取eip // 没有重复的原因是，read_eip中取到的eip，调用read_eip函数压了一次栈 eip = *((uint32_t*)ebp+1); // ebp是一个整数，但是表示一个地址，(uint32_t*)ebp会将ebp的值作为地址解释 // *(uint32_t*)ebp，取地址中的内容，是上一个ebp的地址 ebp = *(uint32_t*)ebp; }}read_ebp和read_eip其实就是两个内联汇编函数，加载ebp和[ebp+4]（返回地址）到C变量中。因为ebp存的是地址，而eip的地址相对于ebp的值，所以必须先取eip的值，再变ebp的值。print_debuginfo()是一个ucore-os已经提供的函数，传入地址，得到文件名和行数，实现原理是将编译器的符号表信息通过链接器加载到内核的内存中，通过查找符号表就知道对应哪一个符号、哪一个文件、哪一行。 eip实际上是返回地址，返回地址是函数调用的下一条指令的地址，所以这里参数传的是eip-1，就能定位到函数调用的指令中。 练习6 完善中断初始化和处理练习6要完成下面几个目标： 了解中断向量表的结构，一个表项几个字节？如何寻址中断向量表？ 完善kern/trap/trap.c中的idt_init 完善trap函数，处理时钟中断，每100次时钟中断输出一个100tick 这一部分需要了解中断的相关知识和ucore-os对中断的实现的知识才能顺利完成，请参考ucore-os笔记6：中断和异常。 ucore-os提供了SETGATE宏函数，传入参数，扩展成一个门表项（可以是任务门、中断门、陷阱门、调用门，反正结构都一样），可以在代码中利用该宏。vector.S中定义了__vectors.S符号，其值是中断向量处理程序入口数组的起始地址。由于是全局符号，链接后能够直接在C中访问。 idt_init函数中要做的事情就是构造idt表项，并将idt的起始地址加载到IDTR中。要注意不同中断的权限不一样，例如T_SYSTEM可以在用户态（特权级为3调用），而其他的只能在特权级为0调用。还要注意向量的起始地址在__vectors中。看代码，注意注释中的细节：123456789101112131415161718// 将__vectors[]声明为外部变量，__vectors[]在汇编文件中定义，链接后通过extern可以访问外部文件中的符号// 这里只能将__vectors声明为数组，而不能声明为指针。如果是指针会访问到数组的第一个元素，// 因为将vectors当作指针的地址了，指针的值就是数组的第一项了。虽然数组和指针可以相互转化，// 但是将一个地址作为指针的地址还是作为数组的地址是不一样的extern uintptr_t __vectors[256];// 初始化中断向量表idt，处理程序的入口在__vectors[]中，__vectors[]的每一项是一个地址// T_SYSCALL是trap，并且DPL是用户级3。其他的中断都是interrupt，DPL为0for(int i = 0;i &lt; 256;i++) { // cprintf(\"interrupt entry:0x%08x\\n\", __vectors[i]); if(i == T_SYSCALL) { // KERNEL_CS是内核代码段的起始地址 SETGATE(idt[i],1,KERNEL_CS,__vectors[i],3); } else { SETGATE(idt[i],0,KERNEL_CS,__vectors[i],0); }}lidt(&amp;idt_pd); 处理时钟中断当中断发生时，调用链是__vectors中的入口地址-&gt;__alltraps-&gt;trap-&gt;trap_dispatch-&gt;根据中断向量号处理。 所以我们找到trap_dispatch中的时钟中断：12345678910111213141516171819202122/* trap_dispatch - dispatch based on what type of trap occurred */static voidtrap_dispatch(struct trapframe *tf) { char c; switch (tf-&gt;tf_trapno) { case IRQ_OFFSET + IRQ_TIMER: /* LAB1 YOUR CODE : STEP 3 */ /* handle the timer interrupt */ /* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks(). * (3) Too Simple? Yes, I think so! */ ticks++; if(ticks == 100) { print_ticks(); ticks = 0; } break; // ... }}使用IRQ_OFFSET=32是因为中断向量的前32个被CPU保留了，像时钟中断等硬件中断都由系统设计者决定应该使用哪个中断，ucore-os设计将IRQ_TIMER作为自定义的第一个中断，值为0，所以IRQ_OFFSET+IRQ_TIMER=32，是第一个自定义的中断向量。 这里各种中断与中断控制器有关，中断控制器的设置在操作系统初始化的时候进行，请看ucore-os的初始化过程和IO和基本硬件访问。IO和计算机接口技术和计算机组成原理的知识息息相关，ucore-os中用到的组成原理和计算机接口知识间接给出大致的了解。 挑战练习1 添加syscall添加一个用户态函数，当内核初始完毕从内核态切换到用户态，在用户态通过syscall获取内核中的tick值，然后再从内核态切换到用户态。调用结构如图：12345678910static voidswitch_test(void) { print_cur_status(); // print 当前 cs/ss/ds 等寄存器状态 cprintf(\"+++ switch to user mode +++\\n\"); switch_to_user(); // switch to user mode print_cur_status(); cprintf(\"+++ switch to kernel mode +++\\n\"); switch_to_kernel(); // switch to kernel mode print_cur_status();}切换函数通过中断的方式实现，再trap里面完成T_SWITCH_TO*中断。完成后执行make grade能看到分数。 答：这里我们需要弄清楚两部分的知识，一个是如何完成用户态到内核态的切换，另一个是添加一个系统调用获取tick。 添加系统的调用非常简单。就是在中断初始化时，将中断向量表的T_SYSCALL设为用户态（DPL=3，这样能够由用户态触发该中断），然后在trap_dispatch中添加T_SYSCALL的处理代码。 内核和用户态的切换通过中断调用进行，将用户到内核的中断设置成用户可访问，用户就能够通过中断切换到内核态，从中断返回时，会从栈中恢复cs、ds等等寄存器，用户态和内核态的区分实际上就是cs中的DPL的区分。只需要在中断处理程序中设置cs、ds等寄存器的值，即可实现用户态和内核态的切换。 这里需要注意，从中断返回时，如果发生了特权级的切换，会多弹出ss和esp，一定要处理这一点。例如在switch_to_user中，从内核态返回用户态，会多弹出SS和ESP，但是进入中断的时候没有发生特权级切换，所以不会压入ss和esp，这里需要手动压入（或者使用subl $8, %%esp预留位置，然后int后接movl %%ebp, %%esp恢复esp，个人不推荐这种方式，如果栈中有局部变量，这样就会出问题）。switch_to_kernel中，因为产生中断的时候是从用户态到内核态，会压入ss和esp；但是返回的时候是从内核态到内核态，所以不会弹出ss和esp，需要手动弹出。看代码：123456789101112131415161718192021222324252627282930313233343536static voidlab1_switch_to_user(void) { //LAB1 CHALLENGE 1 : TODO // esp压栈两个字节，为esp和ss留出空间 // 因为从切换到用户态，执行iret时，会从内核栈中弹出esp和ss，我们在trap.c的trap函数中，改变栈中的ss，就可以切换到用户堆栈 // 但是最开始时内核态到内核态，cpu不会压栈esp和ss，所以需要手动压栈 // // 从中断返回的时候是从内核态返回到用户态，发生了特权级的切换，所以会弹出esp和ss // 但是产生中断的时候cpu不会自动压入，所以要手动压入 asm volatile ( \"movl %%esp, %%eax;\" \"pushl %%ss;\" \"pushl %%eax;\" \"int %0;\" // \"movl %%ebp,%%esp;\" : :\"i\"(T_SWITCH_TOU) :\"%eax\"); // print_stackframe();}static voidlab1_switch_to_kernel(void) { //LAB1 CHALLENGE 1 : TODO // 注意触发中断的时候压入了ss和esp，但是返回的时候并不会弹出，因为返回的时候没有发生特权级的切换 // 但是这里不能直接将esp+8，因为从用户到内核态的中断使用的内核栈是一个临时栈 // 正确的方式取出ss和esp，然后恢复到ss和esp寄存器中，也不能直接pop，因为pop会改变esp... asm volatile ( \"int %0;\" \"movl %%esp, %%eax;\" \"movw 4(%%eax),%%ss;\" \"movl (%%eax),%%esp;\" : :\"i\"(T_SWITCH_TOK) :\"%eax\");} lab1虽然启动的分段机制，但是在物理地址上并没有区分内核段和用户段，也没有区分数据段和代码段，GDT中所有段的基址都是0，limit都是4G，所以这里不需要考虑切换cs后物理寻址的问题。相同的偏移，分段处理后在lab1中会得到相同的物理地址。 挑战练习2 键盘实现用户模式到内核模式的切换使用键盘完成用户模式到内核模式的切换。 答：上一个实验已经完成了用户模式到内核模式的切换，这里只需要复用上一次实验的代码就可以了。","link":"/2019/12/22/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A05%E3%80%816%E3%80%81%E6%8C%91%E6%88%98%E7%BB%83%E4%B9%A0/"},{"title":"ucore-os思考与总结","text":"2019.6.24开始着手操作系统的学习和开发，需要了解的知识有很多很多，需要了解linux开发环境，包括linux命令、shell脚本、linux下的编译器gcc的使用（包括gcc的编译选项、makefile的使用、gcc混合编译——内联汇编——c和汇编），还有C语言的细节，结构、函数指针，还有算法、数据结构，还有硬件底层的知识，x86下CPU的工作模式，实模式和保护模式，mmu内存管理硬件单元，分段分页，特殊寄存器，中断处理。操作系统一般都是一个较大型的项目，能够锻炼大型项目的编程能力。一定要坚持下来，可能知识会多一点，但是学到的东西一定会更多！ 接下来要一步一步来，首先要把基础学好，linux命令行和shell脚本编程以及gcc、makefile的使用，第一步首先弄清楚ucore整体的编译过程，它用到了linux和gcc makefile的细节都要搞清楚，并做好笔记。 然后开始进行操作系统内核的开发，了解操作系统的硬件基础、内核的工作原理。 然后在进行操作系统顶层的开发。 完成了这些之后，综合内核和已有的库进行扩展，进行网络协议实现等基础设施的建设，希望最终能做出一个带图形界面的完整移动操作系统！ 问题记录gnu ld链接器的工作原理？ 如何进行链接？ 链接后的地址如何分配？链接指定的地址有什么用，例如0x7c00？ 链接后生成的文件的格式？格式各部分和操作系统的关系？ linux上的可执行文件和生成的在硬件上的可执行文件（例如bootloader和操作系统内核）的区别？ 如何使用objdump、objcopy等工具？ objdump等工具用于什么对象？ 这些工具有哪些作用？ 汇编语言的知识？ 代码段？数据段？和操作系统还有硬件的关系？ .code16和.code32的细节？ lgdtr的细节？ .long .word的细节？ GCC下如何编译.s文件？和编译.o文件一样，直接使用gcc命令，编译得到.o文件。将汇编得到的.o文件和c得到的.o文件进行链接，可以生成可执行文件。这样就能将C和汇编混合编译。在汇编中能够直接使用C函数名作为标签名，链接后会找到C文件中对应的函数。 BIOS提供的功能和作用？ 它会被加载到内存中吗？会被加载到内容中，计算机加电以后会将BIOS的内容加载到内存中。CPU调转到内存中BOIS开始的位置执行。 操作系统对硬件的控制和访问与BIOS有关吗？还是BIOS仅用于系统初始化阶段？有关，BIOS是一系列程序的集合，系统初始化的BIOS程序只是其中一个，对于不同的硬件，都有与其对应的BIOS程序。这里还是不太懂 操作系统如何提供对硬件的保护？ 是通过分段机制对特定指令的保护吗？是的，IO地址的访问也有优先级，称为IOPL，只有当前代码的优先级高于IO地址优先级时（CPL&lt;=IOPL）才能访问。 如何避免应用层程序直接访问硬件？应用层程序运行在特权级为3的情况下，IOPL一般是0，只有内核能访问。通过分段的优先级控制就能够防止应用层程序访问硬件。 ELF格式的细节？ elf文件结构？如何解析？ elf内各段（segment）各节（section）的区别和联系？segment是将多个section放在相同的段中，便于内存管理。section是指.data、.text、.bss等不同的程序节。 如何编写自己的bootloader程序？ 相关指令、相关IO端口的作用？ intel 80386指令、AT&amp;T语法汇编知识？ 实模式到保护模式的切换实现？ 操作系统的加载实现？ 如何初始化中断、键盘、显示器等等设备？ 总线如何处理？ IO端口如何处理？ 中断如何处理？ 在i386模拟上实现并总结其原理。 分段模式如何识别不同的段？ 如何识别段栈段和数据段，指令一条指令，怎么判断指令中的寻址使用的是哪一个段选择符？在访问内存的时候才涉及到段选择器的问题。intel 80386有默认的使用段寄存器的方式（在intel 80386参考文档的2.5节），当只指定的偏移，没有指定段寄存器的时候，按照下面的规则使用段寄存器： 指令预获取、指令调转等等指令，使用CS 使用ESP、EBP作为基址寄存器访问内存的时候，使用SS 栈操作命令push、pop等，使用SS 字符串指令，使用ES 不在上面情况中的，使用DS 不同的段是不是有不同多地址空间？是的，一个段就是一个独立的地址空间。GDTR存储了GDT的基址，段寄存器*8+GDTR就是选择符的地址，选择符中有段的基址和偏移。段的基址是线形地址，就是说，这个基址不需要在经过分段基址的转换，直接由基址+偏移得到线形地址。 段和编译器得到的.text和.data等是不是有什么关系？是等价的，不过.text和.data肯定分别放在CS和DS中，但是DS中不仅仅有.data。 如何实现不同的进程之间的内存隔离？ 分段基址的物理空间重叠怎么处理？ milestone 2019.11.04 开始进行ucore-os的开发和学习 2019.11.21 完成对C语言基础知识的复习，也学习了更多的计算机基础相关的知识，例如字节对齐、大端小端、字节序、字符编码等知识。 未完成1：C语言高级语法总结、GCC扩展（内联汇编等等特性） 未完成2：标准库的使用，包括文件io、并发编程、内存分配等等 2019.11.26 完成对Makefile的分析 了解了make的基本语法，ld、gcc选项。 了解了ucore.img镜像的构建过程。主要学习make语法、如何编写makefile、以及gcc、ld编译的一些选项等。 了解了bootloader的结构","link":"/2019/06/24/os/ucore_os/ucore-os%E6%80%9D%E8%80%83%E4%B8%8E%E6%80%BB%E7%BB%93/"},{"title":"ucore-os笔记4：qemu和gdb调试","text":"本篇笔记我们学习qemu和gdb调试，这是调试操作系统内核代码必备的技能。 qemu是通用开源的硬件模拟器，可以模拟完整计算机系统，包括多种CPU架构（x86、x86_61、MIPS、ARM等）、系统总线（PCI、ISA桥等）、VGA显示、PS/2键鼠、PCI和ISA网络适配器、串行端口、USB。这里我们不详细讨论所有的相关知识，只学习我们目前使用到的这一部分。 gdb是gnu调试工具，可以调试编译后的程序。我们在编译操作系统时，要使用GCC的-g选项生成调试信息才能使用gdb调试。gdb提供了单步调试，指令单步调试，调用栈显示等等功能。 qemu基础知识通过qemu命令就可以启动qemu模拟器，通过qemu命令的参数可以指令模拟的硬件的参数，例如指定硬盘、串行端口、CPU核心数等等。一个基础示例如下：1qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;该命令会启动一个PC系统模拟器，并指定了其并行端口、串行端口、和硬盘镜像。模拟器会模拟一台计算机的启动过程，从硬盘镜像中加载BIOS和bootloader，然后将控制权交给bootloader。 部分命令行参数说明： -no-reboot：退出不重启 -parallel stdio：将模拟器的并行端口重定向为stdio。stdio是unix系统下的标准输入输出，标准输入一般指键盘输入，标准输出和程序执行的进程相关，从shell启动的程序输出到控制台 -hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像。模拟PC启动的时候会从该镜像加载bootloader和操作系统 -serial null：将模拟器的串行端口重新向为null -monitor stdio：将显示器重定向到stdio -S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作 -s：-gdb::1234的缩写，等待连接到端口1234。通过-s选项启动远程调试功能，gdb连接到1234端口就可以实现gdb调试qemu中执行的操作系统。 gdb基础知识gdb是gnu调试器，通过gdb可以调试gcc通过-g选项生成的可执行文件。 gdb的使用很简单，在命令行输入gdb即可进入gdb命令行。-q表示不输出copyright信息。12[bright@localhost ~]$ gdb -q(gdb)在gdb命令行中输入help，可查看可使用的gdb命令：12345678910111213141516171819202122(gdb) helpList of classes of commands:aliases -- Aliases of other commandsbreakpoints -- Making program stop at certain pointsdata -- Examining datafiles -- Specifying and examining filesinternals -- Maintenance commandsobscure -- Obscure featuresrunning -- Running the programstack -- Examining the stackstatus -- Status inquiriessupport -- Support facilitiestracepoints -- Tracing of program execution without stopping the programuser-defined -- User-defined commandsType \"help\" followed by a class name for a list of commands in that class.Type \"help all\" for the list of all commands.Type \"help\" followed by command name for full documentation.Type \"apropos word\" to search for commands related to \"word\".Command name abbreviations are allowed if unambiguous.(gdb)我们看到通过gdb可以设置断点、查看数据、指定文件、查看堆栈、调试源程序等等。当我们要使用某一个功能时，可以通过help来查看，例如我想看调试相关的命令，输入help running，就会有很多调试相关的命令。要锻炼自己看工具说明文档的能力，授人以鱼不如授人以渔。 下面是一些常用命令的总结： run：启动调试程序 break breakpoint：打断点，breakpoint可以是地址或者符号名或者文件名加行号 continue：执行到下一个断点 next：执行下一条语句，调过函数。这个是C代码级的调试，调试汇编的使用需要使用nexti或者stepi。（例如调试bootloader的时候就要用nexti或者stepi） nexti：执行下一条指令 step：执行下一条语句，进入函数。 stepi file filename：加载filename文件中的调试信息。这一个指令在执行远程调试的时候必须有，因为远程调试不会加载调试的符号表，需要手动加载。 target remote address：远程调试address，利用这个功能来调试qemu中的操作系统。 qemu和gdb实现操作系统源码级调试实现源码级调试我们要用到上面提供的两个功能，一个是开启qemu的远程调试端口，另一个是用gdb远程连接qemu的调试端口。 所以我们要做的是，在启动qemu的时候通过-s选项启动:1234端口，通过-S暂停执行（等待gdb连接后在继续执行）:1qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp; 然后在gdb中加载符号表、远程连接、设置断点等：1234file bin/kerneltarget remote :1234break *0x7c00continue 接下来我们在gdb中就可以输入调试命令来调试操作系统内核了。有下面两点要注意： 如果是调试bootloader，可以切换到8086调试实模式代码：set arch i8086 调试汇编代码要使用stepi或者nexti","link":"/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B03%EF%BC%9Aqemu%E5%92%8Cgdb%E8%B0%83%E8%AF%95/"},{"title":"ucore-os笔记2：GNU make","text":"c/c++程序基本都是使用GNU make来构建的，其基础是位于根目录的Makefiles文件。 GNU make有什么用呢？我们使用gcc编译器的时候，gcc -o target source，将源文件编译成目标文件，那么如果我们有很多的c/c++文件呢？使用gcc命令就不太合适了。makefiles就是帮我们做这个事情的，它会管理我们要编译的内容，我们指定构建的依赖和构建目标，然后编写对应的构建脚本，完成之后只需要一个make命令，就可以完成构建。make会判断源文件是否被更新过，如果源文件被更新了，那么被更新的那部分会被重新编译。 GNU Make的官方文档，阅读步骤：阅读每一章的前几个章节，因为前几个章节是介绍性的内容。等到具体到细节的时候，再阅读后面的内容。 概览这一部分说明make的使用、makefiles的基本构成、规则、编译脚本、变量等等，先对整体有一个印象，然后我们在后面再深入一些细节。 make的使用如果我们在某一个目录下使用make命令，那么会自动区查找该目录下的makefiles或Makefils文件，并执行makefiles文件中的第一个规则（可以通过.MAKEFILE_GOAL变量来修改，后面会说明）。 makefiles的基本构成先看一个示例：12345edit: test.c cc -o edit test.c.PHONY:cleanclean: rm -r -f ./bin/ makefile由三个部分组成: target、prerequisites、recipes，对应到上面的实例中就是，edit是target，test.c是prerequisites、下面的脚本是recipes（每一条语句占一行，前面必须有一个tab）。target可以只是命令，而不生成某个输出文件，比如上面的clean。 12target: prerequisites ... 除此之外，makefiles文件由五个元素组成：显式规则、隐式规则、变量定义、指令（例如include）和注释。 显示规则说明了如何重新编译一个或者更多的文件，就是target。 隐式规则说明了合适根据文件的名字来重新构建一类文件。例如target是main.o，那么会自动寻找和编译main.c 变量是将文件赋值给一个变量的一行，稍后使用变量的地方会用该文本代替（类似C中的宏替换）。 指令是在makefiles被解析时告诉make去做一些特殊的事情，包括： 读取其他makefiles 决定是否使用或者忽略makefiles的一部分（makefiles的条件指令，类似C的预编译条件指令） 从多行字符串定义一个变量 ‘#’开头一行，’#’所在行后面的部分都是注释，注意： 没有被转义的’\\’会将注释延续到下一行；这样一个’#’可以实现多行注释 如果要使用符号’#’使用，\\# 变量和函数调用中不能使用注释，注释会当做纯文本传给变量和函数 recipe中的注释会传给shell include可以导入其他的文件，这个过程时阻塞的，导入其他文件的过程会暂停当前makefiles的解析。 make的运行规则当prerequistes被更新时，target会被重新编译。prerequisite有可能也是其他rule的输出，这时候会先更新prerequisites再更新target。make会检测到target所依赖的文件的文件，执行必要的重新编译（未改变的那些不重新编译），在make内部会根据prerequisites来生成依赖图，依据依赖图来决定哪些部分需要重新编译。例如： 123456789101112131415161718192021222324edit : main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o cc -o edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.omain.o : main.c defs.h cc -c main.ckbd.o : kbd.c defs.h command.h cc -c kbd.ccommand.o : command.c defs.h command.h cc -c command.cdisplay.o : display.c defs.h buffer.h cc -c display.cinsert.o : insert.c defs.h buffer.h cc -c insert.csearch.o : search.c defs.h buffer.h cc -c search.cfiles.o : files.c defs.h buffer.h command.h cc -c files.cutils.o : utils.c defs.h cc -c utils.cclean : rm edit main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o edit依赖于.o文件，每一个.o文件又依赖于对应的.c和.h文件，当执行make的时候，会根据.c文件判断那些.o文件是要重新生成的并重新生成.o文件，然后再生成edit可执行文件。 不是第一条rule或者goal指定的rule所依赖的rule时，该rule不会被执行，例如clean，只能显式使用make clean。 定义变量12objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.o 上面的格式就可以定义变量，可以使用=(递归查找变量的值，意味着可以多层引用变量)，:=(最多只查找一层的变量值，多于的直接当文本处理)，还有其他的定义方式，见变量。 make推断规则make有一个隐式的规则：.o文件会自动去找其名字对应的.c文件执行cc命令。也就是说我们可以仅指定.o文件的依赖，不用每条都写对应的cc语句，在prerequisies中也可以不写.c文件，如下： 123456789101112131415161718objects = main.o kbd.o command.o display.o \\ insert.o search.o files.o utils.oedit : $(objects) cc -o edit $(objects)main.o : defs.hkbd.o : defs.h command.hcommand.o : defs.h command.hdisplay.o : defs.h buffer.hinsert.o : defs.h buffer.hsearch.o : defs.h buffer.hfiles.o : defs.h buffer.h command.hutils.o : defs.h.PHONY : cleanclean : rm edit $(objects) 小结上面是对makefiles的一个小的概括，关键包括下面几点： makefiles是做什么用的？答：makefiles用于自动构建，通过构建目标: 构建依赖\\n 构建命令这样的格式来自动构建程序。makefiles会根据我们编写的构建规则来处理构建关系，最后生成构建目标。不仅仅使用于c、c++语言，也适用于其他语言甚至文档。总之，makefiles是一个管理依赖关系的自动构建工具。 makefiles的构建过程？答：输入make之后，会找到第一个规则（如果是make target，则找到target对应的规则），先构建prequistes，例如上例的main.o，先去构建target为main.o的依赖。所有prequistes构建完成后，执行后面的脚本。相当于makefiles先根据我们编写的规则构建依赖树，然后自底向上执行规则的脚本，同时会检测更新确定是否要执行脚本。 编译脚本recipes会被shell执行所以recipes用shell语法来编写。make不理解shell语法，它仅仅只做一点点简单的处理，然后将其将给shell执行。 make中的recipes规则： 以tab开头的空行不是空的，是一条空的recipes 在recipes中的comment不是make的comment，它会被传给shell 在rule中定义，以tab开头的变量不是make变量，它会被传给shell 编写makefiles上面提到了makefiles包含五个部分，显式规则、隐式规则、变量、指令、注释。接下来会逐步介绍细节。 多行语法makefiles使用了一种多行语法，每一个换行符都表示一条语句的结束。通过\\可以将单行的内容分布在多行中，非recipe脚本中的\\和其前后的空格都会被合并成单个空格。 指定了.POSIX的target的\\不会被压缩。 Makefile文件的名字按照GNUmakefile、makefiles、Makefile的顺序查找。 如果make没有找到上述文件的任何一个，则会启用内置的隐式规则来决定如何构建。 通过make的-f或者–file选项可以指定自己的makefile文件。可以多次使用-f选项，指定的文件按顺序拼接。使用-f会忽略默认的makefile文件。 包括其他makefile文件include会暂停当前文件的读取转而读取和解析指定的文件，完成后继续本文件。1include filename 例如：1include *.mk $(bar)等价于（假定当前文件夹下有a.mk,b.mk,c.mk。bar的值是bish bash1include a.mk b.mk c.mk bish bash 如果指定的文件路径下没找到，会去–include-dir选项指定的文件夹下找，以及/usr/local/include、usr/gnu/include、/usr/include 注意：环境变量MAKEFILES用于在文件其他部分解析之前include 变量MAKEFILES指定的一系列文件。类似于include，建议显式使用include而不是MAKEFILES变量。 没看懂的两节How makefiles are remade以及Overriding part of another makefile. 主要是不懂这个部分讲了什么功能，这些功能如何使用以及用于什么场景。 make如何处理MakefileGNU make经过两个阶段处理Makefile。第一阶段读取所有makefile，包括included的makefile。内化所有的变量和其值，以及显式和隐式规则，并且构建target和其prerequisites之间的依赖图。 第二阶段利用第一阶段构建的内部结构，决定哪些target需要构建，并且执行其脚本。 理解两阶段构建很重要，因为这涉及到变量和函数何时扩展。先说明基本概念，扩展指变量和函数被替换为相应的值；immediate指第一阶段扩展；deffered指第二阶段扩展。 变量赋值变量赋值的解析规则如下，注意前面提到的immediate和deffered的概念。 123456immediate = defferedimmediate ?= defferedimmediate := immediateimmediate ::= immediateimmediate += immediate or defferedimmediate != immediate 条件指令条件指令是immediate parsed的，在第一阶段就处理了。这意味着，自动化变量不能用于条件指令（因为自动化变量直到rule的recipe调用时才设置）。如果需要使用自动化变量，需要在recipe中使用shell语法的条件指令。 规则定义规则定义始终按照如下以下方式处理：12immediate: immediate; deffered deffered target和prerequisites始终时immediate的，而recipe始终时deffered的。 二次扩展对于prerequisites，GNU提供了额外的能力，叫做二次扩展。必须在第一个prerequisites前使用.SECONDEXPANSION来启用这个能力。 注意：二次扩展仅适用于prerequisites。 怎么用呢？通过两个$，来实现在正常扩展后的二次扩展，例如：1234.SECONDEXPANSIONONEVAR = onefileTWOVAR = twofilemyfile: $(ONEVAR) $$(TWOVAR)在第一次扩展以后myfile是myfile: onefile $(TWOVAR)，在二次扩展后，才会变成myfile: onefile twofile。 这里还有其他内容，和自动化变量，显示规则、隐式规则相关，先阅读后面，回来再继续补充。 编写Rulerule的顺序不太重要，除了默认的rule——第一个rule。没有指定target的时候，默认找第一个rule。 Rule示例12foo.o : foo.c defs.h # module for twiddling the frobs cc -c -g foo.c 构建target是foo.o，前置要求是foo.c 和defs.h。说明了两个事情： 如何决定foo.o是否过期：foo.o不存在或者foo.c 和defs.h更新 如何更新foo.o：执行脚本中的cc命令 Rule 语法12345678targets : prerequisites recipe …# or like this:targets : prerequisites ; recipe recipe … 要点： targets可以是多个 targets是文件名，可以使用通配符。变量赋值的通配符需要使用通配符函数 recipe是tab开头的行（或者.PRECIPEPREFIX环境变量指定的） $用于变量，如果要使用$符号，使用$$。recipe决定如何更新target，它被传递给shell执行 一个target，多个规则同一个target可以有多个规则，这些规则会合并成一个规则。这些规则的所有rerequisites会合并成同一个规则。 但是一个target只能有一个recipe。如果一个target有多个recipe，make会使用最后一个，并给出警告。 使用::可以让一个target拥有多个recipe。target重新构建的时候，每一个recipe都会被独立的执行。 在Rules中编写RecipesRecipes包含一条或者多条shell命令，按照出现的次序依次执行。 Recipe语法 tab开头，或者.RECIPEPREFIX变量指定的符号开头，第一条语句可以接在prerequisites后面 recipe中的comment不是make的comment，会传给shell rule上下文中的变量定义，如果以tab开头，当作shell的变量 条件表达式会传给shell Recipe中使用变量recipe中的变量在结束读取makefiles，确定targets过时了之后才会被扩展。 recipe中的变量和函数和makefiles中其他位置有相同的语法和语义，使用上没有区别。 Recipe的执行更新target时执行recipes，这些recipe将会在一个新的子shell中执行，除非指定了.ONESHELL。 如何使用变量一个变量类似于C语言中的宏替换，其值是一个文本。这些值被替换到targets，prerequisites，recipes以及makefile的其他位置。（变量也叫宏）。 变量名大小写敏感。 变量引用基础使用$(var)或者${var}来使用变量。var是变量名。变量可用于targets、prerequisites、recipes、大多数指令以及新的变量。变量被扩展的时候用其值替换。1234objects = program.o foo.o utils.oprogram : $(objects) cc -o program $(objects)$(objects) : defs.h 两种类型的变量一种是使用=，表示递归扩展的变量；意思就是，如果扩展后的值还是一个变量，那么会继续对改变量进行扩展。递归扩展在每次扩展时都会对函数进行求值。 另一种是:=，表示简单扩展变量；意思就是，只会扩展一次，值就是扩展后的文本，即便该文本可能是一个变量的扩展（$(two)这种形式）。 还有一种?=，表示条件赋值；意思就是，只有变量没有定义的时候才会定义变量并赋值：1FOO ?= bar相当于：123ifeq ($(origin FOO), undefined) FOO = bar #注意是=，而不是:=endif 注意：变量赋值时会忽略前置的空格，但是后置的空格不会。当涉及到目录的时候，容易出错。例如BINDIR = bin # bin dir，后置空格不会被去除，那么$(BINDIR)/file就会变成bin /file，如果作为命令行参数，bin/file是一个选项，而bin /file就变成两个选项了。 变量的+=分成两种情况，如果变量已经定义，那么a += b等价于a := $(a) b。 如果变量没有定义，a += b等价于a = b 多行变量define是另一种定义变量的方式（还有=、:=等等）。语法：1234define vari-name[=|+=|:=]foo$(bar)endef等于符号可以省略，省略默认使用=。define可以定义多行变量。多行内容的中的变量和函数会正确扩展。里面的make指令也会被正确解析。 makefile中的条件片段示例：123456789libs_for_gcc = -lgnunormal_libs = foo: $(objects)ifeq ($(CC), gcc) $(CC) -o foo $(objects) $(libs_for_gcc)else $(CC) -o foo $(objects) $(normal_libs)endif 条件指令的语法12345ifeq(arg1, arg2) ...else ...endif 一共有下面这些条件指令： ifeq(arg1, arg2)或者`ifeq “arg1” “arg2” ifdef varname ifndef varname 处理文本的函数函数用于处理文本。使用一个函数称为函数调用。通过给函数传一些参数，能够得到函数的返回值。 函数调用语法123$(function arguments)# 或者${function arguments} 通过内置的call函数可以定义自己的函数。 shell函数shell函数将参数传给shell命令并且对命令的输出求值。make对参数的处理仅仅是将\\替换成空格。 shell函数被扩展的时候执行命令。取决于shell函数的位置，如果在recipe中，则是第二阶段，也就是recipe执行的时候扩展。 示例：1files = $(shell echo *.c) 用于文本替换和分析的函数 $(filter pattern…,text)返回text中匹配模式字符串的空格隔开的单词，移除不匹配的单词。可以使用%作为通配符。 示例： 123source := foo.c bar.c baz.s ugh.hfoo: $(source) cc $(filter %.c %.s, $(source)) -o foo $(filter %.c %.s, $(source))会把source中满足%.c或者%.s的单词取出来。 $(patsubst pattern,replacement,text)找到text中使用空格分开的满足pattern的单词，并用replacement替换他们。可能含有%作为通配符，表示匹配单词中的任意多个字符。如果replacement中出现了%，那么%会使用text中匹配的字符串替换。 1$(patsubst %.c,%.o,foo.c bar.c) patsubst还有缩写形式： 1$(var.pattern=replacement) 等价于： 1$(patsubst pattern,replacement,$(var)) $(sort list)以字符顺序排序list中的单词，移除重复单词。输出是空格隔开的单词序列。例如： 1$(sort foo bar lose) 的结果为：bar foo lose 条件处理的函数有三种提供条件扩展的函数。函数的参数不会在初始化的时候扩展，而只会在需要扩展的时候扩展。 $(if condition,then-part[,else-part])condition的前后空格都会被去掉，然后扩展。如果扩展后的结果是非空字符串，认为是true，如果是空字符串，认为是false。 如果condition为true，那么then-part会被扩展，并将其值作为if函数的值。 如果condition为false，那么else-part会被扩展，并将其值作为if函数的值，如果没有else-part，返回空字符串。 用于文件名的函数 $(addprefix prefix,name…)name是一系列文件名，用空格分割。会将prefix添加到name中的每一个文件名的前面，结果是添加后的空格隔开的字符串。 $(wildcard pattern…)pattern是一个文件名pattern，一般包含通配符。wildcard函数的结果是空格隔开的一系列匹配pattern的文件名。pattern可以是空格隔开的多个规则。 $(basename names…)取出空格隔开的文件名中的除了去掉的值。 $(dir names…)提取names中每一个name的文件夹部分，包括最后的/。当前目录返回./。结果用空格隔开。 origin函数origin函数说明变量的来源。语法：1$(origin variable)注意这里的variable是变量的名字，不带$。 origin函数可能返回的值： undefined：变量未定义 default：内置的变量 environment：从环境中继承并提供给make的变量 environment override：从环境中继承，但是使用-e选项改写了 file：makefile中定义 command line：命令行中定义 automatic：自动 call函数call函数可以用于创建新的函数，可以定义一个变量，通过call给该变量传参数将该变量扩展成不同的值。 语法：1$(call variable,param,param,...)$(1)，$(2)…用于获取param的值。$(0)是variable。没有最大参数个数也没有最小参数个数。但是参数为0call函数就没有作用了，和普通变量没有区别。variable是变量的名字，没有开头的$，可以但是可以使用变量来扩展成其他变量的名字。 参数在赋值给临时变量前求值。 eval函数eval函数通过变量的方式创建新的makefile结构。意思就是，通过eval可以将一个动态的字符串（可以是变量或者函数的值）作为makefile来解析。eval函数的参数会被扩展，扩展的结果用makefile语法解析。扩展的结果中可以定义make变量、target、显式和隐式的规则。 语法：1$(eval argument)eval函数的返回值始终是一个空字符串。 例如：1$(foreach prog,$(PROGRAMS),$(eval $(call PROGRAM_template,$(prog)))) 要注意到eval参数会被扩展两次，第一次作为参数扩展一次。第二次作为make的语法扩展一次。 foreach函数语法：1$(foreach var,list,text)第一个参数和第二个参数将在最开始扩展。var扩展后的值是临时变量的名字。list扩展后是一个空格隔开的列表。foreach会遍历list，将其值赋给名字为var扩展后的值的变量。text会在每次遍历的时候扩展，text中一般会引用var。 foreach函数的值是text扩展后通过空格隔开的列表。 9.如何运行make一个makefile说明了如何重新编译一个程序。最简单的方式就是重新编译每一个过时的文件。当不带参数执行make的时候是这样的。 但是你也许想只编译一部分文件。可能对于不用的编译器使用不同的编译器选项。通过给make传递特定的选项可以做到这些。 构建目标我们前面提到了对于makefiles中的rule，默认使用第一条rule，但是我们也可以通过环境变量或者make选项来设置默认的rule。例如通过.DEFAULT_GOAL变量可以设置默认的rule。 10.使用隐式规则隐式规则告诉编译器如果使用常用的技术，可以让你需要使用这些技术的时候不用详细的指定它们。例如将C文件编译成.o文件是一种make常用的场景，make会有相应的隐式规则来将C文件编译成.o文件，例如使用cc命令等等。通过内置的环境变量我们可以控制隐式规则如何工作，比如使用CFLAGS变量改变传给C编译器的flags。 隐式规则使用的变量通过内置的一些变量可以设置隐式规则。例如设置编译器选项等等。通过makefile中给变量赋值以及make命令参数可以改变这些变量。 隐式规则使用的变量分成两类：程序的名字（例如CC）以及程序的参数（例如CFLAGS）。 编译C语言程序主要就使用下面几个： CC，编译器命令名 CFLAGS，编译器选项 LDFLAG，链接连接器选项 LDLIBS，链接器链接的库 如何使用？看一个示例：12foo: foo.o bar.o cc -o foo.o bar.o $(CFLAGS) $(LDFLAGS)这里使用中我们并写没有foo.o的rule，但是make会使用隐式规则自动编译得到foo.o。 make的隐式规则会根据源文件的类型自动选择合适的规则进行处理。 如果不想为一个没有recipe的target使用隐式规则，在recipe中使用;。 定义和重定义模式规则模式规则就是在target中有%的规则。一个模式规则可能长这样：1%.o:%.c; recipe... 自动变量如果我们要应用模式规则中的文件名怎么办呢？通过自动变量。例如通过$@来使用target文件名，通过@&lt;来使用源文件名。 可用的自动变量如下： $@：target文件名。如果是一个模式匹配的target，那么是触发rule的那一个target $%：target成员名，当target是一个archive成员的时候 %&lt;：第一个prequisites的名字。如果target从隐式规则获取recipe，那么是隐式规则添加的第一个prerequisites $?：所有比target新的prerequisites的名字，用空格分开。 $^：所有prerequisites的名字，空格隔开 $|：order-only的prerequisites，空格分开 … 参考资料GNU make 文档","link":"/2019/06/16/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B02%EF%BC%9AGNU-make/"},{"title":"ucore-os学习前言","text":"大四了，复习大学四年所学过的专业基础知识。操作系统是复习的第一门课，希望通过操作系统的学习，深入掌握计算机底层的工作原理、串联其他课程（计算机组成原理、计算机接口技术）、学习linux下C/C++的开发，希望能够将整个大学学的大部分知识串联起来。深入了解底层硬件的工作机制以及操作系统的原理和实现。（先不关注IO设备的访问这些，实验代码中都有，等完成所有操作系统实验后有时间再深入这部分细节） 这一系列笔记主要记录了ucore-os操作系统开发和学习的笔记。ucore-os是北大操作系统课程用的实验系统，基于MIT6.828，之前操作系统课程用的就是6.828，这次换成ucore-os，靠自己完整理解并实现操作系统的核心功能。 跟随本笔记的学习的过程是：直接从实验开始，从实验1开始，实验1的笔记中会有该次实验所需要的基础知识链接，先阅读基础知识，然后开始独立完成练习，独立完成后再与笔记中的练习解析对照。基础知识可以先粗略的过一遍，之后遇到的时候不懂再回过来看。实验最难的部分是实验1和实验2，因为实验1和实验2涉及到大量的硬件知识、编译工具知识，花的时间也最多，但是独立完成实验1实验2并掌握相关的知识后，后面的实验结合操作系统原理知识将一马平川。万事开头难，贵在坚持！ 参考资料下载： ucore-os-labdoc：ucore-os开发的文档，有练习的要求和一些基础知识，需要结合该文档才能完成完整的实验 80386 refenrence manual：ucore-os基于i386架构开发，所以一定要知道一些cpu硬件相关的知识，如果对于中断、分段、分页、IO、任务切换、保护等硬件机制方面有不理解，虽然笔记和ucore-os文档中有一些介绍，但是可能有不全或者让你不理解的地方，所以不明白的时候一定要看这个手册！！！贵在坚持！ 现代操作系统：操作系统原理教材 笔记会完整记录： ucore-os开发所需的基础知识，包括基础的硬件知识（段页机制等） 相关开发工具的使用（GCC、make、GDB、qemu、ld等）； ucore-os的8个实验每一个练习的解析，包括相关原理和代码解析； ucore-os开发中相关的操作系统原理知识，例如进程调度算法的实现等； elf文件格式、链接原理等相关知识； 这系列笔记的最终目标是帮助能够希望学习和实现操作系统的同学无障碍的完成完整操作系统功能的开发。所以这一系列笔记会有大量的相关前置知识的学习，例如相关硬件知识（段页相关的硬件原理、IO设备访问等等）、软件知识（make工具、elf文件格式、链接器），希望能够解决没有基础的同学开发中的大量疑问。当然这些都是我自己的看的一些书和资料的总结，完全没基础也不行，只是希望能够尽量帮助自己了解相关知识。 我觉得在进行操作系统开发之前需要掌握的基础知识： C语言：C语言语法，尤其是对各种指针（数组指针、指针数组、函数指针）了解。还有结构体的内存分配、字节对齐等。可以参考我的C语言学习笔记 汇编语言：32位x86汇编，AT&amp;T语法 英语能力：intel 80386、gcc、make等的文档都是英文的，能够较为流畅的看这些文档。一些博客上有中文的使用教程，但是没有源文档那么详细，建议直接看源文档。 其他的相关知识我的笔记里都有。在每一个实验的开头都会给出参考学习资料，里面有前置知识和相关的os原理。 希望通过这一系列的学习，将大学所学的知识融会贯通。","link":"/2019/12/02/os/ucore_os/ucore-os%E5%AD%A6%E4%B9%A0%E5%89%8D%E8%A8%80/"},{"title":"ucore-os笔记5：实模式与保护模式","text":"这一次笔记学习X86的实模式和保护模式，主要内容是实模式和保护模式的介绍，相关硬件机制的介绍（GDTR寄存器，GDT等），保护模式在内核中的作用，以及如何从实模式切换到保护模式。 实模式与保护模式接下来开始实模式与保护模式的学习。在intel 80386以前的CPU，例如8086，使用的都是实模式。实模式下，CPU没有提供保护机制，可以寻址到任意的内存空间，通过segment:offset的形式可以访问任意的物理空间（segment*16+offset=物理空间地址）。而保护模式在CPU层面提供了对内存空间的保护。保护模式通过分段机制来实现对内存的保护，这个分段机制和8086等实模式CPU下的segment不同，实模式下的segment仅仅只是将内存分片，而保护模式下的分段机制，不仅仅将内存分段，并且CPU对各段内存的访问进行权限的检查，实现内存访问的保护。 保护模式为地址空间提供了抽象，实模式直接访问物理空间，那意味者所有的程序都可以访问所有的物理空间，一个程序可以篡改其他程序的数据，这就存在巨大的安全问题；而且直接访问物理内存，程序的并发运行也存在困难，如何确定多个程序的运行地址？如何进行内存的分配和回收？ 所以CPU对物理内存空间进行了抽象：所有的进程拥有独立的内存空间，并且对进程的内存空间提供保护。CPU通过重定向来实现分离不同的内存空间，对于应用程序而言，其使用的地址会进行CPU的重定向来映射到真实的物理地址。CPU利用段寄存器GDTR和GDT来实现重定向的功能，程序员看到的地址到达CPU后，会经过GDTR和GDT的重定向，生成另一个地址；同时CPU也会检查GDT中描述符的保护位和当前保护位，来确定当前程序是否有权限访问指定的内存，而且会判断段基地址和段界限，确定访问的内存是否在该段内。由此实现了不同进程的内存之间的隔离、内存权限访问的分级。 CPU中进行内存管理的硬件称为MMU（Memory Management Unit），程序员设置的地址会经过MMU的转化后才会变成真实的物理地址送达地址总线。MMU提供了分段和分页机制来实现内存隔离、内存保护、虚拟内存等等功能。详情请看内存管理基础：分段和分页机制 实模式BIOS将bootloader加载进内存以后，在实模式下执行，实模式下CPU运行在16位模式，最大访问1MB的内存。内存地址访问地址真实物理地址，不提供任何抽象和保护机制。通过开启A20，设置CRO寄存器中的使能位，可以切换到保护模式，请看bios和bootloader的加载过程。 保护模式保护模式下能够访问所有的物理内存，同时对物理内存进行隔离和保护。通过CPU硬件检查特权位来实现保护，通过分段来进行地址空间的抽象和进程隔离。通过分页可以实现虚拟内存，允许地址空间比实际的物理空间大，通过在内存和磁盘之间进行交换实现。 保护模式下涉及到分段和分页两种机制，这两种机制对应的原理和相关的硬件介绍在内存管理基础：分段和分页机制中学习。 在保护模式下，地址经历的转化过程是：逻辑地址-&gt;分段机制-&gt;线形地址-&gt;分页机制-&gt;物理地址。","link":"/2019/12/02/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B05%EF%BC%9A%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/"},{"title":"ucore_os笔记1：GCC基础和linux命令","text":"GCC的基本用法参考这篇博客gcc基础命令 GCC内联汇编利用gcc提供的内联汇编的特性，我们可以在C语言程序中写汇编代码。gcc内联汇编有两种方式，一种是基本内联汇编语句，另一种是扩展内联汇编语句。 基本内联汇编语句例子：12345// 基本内联汇编语句，这种方式直接将汇编代码，输出到生成的汇编文件中，可能会影响其他代码 asm(\".code32\\n\\t\" \"pushl %eax\\n\\t\" // C语言中相邻的同类型字符串可以拼接 \"movl $0, %eax\\n\\t\" \"popl %eax\");在asm（或者asm，二者含义相同）中直接写汇编代码。 不同的汇编指令之间需要加换行符或者分号。 扩展内联汇编语句例子：1234567#define read_cr0() ({ \\ unsigned int __dummy; \\ __asm__( \\ \"movl %%cr0,%0\\n\\t\" \\ :\"=r\" (__dummy)); \\ __dummy; \\})GCC扩展内联汇编的基本格式是：1234567__asm__ [__volatile__] ( Assembler Template // 汇编模板 : Output Operands // 输出操作数 [ : Input Operands // 输入操作数 [ : Clobbers ] ]) volatile含义是避免asm指令被删除、移动或者组合，如果不希望被gcc优化而改变位置，需要添加volatile关键词。还可以是inline，表示最小化asm代码 接下来的是汇编模板，汇编模板就是添加了占位符的汇编语句，例如movl %%ebp,%0，%0,%1等表示的是汇编模板中的模板变量，通过模板变量可实现汇编语言和C语言的交互。可用的变量数取决于cpu中通用寄存器的个数。汇编变量映射先输出后输入，例%0、%1…是输出操作数部分的变量，后面才是输入操作数部分的变量。 输出操作数部分规定变量如何与寄存器向结合，例如在上例中：”=r”表示%0可以使用任何一个通用寄存器，并且dummy存放在这个寄存器中，但是如果是：:”=m”(dummy)，表示操作数存放在内存单元dummy中。 输入部分和输出部分类似，但是没有“=” gcc内联汇编的详细知识可以参考我的另一篇博客gcc内联汇编 diff &amp; patchdiff为linux命令，用于比较文本或文件夹差异；patch命令可以对文件或者文件夹应用修改。 例如是是实验中可能在proj_b中应用前一个实验proj_a中对文件进行的修改，可以使用如下的命令:123diff -r -u -P proj_a_original proj_a_mine &gt; diff.patchcd proj_bpatch -p1 -u &lt; ../diff.patch","link":"/2019/06/12/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B01%EF%BC%9AGCC%E5%9F%BA%E7%A1%80%E5%92%8Clinux%E5%91%BD%E4%BB%A4/"},{"title":"ucore-os笔记7：分段和分页机制","text":"前面我们讨论了x86的保护模式和实模式的区别，最新的处理器架构都运行在保护模式下，但是为了向下兼容都也支持实模式。这里学习的分段和分页机制都是保护模式提供的机制，通过CPU为内存提供了抽象。这篇文章详细学习分段和分页相关原理和相关硬件、软件的知识。 地址空间在讨论分段和分页机制之前，首先要讨论地址空间的概念。在最早的CPU架构中，使用的都是物理地址，所有的程序都能够访问任何一处物理地址，这样在程序保护和隔离以及并发程序的内存分配存在很大的问题。 所以最初的设想就是能够让不同的程序地址隔离，同时能够有访问权限的区分。例如程序a的28地址和程序b的28地址是不一样的，那么就能在逻辑上实现a和b的地址空间上隔离的。但是物理地址只有已有，要让a和b的28地址得到的物理地址不同，最好的方式就是地址重定向，将a和b的28重定向到不同的物理地址。可以用软件来实现，例如在每次内存访问前重新计算地址。但是最好的方式是将这一部分提取出来，所以80386以后的x86架构CPU都内置了重定位功能，称为分段机制。 分段机制由段来实现重定向的功能，采用段+偏移这种形式，偏移是程序员可见的地址，称为逻辑地址（或虚拟地址）。在内存访问前，CPU会自动将段基址加上，分段机制计算之后的地址称为线性地址，计算方式是段基址+偏移=线性地址。 在没有开启分页机制的机器中，线性地址就等于物理地址。 现在实现了地址重定向，但是还有更多的问题没有解决。对于32位cpu，最多能够访问4g的内存，但是有时候物理内存没有4g，一种方式是将一部分内存交换到硬盘中，当需要使用的时候再将这一部分内容交换到RAM中。如何实现高效的交换也是一个问题，分页机制就可以实现这样的功能，分页机制以页位单位来进行内存的分配和交换，提供了对RAM和硬盘的抽象。分页机制会检查需要的数据是在内存中还是在硬盘中，如果再硬盘中会自动将数据交换到内存中。 地址的转化是：逻辑地址-&gt;分段机制-&gt;线性地址-&gt;分页机制-&gt;物理地址 逻辑地址空间、线性地址空间、物理地址空间分别是三个阶段对应的不同的地址空间，前两者都是一种抽象，从真实的物理空间上抽象出来的地址空间，通过一定的匹配将空间中的地址映射成真实的地址。 分段机制分段机制是实现内存抽象和保护的关键，分段机制提供了4个特权级和完整的特权级检查，由此能够实现操作系统内核，关键软件，用户态程序的区分。硬件实现的特权级检查能够有效的保护系统的运行。分段机制的核心是GDTR（全局描述符表寄存器）、GDT（全局描述符表）、LDTR（局部描述符表寄存器）、LDT（局部描述符表）。分段机制与段寄存器（cs、ds、ss等）、GDTR、GDT有关。通过lgdt和sgdt指令能够操作gdtr。lldt和sldt能够操作ldtr。 GDTR是全局描述符表寄存器，存放GDT的起始地址和大小。GDT是全局描述符表，存放在内存中，每一个表项包含一个段的信息，包含段基址、段界限、段属性等。LDTR和LDT类似。 分段机制划分的段和程序编译时的代码、数据、堆栈段是相同的，区别是程序编译的很多段例如bss等会放在CPU的数据段中，不一定完全对应。 x86中有段寄存器cs、ds、ss、es、fs、gs，这些段寄存器用于分段机制，段寄存器中存的是选择符，选择符用于选中GDT中特定的项，项中有段的起始地址和界限等等。转换过程如下： GDTR中存了GDT的基址，段寄存器中存了GDT的索引index，通过GDTR+index*8就得到段描述符的地址，从段描述符中取出基址，基址+偏移地址得到线性地址。 段寄存器/选择符： index：GDT中的段描述符 TI：0表示访问GDT、1表示访问LDT RPL：请求特权级，在特权访问中起作用 对于cs只能通过间接方式来设置，例如jmp、call等指令，其他的段寄存器能够通过mov等指令来设置。 GDT和LDT： 段描述符： 段基地址:规定线性地址空间中段的起始地址。在80386保护模式下,段基地址长32位。因为基地址长度与寻址地址的长度相同,所以任何一个段都可以从32位线性地址空间中的任何一个字节开始,而不象实方式下规定的边界必须被16整除。 段界限:规定段的大小。在80386保护模式下,段界限用20位表示,而且段界限可以是以字节为单位或以4K字节为单位。ucore中使用的是4K，一个段的最大是4G 段属性:确定段的各种性质。 段属性中的粒度位(Granularity),用符号G标记。G=0表示段界限以字节位位单位,20位的界限可表示的范围是1字节至1M字节,增量为1字节;G=1表示段界限以4K字节为单位,于是20位的界限可表示的范围是4K 段属性中的粒度位(Granularity),用符号G标记。G=0表示段界限以字节位位单位,20位的界限可表示的范围是1字节至1M字节,增量为1字节;G=1表示段界限以4K字节为单位,于是20位的界限可表示的范围是4K字节至4G字节,增量为4K字节。 类型(TYPE):用于区别不同类型的描述符。可表示所描述的段是代码段还是数据段,所描述的段是否可读/写/执行,段的扩展方向等。 描述符特权级(Descriptor Privilege Level)(DPL):用来实现保护机制。 段存在位(Segment-Present bit):如果这一位为0,则此描述符为非法的,不能被用来实现地址转换。如果一个非法描述符被加载进一个段寄存器,处理器会立即产生异常。图5-4显示了当存在位为0时,描述符的格式。操作系统可以任意的使用被标识为可用(AVAILABLE)的位。 已访问位(Accessed bit):当处理器访问该段(当一个指向该段描述符的选择子被加载进一个段寄存器)时,将自动设置访问位。操作系统可清除该位。 GDTR是48位寄存器，高32位是GDT/LDT的线性基地址，低16位是段描述符表的大小，以字节为单位。 LDTLDT在ucore lab中没有使用，这里做一个简单介绍。 LDTR和GDTR不同，LDTR是16位的，和cs等段寄存器的功能相同。当启用了LDT之后，即段寄存器中的TI=1，此时GDT对应表项的基址变成了LDT的起始地址，界限变成了LDT的界限，通过GDT中的LDT基址和LDTR来找到LDT中的段选择符。 LDT嵌套的GDT中，每一个任务可以有一个LDT，就可以将单个任务的代码、数据、堆栈封装在同一个LDT下。任务切换时，只需要加载LDTR。 LDT的访问过程当TI=1时表示段选择符在LDT中。 从GDTR寄存器获取GDT基址 从LDTR寄存器高13位索引到GDT中的LDT的选择符 从得到的LDT选择符中得到LDT段基址 然后利用段寄存器中的高13位得到LDT中的段描述符。 从段描述符中读取段基址，基址加上偏移地址得到线性地址。 分页机制分页机制将线性地址转换成物理地址。分页机制提供了基于页的虚拟内存以及页面保护。分页机制是可选的，当且仅当CR0寄存器的PG位设置了以后分页机制才会开启，所以一般在操作系统初始化的时候设置PG位。 页框一个页框是大小位4kb的连续物理地址。 线性地址32位的线性地址在分页机制中分成三个部分，31-22位是DIR，用于索引页目录，21-12位是PAGE，用于索引页表，低12位是偏移，用于索引页框中的线性地址。如下图： 页表页表大小为4KB，页表的每一项的大小是4byte，共有1K页。页目录的大小也为4KB，其中有1K项。所以整个分页机制映射的空间是$2^{10} 2^{10} 2^{12} = 2^{32}$，刚好将4G的线性空间一一映射到每一个页框中的每一项。 页目录的物理地址存在CR3寄存器中。在操作系统初始化时，如果开启分页机制，就要设置CR3寄存器为页目录的物理地址。当MMU处理地址时，会自动使用CR3中的页目录地址来进行分页处理。 页表项页表项的大小为32位，结构如下图： 前20位是页框地址。地址不是32位吗？为什么这里是20位呢？因为页框的大小是4KB，其起始地址肯定4KB对齐，所以低12位都是0，这里就只存了高20位，当用作地址时，CPU会自动将这20位作为地址的高20位而低12位置0。对于页目录而言，这20位就是页表的起始物理地址，对于页表而言，就是页框的起始物理地址。 最低位是P，表示Present Bit，如果该位为0，则表示该页表项不能用作地址翻译，CPU在分页处理时，如果遇到P=0的项，则会出现一个页异常，进入页异常的中断处理程序。该位的设置是实现虚拟内存的关键。 A和D为表示Access和Dirty位。在读写任意页表前，会将对应的页表项的Access位设置成1。在写入页表时会自动设置dirty位为1，页目录中dirty是未定义的。 如上所述，CPU会自动设置对应的位，但是不会自动清除，需要程序来清除，这个工作一般是由操作系统来负责。通过dirty和access位可以用于实现页面调度算法、缓存写回等等策略。 R/W和U/S位用于特权级的处理，后文说明。 cache在操作系统原理中，为了加速页面映射的速度，会使用TLB，TLB有硬件管理和软件管理。80386使用的是硬件管理，即CPU自动缓存最近使用的页面，自动替换缓存。对于操作系统来说，要做的就是清空缓存，通过MOVL %CR3, %EAX设置CR3会清空缓存。或者任务切换的时候重新设置CR3也会清空缓存。 组合分段和分页机制通过分段和分页机制的结合，可以设计多种内存管理策略。根据系统的需求，可以直接访问物理地址，也可以添加虚拟内存，在硬件的能力上，可以做任何自己想要的内存管理设计。这就是机制和策略的区别。 80386不能禁用分段机制，但是可以通过设置相同的段寄存器并且不再改变其值来实现类型禁用的效果。 允许每一个段大于或者小于4KB（一个页面的大小）。对于段大于4KB的时候，段会被分成若干个页面，对于启用了虚拟内存的系统来说，这若干个页面可能在RAM中，也可能在硬盘中。对于段小于4KB的时候，待说明 分段和分页机制组合： 段页对齐说明80386架构并不强制要求段按照4KB对齐，所以可能出现一个页面包含一个段的结束同时也包含另一个段的开始。内存管理软件为了简单，可能会让段的分配按照页对齐，那么这样段页的分配就一致了。 分段和分页中的保护80386提供了内存访问及指令执行的保护，包括下面5个方面的保护： 类型检查 界限检查 可寻址区域的先值 程序入口的限制 指令集的限制 每次内存访问前都会进行保护检查，检查失败时将会触发一个保护异常。特权级时保护的中心概念，上面提到的3、4、5保护都基于特权级。 分段保护上面提到的所有保护都应用于段处理过程中。段描述符中存了RPL，RPL占两个bit，能表示0-3四个特权级。CPU在段描述符被加载到寄存器中，以及每次段寄存器访问时进行检查。 描述表中的每一项中也含有DPL用于特权级的检查。段选择符对应的描述符表项会被加载到CPU中，而不是每次内存访问都去内存中找GDT，不需要担心性能问题。 从上图我们可以看到GDT或者LDT中的描述符分为三种，数据段描述符、可执行段、系统段描述符。三个段结构上的主要区别是type和AVL等四位的区别。type中的有可读、可写、可执行等等属性，描述一个段的特性，这些特性将会在type checking时起作用，因为不可能让不可执行的描述符加载到CS中吧？ 类型检查描述符中的type用于描述一个段的作用以及段的种类，可以用type来区分数据段、代码段等。type中的各位主要是设置可读、可写等等属性。描述符也可以是门描述符，此部分待补充。 只有可写的数据段才能向其中写入数据，例如mov %eax, $123123，如果当前段不是可写的，那么尝试向段中写会触发保护异常 只有可读的可执行段才能读取其中的指令。通过cs寄存器或者将可执行段描述符加载到ds、es、fs、gs寄存器中可读取指令 可执行段只可能读而不可能写，防止了篡改代码指令的可能性。也防止程序员错误加载段导致的错误。CPU在下面两种情形下进行类型检查： 描述符被加载到寄存器中时： CS只能加载可执行段的描述符。同时该段必须可读 只有可写的数据段能够被加载到ss 指令显式或者隐式的引用段寄存器的时候： 可执行段不能写 不可写的数据段不能写 不可读的可执行段不能读 界限检查界限检查防止访问段以外的内存。界限检查的细节和B、G、E等为的设置有关，这里暂时没有看懂详细的细节，后面用到的时候补充。 目前只需要知道界限检查用于防止访问段以外的内存即可 特权级检查一共有4个特权级。段中通过下面三个来检查特权级： CPL：当前运行的代码段的特权级，是段描述符中的DPL。CS中的DPL不一定等于描述符中的DPL，例如中断处理过程中改变了CS为用户态，这时候CS就和段描述符的DPL不相同了，这时候的控制转移检查在下一小节学习。 DPL：目标段的特权级，在描述符中 RPL：请求特权级，在段寄存器中 只有max(CPL, RPL) &lt;= DPL时，才能访问描述符请求的段。也就是只能访问特权级相同或者更低的段。如图： 限制控制转移通过JMP、CALL、RET、INT、IRET可以进行控制权的转移。 JMP和CALL有短调用和长调用两种方式，短调用仅仅只能够进行当前代码段中的转移；长调用可以寻址到其他段，通过使用段描述符或者调用门描述符，长调用仅能够调用相同特权级的可执行段或者C位为1并且优先级更低的段。设置了C位的段一般是共享代码库，能被多种特权级的程序调用，调用这种段是特权级不会改变，这也是唯一的CPL和当前执行段的DPL不同的情况。 JMP只能调转到优先级相同的段，而CALL通过调用门的方式能够访问优先级更高的段。门描述符就是系统类型的段描述符（上面有说到三种类型的段描述符：可执行、数据、系统三种类型），门描述符可能放在GDT、LDT中，也可能放在IDT中，例如调用门描述符就放在GDT/LDT中，而中断门、陷阱门、任务门描述符就放在IDT中。接下来讲调用门描述符： 门描述符保护程序入口为了保护不同特权级之间的可执行段之间的控制权传递，提供了下面四种门描述符： 调用门 陷阱门 中断门 任务门 任务门在多任务切换中学习，陷阱门在中学习。这里只介绍调用门。调用门放在LDT/GDT中，有两个作用： 定义程序的入口 定义入口的特权级 调用门在CALL和JMP中也使用段选择符，只不过选择符选中的是调用门描述符。CPU会自动识别调用门描述符。 调用门的寻址过程是：段选择器的选择符-&gt;GDT中的门描述符-&gt;门描述符中的选择符和偏移-&gt;GDT中的段描述符-&gt;可执行段，如下图： 这里就涉及到4个特权级： CPL RPL gate DPL：门的DPL target DPL：门的选择符选中的描述的DPL 如下图： 对于JMP和CALL，对于门描述符的检查不同： JMP需要满足MAX(CPL,RPL) &lt;= gate DPL &amp;&amp; target DPL == CPL CALL需要满足MAX(CPL,RPL) &lt;= gate DPL &amp;&amp; target DPL &lt;= CPL，call可以访问优先级更高的段。 这里需要注意gate DPL用于确定当前程序有没有权限访问这个门（例如该门只设计在内核下访问，那么用户态就无法访问），而target DPL确定能不能将控制权传递给目标代码段。 任务段切换的保护这一部分在任务切换时补充 被操作系统保留的指令有一些指令只能在特权及为0时使用，例如lgdt、lidt、ltr等等。还有一些敏感的指令例如IO指令，也只能在特权为0时访问，有关IO相关请看IO指令和常见硬件的访问 分页保护分页提供两种类型的保护： 内存访问的限制 类型检查 页表项中的保护位PDE和PTE中的页表项提供了了U/S和R/W位用来进行保护。 U/S=0表示管理员权限，为操作系统和其他的系统软件及相关的数据准备。U/S=1表示应用程序和数据。当CPL等于0、1、2时，认为处理器处于管理员执行模式；CPL=3时在用户态下。这意味着只有CPL=0、1、2时才能访问U/S=0的页（实际上能访问所有页），CPL=3时只能访问U/S=1的页。 通过R/W来进行类型检查，有两种类型： 只读（R/W=0） 读写（R/W=1） 当处理器处于管理员权限时，所有的页面都是可读的和可写的。在用户态下只有U/S=1并且R/W=1的页面可写。 当分页启用的时候，80386首先计算分段保护、然后处理分页保护。保护检查未通过时，将停止程序的执行并且触发一个保护异常。 可以创建一个很大的段，其中含有很多页，一些页是只读的，另一些页是可读可写的。","link":"/2019/12/20/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B07%EF%BC%9A%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/"},{"title":"ucore-os笔记4：bios和bootloader的启动过程","text":"这篇笔记学习BIOS和bootloader的执行过程，将详细分析机器加电后执行的第一条指令到操作系统的第一行代码中间经历的过程。 BOIS的启动过程计算机开机后并不是直接启动操作系统，而是先要执行一小部分初始化软件。在80386体系结构下由BIOS和BOOTLOADER组成。BOIS是存储在主板上ROM中的一个小程序，承担了最基础的输入输出功能（电脑没装系统时，我们也可以进入BOIS，BOIS中可以看到计算机的硬件信息，设置启动盘等等，其包括了对硬件最最基本的访问能力）。 计算机加电后，将BIOS加载内存中开始执行。会从一条特定的地址开始执行，该指令调转到BIOS程序的起始地址执行。BIOS会检测硬件并进行初始化，然后会选择一个启动设备。然后将该设备的第一个扇区（512字节）加载到内存的特定地址（0x7c00）。然后将控制权转交给0x7c00地址处的程序开始执行。 简单来说，当我们按下电脑的开机键后，CPU会进行如下的处理： BIOS被加载到内存中 CPU的第一条指令是调转到BIOS程序的第一条指令（1、2步都是硬件预先设计好的） 开始执行BIOS，BIOS会初始化显示器、检测计算机总线上连接的所有硬件；一切正常后将启动盘的第一个扇区（512个字节）加载到内存的0x7c00处，然后调转到0x7c00执行。所以我们的bootloader会放在磁盘的第一个扇区，大小小于512字节，BIOS执行完了就会执行bootloader的指令。 bootloader执行，切换执行模式，加载操作系统内核，将控制权交给操作系统。 操作系统初始化 BIOS初始化是硬件自动的。启动的时候，硬件会将BIOS映射到高位内存地址中，以保证向下兼容8086的启动模式。 bootloader的启动过程BIOS读取硬件扇区到0x7c00的内存中，并调转到0x7c00执行。所以bootloader被放在0x7c00的位置开始执行。（所以在makefile中链接bootblock的时候，将代码段地址设置成0x7c00。目前不懂这里链接指定的地址有什么用？后面学会了回来该） bootloader的主要工作是： 切换到保护模式，启用分段机制 读取ELF执行文件格式ucore操作系统到内存中 显示字符串信息 把控制权交给ucore操作系统 接下来我们详细分析下面两个部分： 如何切换到保护模式？（如果不了解什么是保护模式，请先阅读实模式与保护模式） 如何读取ELF执行文件格式？（如果不了解elf文件格式，请先阅读elf文件结构） 如何从实模式切换到保护模式从实模式切换到保护模式要经历两个步骤： 开启a20 gate 启用80386的分段机制实现保护 下面分别说明这两个部分： 开启a20 gate8086处理器是16位的，只能以实模式运行，最大只能访问1MB内存。但是通过segment:offset的形式，可以得到高于1MB的地址。在这种情况下，8086会将高于1MB的地址“回卷”（只取前20位，溢出的部分舍弃），变成低于1MB的地址。一些8086的软件用到了这样的特性。在80386中，最大内存是4GB，超过1MB就不会“回卷”了，这样就不向下兼容了。所以有了A20 gate（A0-A19是20根地址线），A20 gate默认是不启用的，这样实模式下就只能访问1MB的内存，保证向下兼容。 因为a20 gate只是控制第21根地址的开启和关闭。在80386下（大于1MB的内存），如果开启了a20 gate： 实模式下就可以访问ffff0+0ffff=10ffef=1088KB的内存，超出的64KB也能访问； 保护模式下能够访问完整的4G内存 如果没有开启a20 gate： 实模式下只能访问1MB的内存 保护模式下，a20始终位0，那么只能访问奇数兆的内存0-1M，2-3M… 计算机开机以后是以实模式运行，我们的操作系统是面向32位CPU设计的，所以在bootloader中要启用全部的32根地址线。从实模式切换到保护模式的第一步就是开启a20 gate。 a20 gate的开启和关闭使用通过键盘控制器8042来控制的（需要通过一种方式来控制a20的开启和关闭，工程师们为了节省硬件设计成本将其集成到了键盘控制器中，a20 gate和键盘没有关系），所以我们需要通过io指令向键盘控制器8042发出控制命令，启用a20。bootasm.S中相关代码如下：123456789101112131415seta20.1: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.1 movb $0xd1, %al # 0xd1 -&gt; port 0x64 outb %al, $0x64 # 0xd1 means: write data to 8042's P2 portseta20.2: inb $0x64, %al # Wait for not busy(8042 input buffer empty). testb $0x2, %al jnz seta20.2 movb $0xdf, %al # 0xdf -&gt; port 0x60 outb %al, $0x608042对外暴露了两个端口：0x60和0x64，下面是对8042的简单介绍： 键盘控制器的端口是0x60-0x6f，但是只使用了0x60和0x64两个端口。通过这两个端口给键盘控制器发送命令或者读取状态 8042有两个寄存器，一个是状态寄存器，保存了控制器当前的状态信息（键盘使用启用，buffer中是否有数据等），另一个是控制寄存器。状态寄存器各位信息如下： | bit | meaning | |—|—| |0 |output register (60h) 中有数据| |1 |input register (60h/64h) 有数据| |2 |系统标志(上电复位后被置为0)| |3 |data in input register is command (1) or data (0)| |4 |1=keyboard enabled, 0=keyboard disabled (via switch)| |5 |1=transmit timeout (data transmit not complete|) |6 |1=receive timeout (data transmit not complete)| |7 |1=even parity rec’d, 0=odd parity rec’d (should be odd)| 0x64端口用于写入命令，读取状态信息。0x60用于写入和读取数据。在0x64端口状态信息；写0x64端口写入命令。 8042有两个内部端口（上图中有），这两个内部端口在内部电路中使用，程序员不可见，但是通过向0x64端口写入特定的命令可以改变这两个端口的数据。我们本次要改的a20控制就在内部输出端口的p21，这个信号控制a20的开启和关闭。 设置键盘控制器的步骤是： 等待8042的输入缓存为空。等待上一条IO命令结束，结束后会清空标识寄存器。因为CPU的速度远快于IO设备的速度，所以一定要加这个判断。 向0x64写入设置内部输出端口的命令 等待输入缓存为空 向0x60写入要设置的值 在代码中，inb $0x64,%al和testb 0x2,%al用于判断键盘控制器的输入缓存是否为空。0x2=00000010，对照上面状态寄存器的第二位，1表示input register中有数据，当有数据时，重复，直到没有数据为止。 然后向0x64写入命令0xd1，表示写内部输出端口，然后写入0xdf(11011111)，将p21置高电平，其他的位可以不管，是键盘控制器细节相关的，我们这里只了解一下就可以了。 计算机接口技术课程的相关知识：一个IO设备控制器一般会占用多个端口，分别是状态端口、数据端口、控制端口，一般都是通过控制端口输入控制字，控制字可以设置要对IO控制器进行的操作，如读取IO设备状态、向设备写入数据等等；控制寄存器用于写入IO设备控制器的操作命令，通过改变控制寄存器的相关位，就可以改变控制器的工作模式，例如从写数据切换到读数据。通过地址总线或者IO总线来寻址到特定设备端口，通过数据总线向控制器端口写入或者读取数据，通过控制总线发出一些特定的控制信号。一般来说IO操作的步骤是： 1.向IO设备控制器的控制端口写入控制字2.根据控制字的设置向数据端口写入或者从数据端口读取数据 Intel 80386相关知识：通过out指令寻址的IO设备使用的是IO地址空间，该地址空间和内存地址空间独立。 开启分段机制进入保护模式 这里需要了解保护模式的知识（请学习GDT与保护模式） 先看bootasm.S中的相关代码：123456789101112131415161718 lgdt gdtdesc movl %cr0, %eax orl $CR0_PE_ON, %eax movl %eax, %cr0 # Jump to next instruction, but in 32-bit code segment. # Switches processor into 32-bit mode. ljmp $PROT_MODE_CSEG, $protcseg.code32 # Assemble for 32-bit modeprotcseg: # Set up the protected-mode data segment registers movw $PROT_MODE_DSEG, %ax # Our data segment selector movw %ax, %ds # -&gt; DS: Data Segment movw %ax, %es # -&gt; ES: Extra Segment movw %ax, %fs # -&gt; FS movw %ax, %gs # -&gt; GS movw %ax, %ss # -&gt; SS: Stack Segment80386及之后的CPU提供了保护模式，主要通过GDTR寄存器和GDT（全局描述符表）来实现。GDTR中存了GDT的入口地址。第一步我们将GDT的地址加载到GDTR寄存器中，使用lgdt gdtdesc从内存中加载GDT的大小和地址到GDTR寄存器中。注意这个时候cr0寄存器中的PE位没有打开，所以CPU还没有启用分段机制，所以此时的内存访问就不涉及到分段的问题。 接下来设置cr0中的PE位，开启了CPU的保护模式。这时候就要设置段寄存器的值了，因为接下来的内存访问就会从GDT中取找对应的段了。所以接下来通过ljmp设置CS寄存器的值，因为CS寄存器的值只能通过调转指令间接设置。然后通过mov指令设置其他段寄存器的值。这样我们就开启了CPU的保护模式。 如何加载操作系统前面提到了操作系统的加载由bootloader来实现，bootloader是放在硬盘第一个扇区、大小小于512字节的一段程序，bootloader主要做了两部分的工作，一个是从实模式切换到保护模式，另一个是加载操作系统到ram中并移交控制权。前面我们讨论了如何从实模式切换到保护模式，这里如何加载操作系统。 要理解如何加载操作系统，需要直到两方面的知识，第一个是操作系统的格式细节，这里我们使用的操作系统是ELF格式；另一个如何访问硬盘。下面我们先分别介绍这两方面的知识，因为只有直到ELF文件的格式之后，才能直到如何去读取操作系统并运行。 ELF文件格式介绍ELF(Executable and linking format)文件格式是Linux系统下的一种常用目标文件(object file)格式，有三种主要类型: 用于执行的可执行文件(executable file),用于提供程序的进程映像,加载的内存执行。这也是本实验的OS文件类型。 用于连接的可重定位文件(relocatable file),可与其它目标文件一起创建可执行文件和共享目标文件。 共享目标文件(shared object file),连接器可将它与其它可重定位文件和共享目标文件连接成其它的目标文件,动态连接器又可将它与可执行文件和其它共享目标文件结合起来创建一个进程映像。 参考资料：这里只介绍第一种，也就是可执行文件的格式。 elf-overview 可以看到ELF文件最开始的部分是ELF header，header包含了elf文件的所有信息，包括程序的每一部分大小、位置等等。对于可执行文件，其次最重要的就是program header table(pht)，pht包含了如何创建一个进程映像的信息，可执行文件必须含有pht。pht并不一定就紧跟在header后面，除了elf header以外的其他部分的顺序是不确定的。 ELF header1234567891011121314151617struct elfhdr { uint32_t e_magic; // must equal ELF_MAGIC uint8_t e_elf[12]; uint16_t e_type; // 1=relocatable, 2=executable, 3=shared object, 4=core image uint16_t e_machine; // 3=x86, 4=68K, etc. uint32_t e_version; // file version, always 1 uint32_t e_entry; // entry point if executable uint32_t e_phoff; // file position of program header or 0，程序头表在文件中的字节偏移。 uint32_t e_shoff; // file position of section header or 0 uint32_t e_flags; // architecture-specific flags, usually 0 uint16_t e_ehsize; // size of this elf header uint16_t e_phentsize; // size of an entry in program header uint16_t e_phnum; // number of entries in program header or 0，程序头表的项数。 uint16_t e_shentsize; // size of an entry in section header uint16_t e_shnum; // number of entries in section header or 0 uint16_t e_shstrndx; // section number that contains section name strings}; elf header的前16个字节用于标识一个elf文件，前四个字节是magic number，表示这个文件是一个elf文件，后面的12个字节表示elf文件类别，平台等等，这里没有用到，所以我们用uchar elf[12]表示了。其他重要的有entry——程序入口的虚拟地址、program header和phnum。 对于可执行文件其次最重要的是program header，program header是一个特定结构的数组，数组中的每一个元素代表一个section。结构如下：12345678910struct proghdr { uint32_t p_type; // loadable code or data, dynamic linking info,etc. uint32_t p_offset; // file offset of segment uint32_t p_va; // virtual address to map segment uint32_t p_pa; // physical address, not used uint32_t p_filesz; // size of segment in file uint32_t p_memsz; // size of segment in memory (bigger if contains bss） uint32_t p_flags; // read/write/execute bits uint32_t p_align; // required alignment, invariably hardware page size};包含section的偏移，虚拟地址、物理地址、大小等等信息。ucore-os的加载将会利用这些信息，将每一个段加载到指定的内存地址中。 elf其他格式的解析，会结合操作系统程序的链接、加载一起学习，请看操作系统程序的链接、加载 硬盘访问概述当前硬盘数据是储存到硬盘扇区中,一个扇区大小为512字节。读一个扇区的流程(可参看boot/bootmain.c中的readsect函数实现)大致如下: 等待磁盘准备好 发出读取扇区的命令 等待磁盘准备好 把磁盘扇区数据读到指定内存 硬盘访问的具体细节，我们在其他的文章中学习，因为涉及到计算机接口、计算机组成原理等的知识，请看x86下的IO访问详解 操作系统加载前面我们了解了基础知识，接下来分析操作系统的加载过程，首先分析代码中：1234567891011121314151617181920212223242526272829303132333435363738394041424344static voidreadseg(uintptr_t va, uint32_t count, uint32_t offset) { uintptr_t end_va = va + count; // round down to sector boundary va -= offset % SECTSIZE; // translate from bytes to sectors; kernel starts at sector 1 uint32_t secno = (offset / SECTSIZE) + 1; // If this is too slow, we could read lots of sectors at a time. // We'd write more to memory than asked, but it doesn't matter -- // we load in increasing order. for (; va &lt; end_va; va += SECTSIZE, secno ++) { readsect((void *)va, secno); }}// read the 1st page off disk// 读取磁盘的第一页到内存中的ELFHRD（0x10000）位置，1页是4K，8个扇区。// ELF可执行文件的ELF头在最开始的位置，这里将头读出来，然后根据头中的信息去读程序信息readseg((uintptr_t)ELFHDR, SECTSIZE * 8, 0);// is this a valid ELF?if (ELFHDR-&gt;e_magic != ELF_MAGIC) { goto bad;}struct proghdr *ph, *eph;// load each program segment (ignores ph flags)// ph是程序头段的开始地址ph = (struct proghdr *)((uintptr_t)ELFHDR + ELFHDR-&gt;e_phoff);// eph是程序头段的结束地址（指针+数字的值是：指针值+数据类型大小*数字）eph = ph + ELFHDR-&gt;e_phnum;for (; ph &lt; eph; ph ++) { // 这里p_offset按照扇区对齐去读 readseg(ph-&gt;p_va &amp; 0xFFFFFF, ph-&gt;p_memsz, ph-&gt;p_offset);}// call the entry point from the ELF header// note: does not return// 将ELF文件读入之后，到elf程序的开始地址执行((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))();最开始直接将硬盘的第一页读取到设定的内核起始位置0x10000，注意这个是从第二个扇区开始读，因为第一个扇区是bootloader，所以有offset / SECSIZE + 1。读取的第一页中可能也包含了其他的段，但是这里我们只关心elf header，其他的段后段会再读，读的时候可能会覆盖本次读的段，这些都没有问题。事实上我们也可以按照扇区大小和header的大小向上取整读若干个扇区，但是这里为了方便就直接读一页了。 硬盘读取是一次读取一个扇区，所以我们的硬盘访问分为两个方面： 第一个是按照段来解析，从program header中读取每一个段的虚拟地址、大小和偏移，虚拟地址是加载到内存中的地址，虚拟地址+大小就能确定这个段的范围；这里要注意偏移是指段在文件中的偏移位置，不一定按照扇区对齐了，而读取硬盘却是按照一个一个扇区读取的，所以我们要按照扇区来对齐进行读取，offset / SECSIZE + 1就是扇区号（从1开始，因为0是bootloader），而且这里将硬盘中的内容加载到连续的内存中，offset向下取整了，所以其映射到内存位置也要向下调整，所以有va -= offset % SECSIZE。 第二个是按照扇区来读，前面我们已经得到了段的范围和偏移，由偏移可以确定起始扇区，范围可以确定扇区的个数。先按照扇区对齐，然后逐个读入扇区到内存中，就将对应的段加载到了内存中。 最后调用((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))()，将入口地址作为一个没有返回值没有参数的函数指针调用，就将控制权交给了操作系统，后面执行的就是操作系统内核代码了。","link":"/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B04%EF%BC%9Abios%E5%92%8Cbootloader%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/"},{"title":"ucore-os笔记9：TSS以及机制和策略的关系","text":"这篇文章主要介绍硬件提供的机制与操作系统设计的策略的联系，解决类似80386提供了LDT，ucore-os为什么没有使用呢？为什么不用TSS实现多进程呢？这类问题。同时也简要介绍的TSS相关的cpu硬件知识，因为ucore-os中使用了一小部分TSS的能力。 第一部分是个人的一些思考，关于机制和策略的思考，如果只想看TSS相关的知识，直接跳到第二部分。下面进入正体： 机制和策略的关系为了对CPU的使用进行抽象，操作系统进行了进程的设计，intel 80386其实在硬件层面提供了进程抽象的支持，但是ucore-os并没有使用80386处理器提供的任务切换机制进行进程的设计。TSS机制是硬件多任务机制，ucore使用的软件多任务机制。原因可能如下： 与硬件强相关，假如换成其他CPU架构，那进程模块的绝大部分功能都需要重写 有较大的限制，只能使用CPU指定的方式进行进程切换，切换使用指定的格式，不够灵活 除了多进程设计之外，还有内存管理抽象机制。我们知道每一个进程都有独立的地址空间，80386也提供了LDT来进行进程地址空间的抽象，为每一个进程分配一个LDT即可实现线性地址的抽象。但是ucore-os没有使用LDT，使用的是页表来实现进程地址的抽象。 原因其实很简单，CPU只是提供了一种机制，我们只是在CPU的机制上进行操作系统的设计，用不用CPU的功能我们说了算，只要能够利用硬件能力满足我们系统设计的需求，就没有问题。所以我们看到80386的很多机制在ucore-os中都没有使用，随着系统的扩大需求增多，我们可能需要更多的CPU能力来满足系统设计的需要。 机制和策略是操作系统原理中常常强调的东西，机制是已有的能力或者框架，策略是在一定机制下进行的设计。可以参考分页机制，提供了一种分页的能力，怎么利用分页的能力来进行地址抽象的设计就是策略。 TSS及相关的多任务硬件机制intel 80386在硬件层面提供了多任务的支持，与下列硬件相关： Task state segment（TSS）：内存中的一段区域，用于描述一个task相关的 Task state segment descriptor：TSS描述符，放在GDT中，其中存了TSS的线性基址和DPL等信息 Task register（TR）：TSS描述符寄存器，存放当前运行的程序的TSS的选择符 Task gate descriptor： TSS 参考资料：80386 MultiTask CPU管理一个task的信息存在一个TSS中，TSS可以被放在内存的任意区域中，通过TR找到TSS描述符，通过TSS描述符找到TSS。 TSS的内容是大部分的寄存器（通用寄存器、段寄存器、EFLAGS、EIP）、上一个任务的TSS选择符、LDT、cr3、指向0-2优先级的esp（esp0、esp1、esp2）和IO map基址。 TSS图： TSS descriptotTSS描述符只能放在GDT中，描述一个TSS的起始地址、大小、权限等信息，通过TR能从GDT中找到tss描述符、通过tss描述符可以找到TSS。 一个tss就对应着一个task（操作系统中称为进程），能访问TSS的程序就能导致任务切换。TSS不能读取和修改，要修改TSS只能通过TSS所在内存在进程的数据段的进程中修改。将TSS描述符加载到段寄存器中会导致一个错误。 TR和Task Gate descriptortask register是cpu的一个16位寄存器，和其他段寄存器类似，表示权限以及tss descriptor在GDT中的偏移。 通过ltr和str指令可以修改和存储tr的值。ltr是一条受限的指令，只能在CPU=0下执行。str则没有限制。通常在系统初始化时设置一个TR的初始值，之后TR的值通过任务切换改变。 Task Gate Descriptor（TGD）提供了一种不直接的方式访问TSS，TGD中存了TSS的选择符。TGD可以放在LDT或者IDT中。 任务切换那怎么进行任务切换呢？80386提供了几种机制进行进程切换： 使用jmp或者call来引用一个TSS descriptor或者Task gate 中断向量指向IDT中的Task gate NT设置时使用IRET返回。NT用来处理嵌套的Iterrupt Task。ucore-os没有使用这一部分功能。 任务切换时进行的步骤如下： 检查权限和TSS描述符的合法性 TR存的是当前程序的TSS选择符，从TR保存当前的寄存器、页表、LDTR等到TSS中 将新任务的选择符加载到TR中 将寄存器的值从新任务的TSS中恢复，新任务恢复到上一次保存的CS：EIP处执行 ucore-os中的TSSTSS一般用于硬件的多任务切换。ucore-os使用的是软件多任务处理，但是也需要TSS的支持。ucore-os总共只使用了一个TSS，用于中断、系统调用等的堆栈切换。 中断时，如果发生了特权级的切换（从用户态到内核态），就会使用TSS中的SS0和ESP0，并将原来的SS和ESP压栈。TSS中除SS0和ESP0的其他内容在ucore-os中没有作用。 在多进程设计时，每个进程运行时都可能发生中断，所以要为每个进行分配独立的中断栈。进程切换时通过设置tss.esp0来实现独立的中断堆栈。","link":"/2020/01/05/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B09%EF%BC%9ATSS%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1%E8%AE%BE%E8%AE%A1/"},{"title":"ucore-os笔记8：汇编指令总结","text":"这篇文章总结了ucore-os中使用的汇编语言伪指令，便于更好的理解ucore-os的源码。 汇编程序中的伪指令汇编程序中伪指令以 “.”开头，例如.section，.globl等。下面是linux内核源码中常见的集中常见指令： .ascii 语法： .ascii “string”… .ascii表示另个或多个（用逗号隔开）字符串，并把每个字符串（结尾不自动加’\\0’字符）中的字符放在连续的地址单元。另一个与.ascii类型的是.asciz，z代表’\\0’，即每个字符串结尾自动加一个’\\0’字符 .fill语法：.fill repeat,size,value其中，repeat，size和value都是常量表达式。.fill和含义是反复拷贝size个字节，重复repeat次。repeat可以大于或者等于0。size也可以大于或者等于0，但不能超过8，超过8也只取8。size个字节的内容讲被填充为value的值，如果size的大小大于value的储存所需要的容量，则将高位用0来填充，例如，如果value的大小位4个字节，size为8，那么高4位的内容被填充为0，低4位内容置为value。size和value为可选项。如果第二个逗号和value值不存在，则假定value为0.如果第一个逗号和size不存在，则假定size为1. .globl语法：.globl symbol.globl使得链接程序(ld)能够看到symbol。如果你的局部程序中定义了symbol，那么，与这个局部程序连接的其他局部程序也能存取symbol，例如：某个.S 文件的源程序中某一段为如下123.data.globl number.set number 10而与该文件属于同一个文件夹的另一.S 文件的某一段代码为12.textmovl $number %eax在前一个文件中定义的.globl变量number在后一个文件中可以被引用。 .rept .endr语法：.rept count …… .endr把rept与.endr之间的行重复count次，例如：.rept 3.long 0.endr相当于：.long 0.long 0.long 0在这里， .rept 指令比较容易和.fill 指令混淆，它们的区别是.rept 是将.rept 与.endr 之间的指令重复 3 次，而.fill 则是单纯的重复填充数据。 .space语法：.space size,fill这个指令保留size个字节的空间，每个字节的值位fill。size和fill都是常量表达式。如果逗号和fill被省略，则假定fill为0. .byte语法：.byre expressions预留一个字节，并将这个字节的内容赋值为expression，如果是用逗号隔开的多个expression，则为预留多个这样的字节，并将他们的内容依次赋值。 .word语法：.word expressions预留两个字节，并将这两个字节的内容赋值为expression，如果是用逗号隔开的多个expression，则为预留多个这样的2个字节，并将他们的内容依次赋值。 .long语法：.long expressions预留4个字节，并将这4个字节的内容赋值为expression，如果是用逗号隔开的多个expression，则为预留多个这样的4个字节，并将他们的内容依次赋值。 .set设定常数，就好像C程序中的#define作用一样，例如：.set mark, 0x10，这样在接下来的程序中就可以用诸如movl $mark, eam这样的指令来引用mark。cli指令、sti指令cli将IF置0，屏蔽掉“可屏蔽中断”，当可屏蔽中断到来时CPU不响应，继续执行原指令。而sti相反，sti将IF置1，允许“可屏蔽中断”，中断到来转而处理中断。cld指令、std指令清除方向标志，在字符串的比较、赋值、读取等一系列和rep连用的操作中，di或si是可以自动递减的，而不需要人来加减它的值，cld即告诉程序si、di向前移动。同样，std指令告诉程序si、di向后移动。 #include &lt;文件&gt;导入另一个汇编文件，不同汇编器指令不同，例如MASM下是include 文件。在这次内核实验中导入的指令是#include&lt;inc/mmu.h&gt;inb、outb、inw、outwCPU和IO端口进行通讯的指令。b表示一个字节，w表示一个字。例如：inb $0x64,%al，outb %al,$0x64 test指令语法：test %eax, %ebxtest属于逻辑运算指令。功能：执行BIT与BIT之间的逻辑运算，将两个操作数做与运算，仅修改标志位，不回送结果。接下来可以根据标志位进行条件跳转，如jz、jnz等。.code16 .code32这两个指令告诉汇编器接下来的指令是按照16位处理还是32位处理。例如，如果设置成.code32那么接下来的地址处理等都会按照32位进行。 ljmp指令语法：ljmp 段选择子，段内偏移ljmp是linux下AT&amp;T格式的汇编指令。表示长跳转。 leave指令语法： leave在16位汇编下相当于:mov bp,sppop bp在32位汇编下相当于:mov ebp,esppop ebp ret指令pop eip，从栈中弹出返回地址并赋值给eip。","link":"/2019/12/26/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B08%EF%BC%9A%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/"},{"title":"ucore-os笔记6：中断和异常、IDT和IDTR","text":"外部设备与CPU通信需要通过中断机制。例如，当按下键盘上的一个键的时候，必然要通知CPU该键被按下，一种方式是CPU一直监视键盘上有没有键按下，但是这种方式性能太低。另一种方式由设备主动通知CPU有事件发生，当键盘被按下时，键盘通知CPU有键被按下并且告知是哪一个键，这种方式就是中断方式。中断机制是系统具有响应式能力，也是进程/线程实现抢占式调度的一个重要基石（通过时钟中断）。 操作系统中有三种中断，分别是： 外部设备引起的：IO中断、始终中断等异步产生的，与CPU的执行无关，简称为中断 CPU运行中引起的：例如除0、缺页、地址越界等等，在CPU运行时CPU检测到的异常，称为异常 用户调用引起的：例如系统调用，用户调用了INT指令，也是在CPU运行时检测到，称为陷入 上面的三种中断可以分为两大类，异步中断和同步中断。异步中断由外部事件产生，时间不确定。同步中断由CPU产生，可以是CPU执行时的异常，或者用户调用特定指定导致。 中断还可以分为可屏蔽中断和不可屏蔽中断，可屏蔽中断由NMI引脚触发，不受EFLAGS寄存器中的IF影响。普通中断硬件由INTR引脚引起，可通过IF位屏蔽 中断处理过程当CPU检测到中断时，会中断当前指令的执行，调转到中断处理程序的位置执行。那如何直到中断处理程序在哪个位置呢？CPU使用IDTR和IDT和储存中断处理程序的地址。中断调用结束后会回到被中断的指令的位置继续执行，那如何直到中断前的指令的位置呢？通过堆栈来实现，CPU会自动将指令位置相关的寄存器cs、eip压入内核栈，中断结束后通过iret将栈中的数据恢复到寄存器中。 IDTR是中断描述符表寄存器，存了中断描述符（IDT）的起始地址和长度：IDTR 每一个中断有一个中断向量号，最多有256个中断向量号。中断向量号对应IDT中的表项，IDT是中断描述符表，里面最多有256个表项与中断向量号一一对应。寻找中断程序入口的步骤是，从IDTR找到起始地址，注意这里的起始地址就是线形地址，不需要在经过GDT转化；寻找计算对应的表项的地址，计算公式是base+interrupt number * 8，乘8是因为一个表项占8个字节。找到对应的表项之后，表项中存了中断程序的逻辑地址，就是段描述符+偏移；CPU将段描述符加载到段寄存器中，偏移加载到EIP中，然后就得到中断处理程序的线形地址，描述符表项结构：IDT表项 中断向量表的前32个是被CPU保留的，[32,255]是给用户使用的，所以ucore定义的中断都在32之后，包括IO设备中断、系统调用等等。cpu触发中断以后，会禁用中断（将EFLAGS寄存器中的IF位置0），中断处理程序中可以手动开启来实现中断嵌套，但是需要自行处理堆栈；陷入和异常不会禁用中断。 IDT中有三种描述符，在上图中有其格式，分别是： Task-gate descriptor Interrupt-gate descriptor Trap-gate descriptor 中断过程中硬件完成的工作中断过程中的调转到中断程序和从中断程序都是硬件进行的： CPU在执行完每一条指令之后，都会检测中断请求，如果监测到中断请求，会从总线上读取对应的中断向量（对应计算机接口中的IO读周期） 用读取到的中断向量号来寻找中断向量的起始地址，通过IDT和IDTR找到描述符项 描述符项中有段描述符和偏移，利用它们找到GDT中的对应表项，取的中断服务程序的线形地址 CPU会根据CPL和中断处理程序的段描述符的DPL确定是否发生了特权级的转换。因为用户程序运行在用户态，而内核程序运行在内核态。中断会陷入内核态，如果是在用户态，则需要先切换到内核态。在用户态执行int指令，会通过TSS和TR可以取得内核栈地址，切换到内核栈然后将用户态的ss和esp压栈保存下来。如果是内核态陷入中断，则不需要这些处理，栈中也没有ss和esp CPU会保存一些现场信息用于返回原程序执行，所以会压栈eflags、cs、eip、errorCode（有的中断有errorCode，有的中断没有，是CPU预置的） CPU将cs、和eip切换到中断程序的地址，然后开始执行 执行完中断程序以后，通过iret指定恢复原有的程序。指定iret后，CPU会将eflags、cs、eip从栈中恢复到寄存器中，cpu不会自动弹出errorCode，需要手动弹出 如果是有特权级切换，不管是用户态还是内核态，都会弹出ss和esp。 中断处理程序寻址过程：中断处理程序寻址过程 堆栈变化：堆栈变化 这里需要注意堆栈变化，当有权限切换时，会压入/弹出SS和ESP，不管是从内核到用户态还是从用户态到内核态。例如，从内核触发中断的时候，没有发生切换，所以不会压栈SS和ESP，但是如果在中断程序中切换了CS到用户态的CS，那么从中断返回的时候，就会从堆栈中多弹出SS和ESP，写代码的时候要注意这一点（lab1挑战实验1）。堆栈变化1 中断处理过程中的特权级转换中断时CPU会进行特权级的检查。这个特权级的检查分成两个部分，一个是IDT中表项中的段描述符，段描述符中的DPL确定了所处段的特权级，只有段描述符的特权级高于或等于当前特权级时，检查通过；当触发中断和从中断程序返回都会检查，检查中断程序的段选择符和当前的CS，如果两者的DPL不相同，就发生特权级切换了，堆栈处理操作不同，看上一小节的堆栈图。 另一个是IDT表项中的DPL，如果是用户态程序触发的（例如INT n），还会检查表项中的DPL，只有当DPL更低时或相同时才通过检查，这就阻止了用户程序能够触发任意的中断，例如用户态为3，那么就只能触发DPL为3的中断。这里需要注意只有INT指令触发的中断，才会检查DPL，由硬件触发的中断不会检查DPL，所以硬件中断的代码即使位于内核段中，也能直接被调用；但是权限切换依然会被检查，如果当前是用户态执行触发了硬件中断，那么会压入ss和esp 如果检查失败，CPU会触发一个保护异常。idt-privilige-check ucore-os对于中断的实现ucore-os的中断向量表定义在kern/trap/vector.S中，该文件由tools/vertor.c文件生成。vector.S文件的主要内容是定义了256个中断向量处理程序的入口，在中断时的有的会自动压入errorNumber，有的不会，vector.S中的不会自动压入errorNumber的会压入一个0，以统一结构。每一个程序再压栈errorNumber（如果CPU不会自动压栈的话）和压栈中断向量号后，同一调转到__alltraps执行：123456.globl __alltraps.globl vector0vector0: pushl $0 pushl $0 jmp __alltraps alltraps是另一个汇编文件trapentry.S中定义的全局符号，链接后会指向trapentry.S中的`alltraps`。trapentry.S的作用是构造trapframe的栈结构，并调用trap函数，trap函数返回后出栈trapframe的结构。因为涉及到特定寄存器的入栈出栈，这一部分代码用汇编语言描述最方便。 vector.S中定义了全局段全局符号__vectors，其值是一个数组的起始地址，数组的每一项是每一个入口程序的地址。因为符号__vectors是全局符号，所以可以在C程序中可以直接访问，因为链接后会加入到符号表中。12345678910# vector table.data.globl __vectors__vectors: .long vector0 .long vector1 .long vector2 .long vector3 .long vector4 ... 再idt_init进行idt初始化的时候，要做的事情就是构造IDT表并填充表项。__vectors中已经有了中断处理函数的地址，只需要在设置DPL等等其他表项的内容，就能构造出来IDT表。最后将IDT表的地址使用lidt指令加载到IDTR寄存器中，我们就完成了中断向量表的初始化。","link":"/2019/12/19/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B06%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E3%80%81IDT%E5%92%8CIDTR/"},{"title":"OS原理：进程管理","text":"这篇笔记复习进程管理相关的操作系统原理。包括进程和线程的定义，进程和线程的内存空间、进程实现、进程调度、进程同步等知识点。","link":"/2020/02/15/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/OS%E5%8E%9F%E7%90%86%EF%BC%9A%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/"},{"title":"OS原理：内存管理","text":"这篇笔记复习进程内存管理相关的操作系统知识。包括内存空间的定义、分段和分页、安全和权限、虚拟内存等等知识点。","link":"/2020/02/15/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/OS%E5%8E%9F%E7%90%86%EF%BC%9A%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"},{"title":"OS原理：文件系统","text":"这里文章学习操作系统的原理，主要学习的核心知识点有以下几个： 文件系统的作用和组成成分？ 对文件和目录有哪些操作？ 文件系统如何实现？包括： 空闲磁盘空间如何管理和分配？ 如何实现文件到磁盘块的映射管理？ 文件系统如何在磁盘上存储？ linux和windows是如何实现文件系统的？ 本片文章带着这些问题来复习文件系统的相关的知识，由浅入深。从文件系统解决的问题，到对文件系统的操作，再到文件系统的具体实现方式，再到具体的操作系统的文件系统的设计实现。从原理到实现熟练掌握文件系统。学完原理后，可以分析ucore-os中的文件系统的设计和实现的详细代码（在另一篇文章中，请看）。本文参考自《现代操作系统》一书，添加了自己的理解。 文件系统的作用和组成成分在计算机运行时，数据基本都是存储在内存（RAM）中的，RAM中的数据具有易失性，当进程退出或者计算机掉电的时候就会丢失数据。磁盘等设备能够长时间存储数据，即使断电，所以一般用磁盘、U盘、光盘等设备来进行长期的数据存储。 但是磁盘、U盘、光盘等设备的数据储存方式和结构可能完全不一样，操作系统需要能够处理这些不同的设备。文件系统需要解决的第一个问题，就是设备的抽象性，例如，我的电脑上插了硬盘、U盘、SSD三块设备，但是我希望以相同的方式来管理和访问三个不同的设备。例如windows上的文件系统，当新插入一个硬盘/光盘/U盘时，会分配一个新的盘符，该盘符的访问和其他所有盘符的访问方式完全相同。 这就出现了文件系统的两层抽象，第一层屏蔽不同硬件的差异；第二层屏蔽不同文件系统的差异。第一个问题通过设计适合不同设备的不同文件系统解决。第二个问题通过虚拟文件系统（VFS）解决。后文会详细讨论这两个问题的解决方案。 文件系统最关键的两个组成元素就是文件和目录。文件和目录都是抽象的概念，一个文件表示一个逻辑上的数据集合；一个目录能够包含其他目录和文件，是一种层级上的抽象。对于操作系统用户来说，直接操作的接口就是文件和目录接口，需要存储的数据以文件为基础单位，通过目录来对文件进行组织和区分。例如希望保存联系人列表，可以创建contact.txt文件、numbers.txt文件；创建短信列表，可以创建message.xml文件；然后通过目录来区分联系人列表或者短信。 还有其他的元素例如字符特殊文件和块特殊文件，字符特殊设备将特殊的字符流设备例如打印机映射到文件系统，通过对对应的文件进行读写就可以读写对应的设备。这里只讨论普通文件。 对于文件还有不同的抽象方式，例如可以将文件视做字节序列，或者记录块或者树结构。第一种方式，字节序列方式，是windows和linux都采用的方式，就是对于用户来说，从操作系统读取出来的文件都是字节序列，如何解释这些字节序列由用户程序决定。第二种方式以“记录”的形式，每一个记录拥有特定的结构和大小，这种方式限制了文件能够存储的类型，一般用于专用的文件系统。第三种方式是树形结构，和上一种结构类似，也是采取一种特殊的查找树的方式来组织文件，通过键来快速查找文件，文件的结构也是特殊的，一般用于专用的文件系统。 文件和目录的信息和操作前面提到了文件和目录的概念，文件是逻辑上的数据集合，目录是文件和目录的集合。文件是存储的基本单位，所有信息通过文件来存储，通过目录来组织，文件系统肯定会提供与文件和目录有关的操作，用来管理文件和目录；肯定会提供文件的信息，例如文件大小、文件类型、文件所有者、文件名等等。 普通文件一般分为二进制文件和文本文件。一般的可执行文件例如ELF文件就是二进制文件。磁盘中存储的都是二进制数据，二进制文件和文本文件只是应用程序对磁盘输入的二进制流的解释方式不同。文本文件一般存的是字符编码后的结果，例如ASCII、UTF-8、GBK等等。 文件和目录信息为了便于区分文件，肯定需要为文件取名字；文件名一般由名字+后缀组成，例如contact.txt，.txt是后缀，一般用于表示文件的类型。windows下在操作系统层面区分后缀。linux后缀只是在用户程序中区分。一个简单的例子，windows下只有.exe文件才可执行，而linux下只要赋予的x（可执行）权限的文件都可以执行（当然如果文件内部不是可执行文件的格式会报错）；用户层面区分的例子比如C编译器只接受输入为.c后缀的文件。 文件名的长度在不同的操作系统中不同，一些操作系统只支持最大固定长度的文件名和后缀，例如DOS是8+3，最新的操作系统的文件名长度限制会更大，例如256个字符。 常见的文件属性如下： 保护：谁能访问文件，文件是否能执行等 口令：文件访问需要的密码 创建者 所有者：拥有该文件的用户、群组等 只读标识 隐藏标识 大小 创建时间 最后修改时间 最后访问时间 … 具体的文件系统实现可能不会具有所有的属性，也可能有更多的属性，由具体的操作系统实现来决定。文件属性描述了操作一个文件所需要的信息，任何和文件有关的、用户需要的信息都可以作为文件的属性。 目录描述了文件和目录的层次结构信息，例如一个目录下的结构可能如下：12345 user / \\ all bright.txt / \\1.c hello.js 如上例，user目录下有一个目录all和一个文件bright.txt，目录all下又有两个文件：1.c和hello.js。那我要在上述文件结构中找到1.c或者bright.txt怎么办呢？在上述的目录树中我们可以很方便的找到一条从根目录到文件的路径，例如/user/all/1.c，可以用路径来表示文件在文件系统中的位置，这也是windows和linux采用的方式，不过windows使用\\作为分隔符，而linux使用/。上述这种方式叫做绝对路径，另一种方式是相对路径，例如./user/bright.txt或../hello.js，表示相对于当前位置的路径。 目录的属性和文件类似，在unix系统中，目录是特殊的文件，属性基本都相同。也包含创建者、所有者、创建时间、修改时间等等信息。 对文件和目录的操作有了文件和目录的概念，那么就需要对文件和目录进行操作，常用的操作有：创建、删除、链接、打开、关闭、读取、写入、重命名、链接等等。对于目录还有切换目录。 对于文件和目录通常有以下操作： create：创建文件或者目录，主要工作是初始化一些文件属性、将文件添加到文件系统中 delete：删除文件或者目录，从文件系统中删除文件，可能没有彻底从磁盘删除，视具体实现而定 get attribute：获取文件属性（unix中的stat） set attribute：设置文件属性 rename：重命名文件或者目录 link：链接文件或者目录，这里的链接是硬链接，两个文件共享一个i节点，只删除其中一个节点不会导致数据从硬盘删除 unlink：将i节点的链接数减1，当计数值为0时删除文件 对于文件还有以下操作： open：打开文件，文件只有打开后才能读写 close：关闭文件，一个程序能打开的文件是有限的，文件使用完成后要及时关闭 read：从文件读取数据 seek：设置文件读取的位置 write：向文件写数据 append：在文件末尾添加数据，可以通过seek来实现 对于目录还有以下操作： opendir：打开目录 closedir：关闭目录 readdir：读取目录 文件系统的实现文件系统主要实现上面提到的文件系统的特性，第一个是设备无关性，第二个是文件系统无关性。设备无关性通过文件系统来保证，文件系统无关性虚拟文件系统来保证。最顶层的是文件和目录的抽象，用户能够看到的都是对文件和目录的操作，所以文件系统还需要实现统一的文件目录操作的接口。除此之外，还有整个文件系统的在磁盘的布局，因为文件系统中的所有信息都是需要能够永久保存的，所以文件和目录的属性、结构、包括文件本身都需要存放在磁盘中，以达到永久保存的目的。如何布局这些数据在磁盘中的存储也是一个很重要的问题。文件系统的层级结构如下图： 12345678910111213 用户进程--&gt;系统调用-&gt;| 用户空间-------------------------------------|----------- 文件目录操作 &lt;----| 文件目录 内核空间 file接口 &lt;----| 抽象层 | |-&gt;虚拟文件系统操作 虚拟文件系统 |-&gt;inode接口、vfs接口 抽象层（可以有多个具体文件系统层实现并挂载） | 具体文件系统对磁盘的操作&lt;-| 具体文件系统 |-&gt;vfs接口的实现 层 | | |超级块|空间磁盘空间管理|i节点|根目录|未使用| 磁盘上的文件系统布局 下面我们会自顶向下讨论文件系统的实现，从用户空间的系统调用，内核的进程结构中的文件，到内核的文件、目录抽象，到内核的虚拟文件系统的实现，再到具体文件系统的实现及磁盘上的布局管理。每一层都会提供一定的抽象，通过下层的不同实现来兼容不同的设备或者文件系统。接下来首先介绍整个文件系统的工作过程，先整体了解，细节放在后面单独的小节中。 首先是用户空间的使用，在用户空间能够看到的是文件系统提供的最顶层的抽象——文件和目录，对于用户空间来说文件就是一串二进制数据，并不关系这文件在磁盘上是如何存储和读取的。用户空间通过一系列系统调用来实现对文件和目录的操作，也就是用户直接调用的上图中的文件目录抽象层。该层实现了对于抽象文件的所有操作，例如上面提到的打开、关闭、删除文件等等。主要依赖的数据结构是file接口，也就是最顶层的文件抽象结构，其主要的属性是和文件相关的信息，例如可读写、大小、以及与下一层关联的接口等。 下面是虚拟文件系统层，该层的主要作用是实现文件系统无关性的抽象。虚拟文件系统层定义了一系列对具体文件系统的操作，由具体文件系统来实现以此来实现提供文件目录抽象层使用的统一的底层接口。不同的具体文件系统通过叫做挂载的操作接入虚拟文件系统，挂载到虚拟文件系统后，上层便可以以统一的方式来访问这些具体文件系统，而不关心文件系统的细节。file接口只定义文件的属性，文件的实现和操作的抽象都在虚拟文件系统层定义。 具体文件系统层是虚拟文件系统层的具体实现，虚拟文件系统层会定义具体文件系统的操作抽象、存储抽象、文件路径抽象，由具体文件系统层来实现。具体文件系统层定义了文件如何在磁盘上存储、如何将文件写入磁盘，如何从磁盘读取文件。 文件和目录的实现前面讲了一个操作系统大概的文件系统层级结构，接下来从原理的角度来分析文件和目录的实现。 文件的实现有多种，第一种是连续分配，需要分配多个连续的磁盘块来满足文件的需要。这种方式的优点是文件读取块，因为文件存在相邻的磁盘块，减少了寻道时间。缺点是会导致磁盘碎片问题，因为当磁盘不断被分配和回收之后，磁盘空闲空间碎片化，这样会导致几个问题，一个是空闲空间分散，可能没有足够的连续空间来分给一个较大的文件，尽管可能总空闲空间大小远大于需要的磁盘大小；另一个是碎片化导致寻道时间增长，磁盘访问变慢导致系统卡顿。还有一个缺陷就是空洞问题，有时候可能需要增长的文件，文件大小不是预先知道的，碎片分割的空洞严重限制文件的大小增长能力。","link":"/2020/01/22/os/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/OS%E5%8E%9F%E7%90%86%EF%BC%9A%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/"},{"title":"图解密码技术1：环游密码世界","text":"本章是《图解密码技术》的第一章，将会在整体上了解一下密码世界究竟是个什么样子。 密码世界中的角色密码世界中有很多角色，有发送者、接收者、窃听者、主动攻击者等等。因为发送的信息在网络上传播，中间要经过很多网络节点、物理线路，发送的消息在传播途中可能被窃听。如果发送的是明文，那么窃听者可以很轻易的获取到发送的信息。如果是机密信息不想让窃听者知道呢。这时候这就可以使用密码技术，将明文进行加密，窃听者如果不能对密文进行解密，那么拿到就是没有意义的乱码。 计算机的密码世界中使用的加密技术是密码算法，需要密钥来进行加密解密。根据加密时使用的密钥方式不同，有对称加密（对称密码，加密和解密使用向相同的密钥）、非对称加密（公钥密码，加密和解密使用不同的密钥）等。也可以使用对称密码和公钥密码同时使用的系统，称为混合加密。 密码世界中的密码技术密码技术所提供的并不仅仅是密码的机密性，用于检验消息是否被篡改的完整性、以及认证等都是密钥技术的范畴。 加密技术 对称加密，使用相同密钥 非对称加密，使用不同密钥 单项散列函数用于验证消息是否被篡改，不仅可以用于网络通信，也可以磁盘中的数据是否被篡改，两个文件是否一致等。其本质原理是对源文档求摘要（也叫散列值、哈希值、指纹等），相同的文章摘要一定相同，所以可以用来验证文档是否被修改，用于检验完整性。 单项散列函数是单项的，由散列值不能得出源文档。 消息认证码为了确认消息的来源。消息认证码能够确认消息是否被篡改，还能够确认消息是否来自所期待的通信对象。 数字签名用于防止伪装、篡改、和否认等的技术，就是数字签名。发送方对发送的消息添加数字签名，接收方对数字签名进行验证，知道发送消息的是发送方而不是伪装者。 数字签名是一种能够确保完整性、提供认证并放置否认的技术。 伪随机数伪随机数生成器是一种能够模拟产生随机数列的算法。随机数在密码技术中非常重要，多数密码算法中都是用到的随机数。如果随机数生成算法不好，那么攻击者可能推测出密钥。 密码学家的工具箱主要是下面6种技术： 对称密码 公钥密码：同上，保证机密性 单向散列函数：保证完整性 消息认证码：保证完整性、认证 数字签名：保证完整性、认证、防止否认 伪随机数生成器 密码于信息常用 不要使用保密的密码算法 使用低强度的密钥比不使用密码更危险，尤其是涉及机密文件的时候，这时候有密码会使人掉以轻心，而低强度的密码和没有差不多 任何密码总有一天会被破解 密码只是信息安全的一部分，还有社会工程学的东西，毕竟密钥等都掌握在人手里","link":"/2019/11/08/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF1%EF%BC%9A%E7%8E%AF%E6%B8%B8%E5%AF%86%E7%A0%81%E4%B8%96%E7%95%8C/"},{"title":"图解密码技术3：对称密钥","text":"对称密码（共享密钥密码）——使用相同的密钥进行加密和解密。这章学习以下内容： 比特序列运算和XOR运算 一次性密码本 几种常用的对称密码算法：DES、三重DES、AES等 比特序列密码计算机操作的是比特序列，只要我们能够对比特序列进行加密，就能够对计算机上的文本、视频、图片等任意内容进行加密。 XOR运算XOR是异或运算符。运算规则是“同0异1”，相同的运算数得0，不同的运算数得1. 两个比特序列进行XOR是将比特序列的每一位进行XOR，没有进位。那XOR有什么性质呢？A XOR B XOR B = A。假设B为密钥，A XOR B得到密文，密文 XOR B得到明文。 一次性密码本一次性密码本是无法被破译的密码，它非常简单，原理是“将明文于遗传随机的比特序列进行XOR运算”。 无法破译的原理是：无法判断破译结果是不是正确的明文","link":"/2019/11/09/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF3%EF%BC%9A%E5%AF%B9%E7%A7%B0%E5%AF%86%E9%92%A5/"},{"title":"图解密码技术2：历史上的密码","text":"本章将学习三种历史上著名的密码： 恺撒密码 简单替换密码 Enigma 还有两种破译密码的方法： 暴力攻击 频率攻击 恺撒密码恺撒密码将字母表平移若干个字母后得到密文，例如平移三个，A变成D，如果平移后溢出了字母表，那么重新回到A。 解密也很简单，反向平移三个字母。 这里的平移多少个字母就相当于密钥，因为字母表总共值有26个字母，那么密钥可能的取值也只有26种，可以使用暴力破解，穷举可能出现的密钥。知道机密出有意义的字符串。 简单替换密码恺撒密码是通过平移字母表来建立字母之间的对应关系，那么如果我们建立其他的对应关系呢，可以使用自定义的对应表，只要加密者和机密者有统一份对应表，就能解密信息。 简单密码替换就是将明文按照对应表转换成密文。 简单替换密码的密钥空间大小是25!，使用穷举很难在有限的时间内破解。 频率分析破解简单替换密码的密钥空间比较大，第一个字母对应25个，第二个对应24个，总的空间大小是25!，暴力枚举不太可能了，但是可以用频率分析法。 英文文章中字母出现的频率是有规律的，单词出现的频率也是有规律的。例如，e出现的概率最大，the出现的概率最大。我们通过分析密文频率最大的字母，它就很有可能对应到e，以此类推，我们就可能破解出有意义的明文。 EnigmaEnigma是德国发明的用于加密解密的机器，其密钥是每日密码本，只有在机器上设置每日密码本上的密钥，再在机器上输入密文，才能解密。该机器的加密和解密操作是对称的。内部通过转子来改变电路的对应的关系，实现加密解密的映射关系。 思考为什么要区分密码算法和密钥呢？ 通过分析上面的案例，密码算法必须存在可变的部分和不变的部分，如果一切都是确定的，那么只要知道密码算法，就能够破译密码。密钥充当了可变的部分。一定有加密和解密的过程，如果每次加密和解密使用不同的算法，那么计算机需要存储的算法有点多了。 所以在现在的密码算法中，算法是不变的，在各类计算机各个平台上都有实现，密钥是可变的，只要改变密钥，就能够改变加密的密文。","link":"/2019/11/08/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF2%EF%BC%9A%E5%8E%86%E5%8F%B2%E4%B8%8A%E7%9A%84%E5%AF%86%E7%A0%81/"},{"title":"vue组件库开发：简介","text":"这一系列文章将会学习如何开发一个自己的vue ui组件库，参考现有的组件库例如element-design-vue、element-ui等等，实现大部分常用的组件，以此来深入学习html、css的实战、熟练掌握基于vue的前端开发。计划中开发的组件如下： Form表单元素，以锻炼表单美化、表单验证等等功能的开发能力： Input：初步完成、待完成数据双向绑定和数据格式验证 Model：初步完成、待完成模态和非模态 Card：初步完成，待优化 Tree：未开始 MarkdownEditor：开发中 nav：未开始 timeline：未开始 calender：未开始 Button：初步完成，待进一步设计 datetime-picker：未开始 table：未开始","link":"/2019/12/18/vue/%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%8F%91/vue%E7%BB%84%E4%BB%B6%E5%BA%93%E5%BC%80%E5%8F%91%EF%BC%9A%E7%AE%80%E4%BB%8B/"},{"title":"4.C语言中的自定义类型","text":"这篇文章学习C语言中的自定义类型。自定义类型能够将一些数据抽象化，将信息组织成我们更容易理解的模型。 枚举类型枚举类型用于表示离散有限个数据对象。通过枚举来表示一系列状态的集合。声明方式如下：12345678910111213141516171819202122enum Name { a, b, c}enum LIGHT;enum TRAFFIC_LIGHT { TRAFFIC_LIGHT_RED, // 0 TRAFFIC_LIGHT_GREEN, // 1 TRAFFIC_LIGHT_YELLOW // 2};enum LIGHT { RED = -2, ORANGE, // -1 YELLOW = 1, BLUE, // 2 INDIGO = RED - 100, // -102 PURPLE // -101}; LIGHT称为枚举类型，RED称为枚举符或者枚举常量，枚举常量可以赋整数值，可以在任意位置赋值，如果当前枚举符没有赋值，那么其值是前一个+1。 声明和使用枚举123456789101112131415161718192021222324252627282930313233343536enum LIGHT;enum TRAFFIC_LIGHT { TRAFFIC_LIGHT_RED, // 0 TRAFFIC_LIGHT_GREEN, // 1 TRAFFIC_LIGHT_YELLOW // 2} g_traffic;static enum LIGHT { RED = -2, ORANGE, // -1 YELLOW = 1, BLUE, // 2 INDIGO = RED - 100, // -102 PURPLE // -101} s_light = BLUE;// 匿名枚举enum { ONE = 1, TWO, THREE, FOUR, FIVE, SIX} g_dice = TWO;int main() { enum TRAFFIC_LIGHT traffic = TRAFFIC_LIGHT_YELLOW; g_traffic = TRAFFIC_LIGHT_GREEN; // 枚举类型可以进行算术运算，也能赋值给整型变量 g_traffic += 2;} 要点： 能够在枚举定义后面直接接变量定义并初始化。 枚举符能够全局访问，不用加前缀 声明枚举变量需要添加enum 枚举可以先声明后定义 结构体类型结构类型中可以存放任意类型的数据。 代码示例1234567891011121314151617181920212223242526272829303132#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;// 声明结构体struct StructTest;enum MyEnum { MY_NUM1, MY_NUM2};struct MyStruct { int32_t a; enum MyEnum e; double d; struct StructTest* pTest; _Static_assert(MY_NUM1 == 0, \"NG\");};// 定义结构体// 注意这里的内存分布，s占两个字节，m占24个字节（4+4+8+8=24，按照8对齐，刚好），i占12个字节（4+4+4=12，按照4对齐，刚好），一共占2+24+12 = 38字节，但是StructTest中最大成员对齐是12字节，所以按照12字节对齐，对齐到48字节，所以StructTest大小是48字节。struct StructTest { int16_t s; struct MyStruct m; struct { int32_t a,b; float f; ; } i;}; C语言中可以定义匿名结构体。 要点： 可以先声明后定义 可以使用静态断言 可以定义匿名结构体声明语句 可以定义其他任何类型 对结构体的使用1234567891011121314151617181920int main() { // 没有初始化，值都是不确定的，可能是内存中的任意值，包括里面的指针也可能指向不确定的地址 // struct MyStruct m; struct MyStruct m = {64,MY_NUM2,64.2,NULL}; // 非指针类型使用.访问成员，指针类型使用-&gt;访问 printf(\"%d %f\\n\", m.a, m.d); // 这里将结构体m赋值给st.m，非指针的结构体能够直接赋值 // 等价于分解为逐个成员赋值（显然，对于指针类型赋值的指针指针，并不会深拷贝，非指针类型会深拷贝） // 但是赋值次序不一定 struct StructTest st = { 16, m, {32, 32, 2.00}}; // 可以嵌套大括号赋值，{}称为初始化器列表 // 使用大括号显示初始化结构体 struct MyStruct m2 = { 32, MY_NUM1, 1.0, &amp;st}; printf(\"%d %d %f\\n\", st.m.a, st.s, st.i.f); // 可以仅仅对部分结构体成员赋值，其与成员自动赋值为0 struct MyStruct m = {64,MY_NUM1};} 要点： 没有初始化结构体，可能拿到内存中的任意值 成员访问使用.和-&gt; 可以直接将非指针赋值，会自动拷贝内容 可以使用初始化器初始化，可以嵌套{}，初始化器中可以通过.对象名 = 值来指定对哪个成员进行初始化，如果没有指定按顺序赋值。 可以部分赋值，未赋值部分初始化为0 只能在初始化的时候使用{}初始化器进行初始化，如果已经定义了，那么可以考虑使用下面的复合字面量赋值，c99及以上支持。 如果结构体定义的匿名结构体没有声明成员对象，那么匿名成员会称为外部结构体的成员 结构体复合字面量定义:1struct S s = (struct S){.a=100,.b=-50};相当于结构体字面量的类型投射。 联合体类型联合体和结构体的声明类似，区别是联合体的所有成员共享同一块内存区域。 结构体和联合体的内存分布联合体所占的内存由其成员的最大内存决定，所有成员共享这一部分内存。 而结构体所占的总内存是字节对齐后的总大小。对于下面的struct和union，内部分布：123456789101112131415161718192021222324struct { int8_t a; int16_t b; int32_t c;} s = { 0, 1, 2 };struct { int8_t a; int16_t b; int32_t c;} u = {0,1,2};// 内存分布如下：// c b a// --------// struct 8 4 2 0// 未对齐前7个字节，对齐后8个字节，填充的1个字节在a上//// a// b// c// ----// 4 210// a占0字节，abc共享0字节，bc共享0，1字节，c独占2，3字节。我们看到联合中最多对其中一个成员赋值，因为内存会相互影响。 要点： 联合和结构一样，其成员可以是任意内容 与结构不同，初始化列表只能有一个元素。可以用.成员的方式表示初始化哪一个成员。 123456789101112131415161718192021222324252627282930313233343536#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main() { union MyUnion { int32_t a; struct { int16_t b; int8_t c; } s; float f; } un = {.s.b=0x0201, .s.c=0x03}; union MyUnion un2 = {100}; union MyUnion un3; // 存储为规格化浮点数的二进制表示 un3 = (union MyUnion) { .f = 10.5f }; // 输出0x**030201，前两位没有赋值，可能是任意值，这一点在linux 64，gcc 8.3下和struct不一样，不会置0 // 因为s.b和s.c占前三个字节，所以前三个字节赋值了，a占4个字节，数组的是4个字节 printf(\"un.a = 0x%.8x\\n\", un.a); printf(\"un2.s.b = %d\\n\", un2.s.b); // 联合体存的是浮点数的规格化二进制表示 // 这里(int32_t)*(float*)&amp;un3.a的意思是，用浮点指针指向un3.a的地址，该地址的内容读取的时候就会按照浮点数读取 // 然后*对浮点指针取内容，取到的内容在转换成int32_t。 // 相当于读取浮点数并转为整形，所以结果是10；浮点数转整数直接去掉小数 printf(\"un3.a = %d un3.f = %f %d\\n\", (int32_t)*(float*)&amp;un3.a, un3.f, (int32_t)*(float*)&amp;un3); printf(\"%f == %x\\n\", (float*)&amp;un3, &amp;un3.a);} enum、struct、union小结 表示自定义类型时，都需要加上enum、struct、union前缀；例如struct MyStruct 可以先声明后定义 可以不初始化，此时内容是不确定的脏数据 可以在定义后面直接声明变量并初始化，可以使用匿名定义 可以使用初始化列表初始化；或者使用复合字面量初始化 struct的内存模式是成员大小叠加并字节对齐；union是所有成员共享一片内存，内存大小是最大成员的大小。 enum的成员只能是整数 位域通过位域，可以将一串比特流进行结构化描述，在通信领域用得尤为广泛。C语言的位域时在结构体或者联合体中指定位宽的成员。通常我们采用结构体来指定位域。位域成员可以和普通成员混合 结构体的成员要作为位域，必须是整数类型。指定宽度的位宽表达式应该也要是一个整数常量表示式，且不能为负。 1&lt;类型&gt; &lt;标识符&gt; : &lt;位宽表达式&gt; &lt;位宽表达式&gt;用于指定此位域的宽度，单位是bit。表达式的值必须是编译时能够确定的常量，例如整数字面量、sizeof操作符的结果、枚举值等 注意：sizeof后面接数据类型或者表达式的值都是编译时常量，但是接数组不是，不管数组是不是变长数组 12345struct BitField { int32_t a : 5; // 5 bit，值范围[-16, 15] uint32_t b : 6; int32_t c : 7;} 上例中的a和c都是带符号整数，所以a、c最高位作为符号位。上面总共是18bit，少于4字节，按照4字节对齐。编译器会自动扩充到4字节。 C语言对位域的限制： 不能对位域成员做取地址操作 位域成员不能作为sizeof的操作数 不能用对齐属性来修饰位域 指定位域宽度的常量值不能超过该类型可表示的范围，例如char类型，位域宽度不能大于8。否则编译器会报错。 位域的内存布局先看一个示例：123456789101112131415161718192021222324252627282930313233343536373839404142#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;stdbool.h&gt;int main() { struct { int32_t a:5; int16_t b:6; int32_t c:7; } s = { 1, 2 , -1}; printf(\"%zd %d %u %d\\n\", sizeof(s), s.a, s.b, s.c); // 输出4 1 2 -1。总共18个字节，一般编译器实现会将其对齐到4字节。 enum MyEnum { ENUM1, ENUM2, ENUM3 }; struct MyStruct { int32_t a : 6; int16_t b : 5; int8_t c : 8; char x : sizeof(enum MyEnum); bool y : 1; enum MyEnum e : ENUM3; } s2 = { 0x18, 0x0a, 0x77, '\\0', true, ENUM3}; printf(\"The sizeof %zu\\n\", sizeof(s)); // 以16进制输出MyStruct的内存分布 int32_t *temp = (int32_t*)&amp;s2; printf(\"%x\\n\", *temp); // 输出结果是50770298，换成2进制是 // (0)101 0000 0111 0111 (0000 0)010 1001 1000 // 然后再查看MyStruct中的位数，分别是2 1 4 8 5 6(从高到低). // 二进制前6位是 011000（0x18，对于a的赋值），6-11是 01010（0x0a，对应b的赋值） // 后面接5个0，这5个0是填充的，然后接下来8位是0111 0111（0x77对应c的赋值），以此类推}上例中我们以二进制的形式输出了MyStrcut的内存分布，括号中的比特序列是填充的bit，如何填充bit不同的编译器不一样。但是C语言指明，对于同一个结构体内相邻的两个成员，如果第一个位域成员仍有位置容纳第二个位域成员，那么第二个位域成员可以与第一个位域成员打包在一起。例如上例中的a和b合起来是11个bit，存放在连续的11个bit中。 如果构成一个单元的存储空间不够，那么后一个位域放在下一个存储单元还是与之前的单元迭交存放，这是由实现自己定义的。如何字节对齐也是标准未定义的。 示例中c占8个bit，前面11个bit，如果与前面相邻就超过了16bit寻址单元（只能按照字节寻址），GCC 8.3将其移到了后一个寻址单元，填充了5个bit的0。在当前C语言的实现中，采用从低位序到高位序的排列方式。 加入我们将c改成5bit：123456789101112131415161718192021222324 struct MyStruct2 { int32_t a : 6; int16_t b : 5; int8_t c : 5; char x : sizeof(enum MyEnum); bool y : 1; enum MyEnum e : ENUM3; } s4 = { 0x18, 0x0a, 0x09, '\\0', true, ENUM3}; printf(\"The sizeof %zu\\n\", sizeof(s)); // 以16进制输出MyStruct的内存分布 int32_t *temp2 = (int32_t*)&amp;s4; printf(\"%x\\n\", *temp2); printf(\"%zu\\n\", sizeof(struct MyStruct2)); // 输出4 // 输出结果是504a98，换成2进制是 // (0000 0000 0)101 0000 0100 1010 1001 1000 // 然后再查看MyStruct中的位数，分别是2 1 4 5 5 6(从高到低). // 二进制前6位是 011000（0x18，对于a的赋值），6-11是 01010（0x0a，对应b的赋值） // 后面接01001，是c的值（0x09），这里能够直接填充满16bit // 最高位填充0到4字节}6+5+5刚好凑成两字节，中间就不会再填充0了。 如何确定相邻的位域成员放在哪些寻址内存中呢？一般C语言实现先将第一个和第二个位域成员先拼接在一起，如果能够拼接成功，向上取满足$2^n$的最小整数。然后再看第三个位域成员，如果拼接起来不大于最小寻址单元（例如上例中的int32_t和int16_t，最小寻址单元是16bit，11+8=19超过了16），那么第三个成员也放在这个区域中，以此类推。如果大于，一般会将其放到下一个可寻址单元中，中间bit用0填充。 如何分配位域的bit分布和位域成员的类型是有关系的。如果位域成员类型能够完全容纳下所有的位域，则中间不会填充，看示例：12345678910111213141516171819202122struct MyStruct3 { int32_t a : 6; int32_t b : 5; int32_t c : 8; char x : sizeof(enum MyEnum); bool y : 1; enum MyEnum e : ENUM3; } s6 = { 0x18, 0x0a, 0x77, '\\0', true, ENUM3}; // 以16进制输出MyStruct的内存分布 int32_t *temp3 = (int32_t*)&amp;s6; printf(\"%x\\n\", *temp3); printf(\"%zu\\n\", sizeof(struct MyStruct3)); // 输出4 // 输出结果是283ba98，换成2进制是 // (0000 00)10 1000 0011 1011 1010 1001 1000 // 然后再查看MyStruct中的位数，分别是2 1 4 8 5 6(从高到低). // 二进制前6位是 011000（0x18，对于a的赋值），6-11是 01010（0x0a，对应b的赋值） // 后面接0111 0111，是c的值（0x77）... // 我们看到int32_t能够放下所有的位，那么中间不会填充，只有高位填充到了4字节 匿名位域在C11标准中，当某个位域只给出其类型和宽度，而不给出标识符名时，该位域称为匿名位域。匿名位域一般用作比特填充（一般填充0） 当匿名位域的宽度为0的时候，表示该位域是前面位域所组成的存储区域的末尾，即左为一个结束标识而使用。该存储区域的后续比特被填充，其下面的位域都将作为一个新的存储区域。（意味着宽度为0的匿名位域可以强制结束位域存储区域）。 123456789101112131415161718struct { int32_t a : 8; // 该存储单元所在的整个区域后续都将用0填充 int32_t : 0; // int16_t : 0； // 存储单元缩小到2字节，后续填充0 // 放在下一个存储单元 int32_t b : 16; int16_t x : 8; int16_t y : 8; } t = { 0x10, 0x4321, 0x65, 0x76 }; // 输出：t is 0x7665432100000010 // 前面都是int32_t，所以第一个存储单元是4字节，除了第一个字节，后面都填充0 // 如果将int32_t:0改成int16_t:0那么只填充一个字节，因为单元是两个字节，同理改成int8_t，不填充 // 改成int64_t呢？发现后面4个字节也被填充0了，b、x、y被放到了后面的(a+8)byte的位置了 // 后面4个字节完全存满，位域刚好32bit printf(\"t is 0x%16llX\\n\", *((uint64_t*)&amp;t+1)); 通过观察发现，宽度为0的匿名位域，其数据类型的宽度是多少，就会填充多大的空间。如果其宽度比前面的存储单元宽度（上例是int32_t）大，那么将前面的存储单元扩大，并在后面填充0。如果小于存储单元宽度，那么将存储单元缩小（最小是位域宽度），并将缩小后的后续填充0。 位域使用在实践中，我们将需要拼接在一起的位域成员用相同类型或相同字节宽度的类型毗邻排放，这样可以避免一些不必要的比特填充。 1234567891011struct Student { uint32_t grade : 2; uint32_t class : 4; uint32_t number : 7; uint32_t weight : 7; uint32_t height : 8; uint32_t isMale : 1; uint32_t age : 3;}; 上面的示例中有两点： 都是用uint32_t，这样可以将存储单元设置成32位，使用4个字节就能够存下来所有的信息 因为4字节能够存下所有信息，所有bit都是相邻存放的，没有字节填充 这样利用位域可以做到bit控制（在计算机网络协议中尤其有用），同时节省空间。像java不支持位域，最小单位是byte，占1个字节，最少需要7个字节来存储。","link":"/2019/11/13/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/4.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E8%87%AA%E5%AE%9A%E4%B9%89%E7%B1%BB%E5%9E%8B/"},{"title":"6.C语言中的指针和数组","text":"本文首先学习C语言中的数组，再学习指针以及指针和数组的关系，再学习字符串字面量，最后学习C语言的完整类型和不完整类型。 数组和结构体一样，属于聚合类型。 一维数组形式：1&lt;类型名&gt; &lt;标识符&gt;[&lt;数组元素个数&gt;] 注意：C99之前，数组元素个数必须是一个整数常量表达式。C99之后可以是一个运行时计算的整数表达式。 如果数组元素个数是一个变量，那么该数组又称为变长数组。 注意：sizeof能正确计算数组的长度，但是是在运行时计算，不管是不是变长数组 访问数组元素使用：标识符[index]形式，例如arr[0]，index从0开始，表示访问数组的第一个元素。 注意：C语言的数组长度没有办法从数组中知道（除非自行用数组元素记录，不像js或者java有length数组。只能自己用额外的变量记录 数组对象可以使用{}初始化列表。如果初始化列表中的数量小于数组长度，那么剩余部分填充0。C99开始可以指定数组下表来初始化数组，如果没有指定，那么按顺序赋值。 通过 { [1] = 10.5f, [3] = 6.0 }这种形式可以对特定的下标赋值，未赋值的部分是0。这种形式和结构体还有联合体的成员赋值类似，区别是结构体使用{ .成员名 = 值 }的形式 初始化列表中的元素不仅仅可以是常量，还可以是运行时求值的表达式：int32_t b[] = { c[0], c[1], c[2] }。还注意到指定了初始化列表，可以不指定数组元素个数，数组元素个数会自动计算。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;complex.h&gt;#include &lt;stdint.h&gt;int main() { char c[2*2+1] = { 'a', 'b', 'c', 'd', 'e' }; for(int i = 0;i &lt; 5;i++) { printf(\"%c \", c[i]); if(i==4) printf(\"\\n\"); } // 可以添加额外的逗号，未赋值的部分置0 int32_t a[4] = { 100, -1, }; for(int i = 0;i &lt; 4;i++) { printf(\"%d \", a[i]); if(i == 3) printf(\"\\n\"); } // 对第二个和第四个元素赋值，其他为0 float f[5] = { [1] = 10.5f, [3] = -0.5f }; for(int i = 0;i &lt; 5;i++) { printf(\"%.2f \", f[i]); if(i == 4) printf(\"\\n\"); } // 这里注意几个点： // 1. 赋值默认从0开始，后面递增+1，所以s[0] = -1, s[1] = 2 // 2. 没有指定下标的元素，序号是上一个序号+1，所以s[5] = 20 // 赋值后的数组是[-1,2,0,10,1,50,5]; int16_t s[] = { -1, 2 ,[3] = 10, [6] = 5, [4] = 1, 20 }; for(int i = 0;i &lt; 7;i++) { printf(\"%d \", s[i]); if(i == 6) printf(\"\\n\"); } struct T { int32_t a, b; }; // 下面是一个更复杂的赋值示例，一个结构体数组的赋值 // 如果没有使用{}，列表中的值依次赋给结构体成员，下例中的10赋给[0].a，20赋给[0].b // 使用[1] = { 1, 2 } // 还可以结合使用[2] = { .a = -1, .b = -2 } // 还可以使用[3].a = 4, [3].b = 5 struct T t[] = { 10, 20, { 1, 2 }, [2] = { .a = -1, .b = -2}, [3].b = 4, [3].a = 5 }; for(int i = 0;i &lt; 4;i++) { printf(\"[%d]: %d %d\\n\", i, t[i].a, t[i].b); }} 注意点数组类型和其他类型不同，不能直接将一个数组对象直接赋值给另一个数组对象，即便初始化的时候也是这样。 结构体可以直接赋值，成员会自动拷贝，但是数组不可以。如果想引用数组，使用指针。如果想拷贝数组，可以使用&lt;string.h&gt;中的memcpy函数。 通过数组的字面复合量可以表示一个匿名数组，但是不能用于初始化，gcc下会报错。 memcpy(void dest, void source, size_t n)，从source地址拷贝到dest地址n个字节。看下面的例子：1234567891011121314151617181920212223#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;#include &lt;string.h&gt;int main() { int c[10] = { 0, 1, 2, [6] = 20, [8] = 100 }; int d[10]; // 注意，数组的标识符d、c可以当作一个指针，指针的值是d、c数组的起始地址 // 传给memcpy(d, c, sizeof(c))，会将指针值传过去，其值是地址，所以不需要在使用&amp;d memcpy(d, c, sizeof(c)); for(int i = 0;i &lt; 10;i++) { printf(\"%d \", d[i]); if(i == 9) printf(\"\\n\"); } // d的最后三位被设置成了7,9,8 memcpy(&amp;d[7], ((int []){7, 9, 8}), 3 * sizeof(int)); for(int i = 0;i &lt; 10;i++) { printf(\"%d \", d[i]); if(i == 9) printf(\"\\n\"); }} 多维数组形式如：int[2][3]表示含有两个int[3]类型的的数组。习惯上我们也称为两行散列的int类型元素的数组。 内存模型如下：1234567 -&gt; 0a -&gt; 0 -&gt; (int[3]) -&gt; 1 -&gt; 2 -&gt; 0 -&gt; 1 -&gt; (int[3]) -&gt; 1 -&gt; 2在内存中二维数组也是线性存放的，例如a[0][0] a[0][1] a[0][2] a[1][0]... 如果是int a[2][3][4]，表示两个int[3][4]型的数组。多维数组就是数组的元素还是数组。 sizeof也可以输出多维数组的大小。1234567891011121314151617181920212223242526272829303132333435363738394041424344#include &lt;stdio.h&gt;#include &lt;string.h&gt;void print_matrix(int a[][3], int n);int main() { // 数组初始化列表进行初始化 int a[2][3] = { { 1, 2, 3 }, { 4, 5, 6 } }; // 也可以扁平化的初始化 int b[2][3] = { 1,2,3,4,5,6 }; print_matrix(a, 2); // 2*3*4 = 24 printf(\"sizeof a is %zu\\n\", sizeof(a)); // 声明二维数组的时候并初始化的时候，第一个数组长度可以省略，但是第二个不行，如果想都省略，使用指针 int c[][3] = { [0] = { 1, 2, 3 }, [2] = { 4, 5 }, [3][0] = a[1][1], [3][2] = 7 }; print_matrix(c, 3); // 不能使用匿名数组初始化，gcc下会报错 // int e[][3] = (int[][3]) { // {1,2,3}, // [1] = {4,5,6}, // {7,9,9} // }; // print_matrix(e, 3);}void print_matrix(int a[][3], int n) { for(int i = 0;i &lt; n;i++) { for(int j = 0;j &lt; 3;j++) { printf(\"%d \", a[i][j]); } printf(\"\\n\"); }} 高维数组除了二维数组，还可以有三维、思维等等数组。具体能到多少维是实现定义的。 声明三维数组：int a[2][3][4]。 变长数组C99引入可变长数组。这类数组声明是不是通过常量来声明的，而是通过变量。有以下限制： 变长数组不能在文件作用域中声明 不能使用static修饰符来修饰 指向变长数组的指针以及变长数组统称为可变修改类型，该类型作为sizeof的操作数时，在运行时计算 变长数组声明后不能直接通过初始化列表初始化，只能通过memcpy或者逐个赋值 gcc 中const作为数组长度，也会当作变量 12345678910111213141516171819202122232425262728#include &lt;stdio.h&gt;int main() { int a = 5; int b[a]; a++; printf(\"b size is %zu\\n\", sizeof(b)); int x = 0; int (*p)[a] = &amp;b; printf(\"p[0] size is : %zu\\n\", sizeof(p[++x])); printf(\"x = %d\\n\", x); // x = 1，sizeof(p[++x])是可变类型，在运行时得到，有副作用 // gcc 中const作为数组长度，也会当作变量 // const int n = 10; // int d[n] = { 1, 2, 3 }; // int (*q)[n] = &amp;d; // x = 1，这里sizeof(b[++x])在编译时确定，没有副作用 printf(\"q[0] size is : %zu\\n\", sizeof(b[++x])); printf(\"x = %d\\n\", x);} 注意：如果sizeof是在编译时计算的，那么不会产生副作用，例如sizeof(b[++x])，即便b时可变类型，但是b[index]是int，不是可变类型，所以++x不会产生副作用。但是同样指向数组的指针会有副作用 一级指针与对象地址C中只要是一个存储对象，就能取地址。 通过&amp;来取地址，例如对于int a;，&amp;a表示取a的地址。无论在文件作用域还是语句块作用域中，都能取到地址。 在32位系统下拿到的地址是4字节，64位系统下拿到的是8字节。桌面程序中拿到的都是虚拟地址，而不是真实的物理地址，由操作系统和硬件负责将虚拟地址转成真实的物理地址，我们不需要关心。一些简单的嵌入式环境中可以拿到真实的地址。 C语言用指针来存储地址。使用int* p来声明指针，在正常变量声明前加一个*。需要注意，指针的长度就是地址的长度，32位系统下是4字节，64位系统下是8字节。那反正指针都是8字节，int* p和double* p有什么区别呢？区别在于如何解释所在地址的内容。指针存的只是一个起始地址，int *p表示指针指向的地址中，存的是一个int型的值，如果对指针取值，这时编译器会取起始地址到起始地址+4内存区间中的值并将其作为int类型返回。 123456789101112#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main(int argc, const char* argv[]) { int a = 10; int *p = &amp;a; // 一个指针对象可以转为一个无符号整数类型来观察该指针对象的值 // 不过一般用uintptr_t来表示一个对象地址的值 printf(\"p value is 0x%.16tX, size is: %zu\\n\", (uintptr_t)p, sizeof(p));} 我们指针的值是地址，但是我们只有将指针对象转为整数，一般是uintptr_t，才能正确看到地址的值。 访问指针对象所指对象的内容通过*可以间接访问指针指向地址中的值，例如*p。 1234567891011121314151617#include &lt;stdio.h&gt;#include &lt;stdint.h&gt;int main(int argc, const char* argv[]) { int a = 10; int *p = &amp;a; printf(\"a = %d\\n\", a); // a变成了20，因为p指向的是a的地址 // *p表示p指向的内存中的值，可以读写该值 *p = 20; short b = *p; *p = 10; // b拥有自己的地址，只是将a地址中的值赋值给了b，再改变a不影响b printf(\"b = %d\\n\", b);} 指针的比较和取地址指针的比较就是指针指向的地址值的比较，可以比较相等，比较大小。 指针类型之间的相互转换，必须强制转换，例如(int*)p，强制指针转换在读取值的时候可能会出现问题，例如原来是int*，转成long long*，指针取值的那么会多读内存中的4个字节，这可能导致地址空间溢出。 只能对左值取地址，而对于右值不能取地址。右值是一个表达式的值，例如sizeof返回的值，整数字面量等。 1234567891011121314151617181920212223242526#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;int main() { int32_t a = 10, b = 5; int32_t *p = &amp;a, *q = &amp;b, c = 0, *r = &amp;c; // 指针可以比较大小 bool e = p &gt; q; printf(\"Is p &gt; q? %d\\n\", e); e = p == r; printf(\"Is p equal to r? %d\\n\", e); printf(\"Is r equal to &amp;c? %d\\n\", r == &amp;c); int16_t s = 1, *t = &amp;s; t = &amp;a; // 这里会出现警告，因为指针不会隐式转换 t = (int16_t*)&amp;a; // 只能强制转换 *t = 2048; // 对于匿名数组，匿名结构体可以取地址 int32_t (*pa)[3] = &amp;(int32_t[]){1, 2, 3};} 多级指针多级指针用于表示指针的地址，例如：123int a = 10;int *p = &amp;a;int **pp = &amp;p;上例中，指针p存了a的地址，二级指针pp存了指针p的地址。那么我们取内容的时候，*pp拿到的是指针p的值，就是a的地址，**pp拿到是a的地址的值，就是10。地址指向关系如下：123456789101112131415161718192021222324252627282930地址 低-----&gt;高int a---------int*p--------int**pp----&gt; | | | | =p的地址----------- 求值 | |=a的地址--------- 求值 |求值 = 10```c#include &lt;stdio.h&gt;#include &lt;stdbool.h&gt;#include &lt;stdint.h&gt;int main() { int32_t x = 10, y = 20; int32_t *p = &amp;x, *q = &amp;y; int32_t **pp = &amp;p; // pp的值指向的内容是p的值也就是&amp;x bool b = (uintptr_t)*pp == (uintptr_t)&amp;x; printf(&quot;b = %d\\n&quot;, b); // *pp是指针p的值，赋值q，所以p == q *pp = q; printf(&quot;p == q? %d\\n&quot;, p == q); **pp = 30;// **pp是a的值，a的值变成了30} 指向用户自定义类型的指针指向用户自定义类型的指针和普通的指针差不多。只是变一下类型。需要注意的是对结构或者联合体成员的访问。 如果是指针，那么需要使用-&gt;来访问结构体成员。例如(s-&gt;a)，当然也可以使用(*p).a。 注意二级指针的使用，例如：1234struct S **pp = &amp;p;(*pp)-&gt;a = 10;(**pp).a = 10;不能直接使用pp-&gt;a。 数组和指针之间的关系C语言中数组可以隐式转换成指针。 C语言规定，除了sizeof、_Alignof、单目&amp;之外，表示数组类型的表达式会被转换成指针，而该表达式的值指向数组第一个元素的地址。 指针也能做整数加减法，但是和普通的加减法不一样，指针的加减法表示地址偏移，而且和类型相关。例如int* p，假设p指向的地址是a，那么p+1，指向地址a+4，因为int大小是4字节。 *(p+1)可以也写成p[1]。指针的偏移地址取值和数组类似。 指向数组的指针数组可以直接赋值给一个指针，例如：12int a[10];int *p = a;也可以使用指向数组的指针，如下：12int a[10];int (*pa)[10] = &amp;a;我们知道在这里数组a其实就是一个int的指针，那么对其取地址就是指针的指针了。要访问a的元素需要通过`(pa)[i]或者pa[0][i]`来访问。 那么int (*pa)[10]该怎么理解呢？指向数组的指针，也就是指针指向内容是一个数组，所以指针pa指向的是数组的地址，(*pa)是一个数组。如果要访问数组的内容，就需要使用(*pa)[i] int (*pa)[10]的类型是int(*)[10] 1234567891011121314151617181920212223242526272829303132333435363738394041#include &lt;stdio.h&gt;int main() { int a[] = { 1, 2, 3, 4, 5 }; int *p = a; int (*pa)[5] = &amp;a; printf(\"size of pa is: %zu\\n\", sizeof(pa)); // 输出8，因为pa是一个指针 printf(\"size of (*pa) = %zu, sizeof (*p) = %zu\\n\", sizeof(*pa), sizeof(*p)); // 输出(*pa) = 20 (*p) = 4 // 因为(*pa)是int[5]，而*p是int int sum = 0; for(int i = 0;i &lt; 5;i++) { sum += (*pa)[i]; // 括号不能省略 } printf(\"sum = %d\\n\", sum); int b[3][5] = { {1,2,3,4,5}, {6,7,8,9,10}, {11,12,13,14,15} }; // pa是指向数组的指针，所以(*pa)是指向b[0]，其值是一个数组 // *(pa+1)指向b[1]，其值也是一个数组 pa = b; pa[0][0]++; (*(pa+1))[0]--; // 表示p的类型是int (*)[2][3]，即指向二维数组的指针 int (*p)[2][3] = &amp;a; // 是一个指针，大小是8字节 int a = sizeof(int (*)[2][3]); // 表示p的类型是int (*)[2]，指向一维数组的指针 int (*p)[2];} 三种指针： 指向数组元素的指针：int *p = a，指针指向的是数组元素，类型是int * 指向数组的指针：int (*pa)[5] = &amp;a，指针指向的是数组，类型是int (*)[5]；指向二维数组的指针是int (*pa)[2][3]，类型是int (*)[2][3]。那么问题来了，指向数组的指针的数组呢？int (*pa[3])[2]，表示长度为3的成员类型为(int*)[2]的数组，类型是int(*[3])[2] 指针的数组：int* a[10]，是一个输出，数组元素是指针，类型是int*[10] void类型void一般用于函数返回类型以及空的表达式形参，也可以作为表达式的类型。 具有void类型的表达式称为void表达式，通过(void)expression，将表达式转为void类型。void表达式有以下规则： void表达式只能作为逗号表达式和三目运算符:左右两边的值，不能用于其他运算符 void表达式不能再被投射到其他类型 指向void类型的指针为void*，void*可以被隐式转换为指向任意对象的指针。指向任意对象的指针也能被隐式转换为void* NULL表示空指针。 字符数组和字符串字面量C99只有ASCII字符和宽字符，宽字符的编码是根据环境来定的，可能是GB2312编码、UTF-16编码等。宽字符使用wchar_t，再&lt;wchar.h&gt;头文件中定义。 C11引入了UTF-8、UTF-16、UTF-32编码，通过u8、u、U字符串前缀来使用。u&quot;abc&quot;是含有三个UTF-16编码的字符串，类型是char16_t[4]。char16_t和char32_t在&lt;uchar.h&gt;中定义。 字符串字面量末尾会自动加上'\\0'。如果”abc”占4个字节，分配空间的时候要注意多分配一个字节。 C语言相邻的相同编码的字符串字面量会进行拼接，例如：12char* a = \"aaaaa\" \"bbb\" \"cccc\";等价于a = &quot;aaaaabbbcccc&quot;。 完整类型和不完整类型C语言中的类型分为：对象类型和函数类型。 不完整类型指缺乏足够的信息取判定该类型所声明对象的大小。 例如： void表达式就是不完整类型，因为不知道对象的大小。 只含有枚举、结构体、联合体的声明，没有定义也是不完整类型。定义了之后变成完整类型 结构体中最后不指定大小的数组对象也是不完整类型 不完整类型不能作为sizeof和_Alignof的操作数。 灵活的数组成员在至少含一个对象的结构体中，最后一个成员可以是不完整类型，该成员被称为灵活的数组成员。 灵活的数组成员不计算大小，但是会影响字节填充。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849#include &lt;stdio.h&gt;#include &lt;stddef.h&gt;#include &lt;stdint.h&gt;#include &lt;stdlib.h&gt;int main(int argc, const char* argv[]) { struct Test1 { int8_t b; // 灵活的数组成员，影响字节填充 double d[]; }; size_t offset = offsetof(struct Test1, d); // 偏移量和结构体大小一样，是8字节 printf(\"offset of is : %zu\\n\", offset); printf(\"size of is : %zu\\n\", sizeof(struct Test1)); struct Test2 { int a; int array[]; }; // 因为按照4字节对齐（如果是double array[]）就按照8字节对齐 printf(\"size of struct2 is %zu\\n\", sizeof(struct Test2)); struct Test2 ts[] = { {10}, {20}, {30} }; // 灵活的数组成员没有大小，地址是结构体的结束的下一个字节 // 这里相当于(int*)&amp;ts[2]，(int*)&amp;ts[3] // 取到的值是20和30 int sum = ts[0].array[0] + ts[1].array[0]; printf(\"sum = %d\\n\", sum); // 灵活的数组成员还有一种方式就是对结构体做动态内存分配 // 动态分配的结构体之后的内存将给灵活数组成员 struct Test2 *pt = malloc(sizeof(*pt) + sizeof(int[sum])); for(int i = 0;i &lt; sum;i++) { pt-&gt;array[i] = i + 1.0; } pt-&gt;a = 100; int result = pt-&gt;a; printf(\"result is %d\\n\", result); for(int i = 0;i &lt; sum;i++) { printf(\"%d \", pt-&gt;array[i]); } printf(\"\\n\");} 要点： 灵活数组成员的起始地址是结构体结束的下一个字节 灵活数组成员可用于对结构体做动态内存分配","link":"/2019/11/18/c-c++/C%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6/6.C%E8%AF%AD%E8%A8%80%E4%B8%AD%E7%9A%84%E6%8C%87%E9%92%88%E5%92%8C%E6%95%B0%E7%BB%84/"},{"title":"leetcode题解：Merge Two Binary Trees","text":"问题描述Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not. You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree. Example 1:1234567891011121314Input: Tree 1 Tree 2 1 2 / \\ / \\ 3 2 1 3 / \\ \\ 5 4 7 Output: Merged tree: 3 / \\ 4 5 / \\ \\ 5 4 7 Note: The merging process must start from the root nodes of both trees. 问题解析这个题的要求是：给定两棵树，然后将这两棵树重叠，两个非空的重叠的节点的值相加作为新节点的值，一个空一个不空的重叠的节点，不空的直接覆盖空的。 我们很容易想到，同时深度优先遍历两颗二叉树，即两个树中每次遍历的节点在树中的位置相同。如果两个节点非空，直接相加作为新的重合节点。在遍历时，可以以一棵树为基准，例如就遍历左边的树。那如果遇到了左边子树为空，右边子树不空的情况呢？需要再遍历右边的子树吗？当然不用，直接将右边的子树拿过来就可以了。 所以遍历的时候，以其中一棵树为基准，只有两个树相同位置的节点都不为空时继续遍历。同时也不同新建一个树来存储，可以直接将结果放在基准树中。 这里可以采用前序遍历，有递归和非递归两种形式，下面分别给出代码： 递归形式：1234567891011121314var mergeTrees = function(t1, t2) { return recursive(t1,t2);};function recursive(t1, t2) { if(t1 &amp;&amp; t2) { t1.val = t1.val + t2.val; t1.left = recursive(t1.left, t2.left); t1.right = recursive(t1.right, t2.right); return t1; } else { return t1 || t2; }}注意递归形式中，递归处理左子树和右子树，当其中一个节点为空时，直接返回非空节点即可。 非递归形式：12345678910111213141516171819202122232425var mergeTrees = function(t1, t2) { var stack = [], h = t1 || t2,p = []; while(true) { if(t1 &amp;&amp; t2) { stack.push([t1,t2]); t1.val = t1.val + t2.val p[0] = t1; t1 = t1.left; t2 = t2.left; } else { // 如果左边为空，并且有父节点，将右边相同位置的节点直接赋过来 if(!t1 &amp;&amp; p[0]) { // 需要判断处理的是父节点的左子树还是右子树 if(stack.length &amp;&amp; stack[stack.length-1][0] == p[0]) p[0].left = t2; else p[0].right = t2; } // 出栈，访问右子树 if(stack.length) { p = stack.pop(); t1 = p[0].right;t2 = p[1].right; } else if(!stack.length) break; } } return h;};注意非递归形式我们要记住父节点，同时要判断当前处理的是父节点的左子节点还是右子节点。","link":"/2019/12/13/algorithm/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9AMerge-Two-Binary-Trees/"},{"title":"二叉树的层级遍历","text":"要求给定一颗二叉树，给出其节点值的每一层的结果。示例：12345 3 / \\9 20 / \\ 15 7可以得到：12345[ [3], [9,20], [15,7]] 思路二叉树的遍历有两种，一种是深度优先（先序，中序，后序），另一种是广度优先。在层级遍历的场景下，我们肯定是使用广度优先遍历，因为这样才能保证在处理下级的节点时，所有上级的节点已被被遍历。 广度优先遍历是利用队列来实现的，具体思路是，先将根结点入队；然后将根结点出队，将根结点的所有子节点入队。然后依次取出子节点，做相同的处理。 我们要实现层级遍历取出每一层的结果，核心问题就是要记录每一层有多少节点数。具体的方法是：利用两个变量，一个记录当前层的剩余节点数，另一个统计下一层的子节点的总数。每处理一个当前层的节点，将当前剩余节点数减1，如果减到了0，则说明当前层处理完毕，将子节点总数赋值给当前层，然后将子节点总数置0，一切从头开始。 javascript代码实现123456789101112131415161718192021222324252627var levelOrder = function(root) { var queue = []; if(root == null) return []; queue.push(root); var tempLevel = [],tempRest = 1, childNums = 0; var res = []; while(!queue.length==0) { var node = queue.shift(); tempLevel.push(node.val); tempRest--; if(node.left) { queue.push(node.left); childNums++; } if(node.right) { queue.push(node.right); childNums++; } if(tempRest == 0) { tempRest = childNums; childNums = 0; res.push([].concat(tempLevel)); tempLevel = []; } } return res;};","link":"/2019/06/22/algorithm/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B1%82%E7%BA%A7%E9%81%8D%E5%8E%86/"},{"title":"数据结构基础：根据先序、中序遍历结果构造二叉树","text":"要求给定一个二叉树的前序遍历和中序遍历结果，构造出这颗二叉树： 例如：输入： preorder = [3,9,20,15,7]inorder = [9,3,15,20,7] 输出：12345 3 / \\9 20 / \\ 15 7 解题思路由先序遍历，我们可以确定树根。在上例中，3是先序遍历的第一个结果，所以3肯定是树根；然后再中序遍历的结果中找到3，在3的左边的肯定是根的左子树，在3的右边的肯定是根的右子树。 这样我们就将中序遍历的结果分成三个部分，3的左边（左子树）、3（根）、3的右边（右子树），然后对左右递归处理，递归的结果返回左右子树的根，然后根结点连接左右节点的根就得到结果了。 大致的思路有了，接下来我们深入细节。当我们向左右递归的时候，怎么知道左右子树的根呢？还是要回到先序遍历，我们已经知道左子树和右子树了，我们根据先序遍历的特点——在前面的结果在树中的位置肯定是靠左的——也就是说左子树的先序遍历结果肯定在右子树先序遍历结果的前面。 通过上面的分析，我们的思路就清楚的了，构造步骤如下： 取出先序遍历的结果中未使用的第一个节点作为根 在中序遍历的结果中查找上一步得到的根，然后以改根为支点，将中序遍历的结果分成左右两部分，分别对应左子树和右子树 用上一步得到的结果，将先序遍历的结果分成左右两部分，具体操作是：得到上一步左边部分的长度，在先序遍历的结果中截取相同的长度——左子树的先序遍历结果，然后右边做相同的操作 将左右递归处理，回到第一步 以上面的例子来执行该算法： 拿先序遍历的第一个结果，得到根：3 在中序遍历的结果中搜索3，将中序遍历的结果：[9,3,15,20,7]，分成左右两个部分：[9]，[15,20,7] 将先序遍历的结果：[3,9,20,15,7]，也分成左右两个部分（不包括3了，已经处理过的就不再处理）：[9]，[20,15,7]。现在我们得到的结果看起来向下面这样：123 3 / \\9 20,15,7 然后我们对左右分别递归，先拿到左递归的根——取先序遍历中的左边的结果：[9]中的第一个节点9，所有左子树的根就是9，处理中序遍历的左边结果：[9]，发现只有一个节点，直接返回该节点。 然后递归右子树，先拿到右递归的根——取先序比阿尼中有边的结果：[20,15,7]中的第一个节点20，所有右子树的根就是20，现在得到的结果看起来向下面这样：12345 3 / \\9 20 | 15，7 (15，7是20的左右子树，但是现在还不确定谁是左谁是右，需要下一步来确定) 回到第二步，在中序遍历的结果中搜索20，得到左右子树[15]、[7]，此时我们就得到了完整的二叉树：12345 3 / \\9 20 / \\ 15 7 javascript代码实现看到这里应该完整的理解了构造过程了吧～接下来上代码，使用javascript：1234567891011121314151617181920212223242526272829303132/*** preleft，preright是preorder的左右边界，left和right是inorder的左右边界，因为左右子树在两个遍历结果中的位置不同，所以要区分*/function construct(preorderResult,inorderResult,preleft,preright,left,right) { if(right-left &lt;= 1) return { val: preorderResult[preleft], left: null, right: null } // 取根结点 var troot = preorderResult[preleft]; // 找到根结点在中序遍历结果中的位置 var trootIndexInorder = inorderResult.indexOf(troot); var lchild=null,rchild=null; // 确定左子树的节点数量 var llength = trootIndexInorder-left; // 确定先序遍历结果中左右子树的边界 var tpreright = preleft+1+llength; // 下面的两个if处理边界条件，至少有一个节点时才递归处理 if(trootIndexInorder &gt; left) { lchild = construct(preorderResult,inorderResult,preleft+1,tpreright,left,trootIndexInorder); } if(trootIndexInorder+1 &lt; right) { rchild = construct(preorderResult,inorderResult,tpreright,preorderResult.length,trootIndexInorder+1,right); } // 返回根结点和左右子树 return { val: troot, left: lchild, right: rchild }} 扩展思考那现在假如已知中序遍历和后续遍历的结果，要构造二叉树怎么办呢？是不是也可以用类似的思路解决这个问题呢呢？其实思路和前面的是一样，只是要结合后序遍历的特点（与前序相反，根结点在结果的最后面），我这里就只给代码了，如果前面的理解了，这个so easy了。javascript:12345678910111213141516171819202122232425function construct(inorder, postorder, inleft,inright,postleft,postright) { if(inright - inleft &lt;= 1) { return { val: postorder[postright-1], left: null, right: null } } var troot = postorder[postright-1]; var trootInorderIndex = inorder.indexOf(troot); var lchild = null, rchild = null; var rlength = inright-1-trootInorderIndex; var tpostright = postright-1-rlength; if(trootInorderIndex &gt; inleft) { lchild = construct(inorder,postorder,inleft,trootInorderIndex,0,tpostright) } if(trootInorderIndex+1 &lt; inright) { rchild = construct(inorder,postorder,trootInorderIndex+1,inright,tpostright,postright-1); } return { val: troot, left: lchild, right: rchild }}","link":"/2019/06/21/algorithm/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E7%94%B1%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86%E7%BB%93%E6%9E%9C%E6%9E%84%E9%80%A0%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"title":"maximum product subarray","text":"问题描述给定一个整数数组nums，找到数组内有最大乘积的最大连续子数组。 例如：123输入：[2,3,-2,4]输出：62*3 = 6 题解这道题是典型的分治问题。类似的问题还有最大连续子数组的最大和。思路就是将数组分成左右两个部分，对左右分别求出最大值，然后求出合并之后的最大值，取三者之中的最大值。 分治问题的难点在于如何“合”，如果“分”的时间复杂度和“合”的时间复杂度均为O(n)及以下，那么分治算法的总时间复杂度为O(nlogn)。在这道题里面，积的特点是负数乘负数能够得到正数，与求和的问题不同。所以“合”的时候要注意两个要点： 分成左右两部分，对左边从右到左求乘积，记录最大值和最小值；对右边从左到右求乘积，记录最大值和最小值 最大积就是左右最大值最小值组合相乘的四种情况中的最大值，因为可能有“负负得正”的情况，就把可能的情况都算了一下 代码：12345678910111213141516171819202122232425262728function recursive(left, right, nums) { if (right - left === 1) return nums[left]; // +1是为了统一数组项奇数个数和偶数个数的情况（不加1也可以，个人习惯），例如(4+1)/2=2，(3+1)/2=2， var center = Math.floor((left+right+1)/2); var lv = recursive(left, center, nums); var rv = recursive(center, right, nums); var min = Number.MAX_VALUE, max = Number.MIN_VALUE, prod = nums[center-1]; for (var i = center - 2;i &gt;= left;i--) { prod *= nums[i]; if (prod &gt; max) max = prod; if (prod &lt; min) min = prod; if (prod === 0) break; // 0 * any = 0 } var rmin = Number.MAX_VALUE, rmax = Number.MIN_VALUE, rprod = nums[center]; for (var i = center + 1;i &lt; right;i++) { prod *= nums[i]; if (prod &gt; max) max = prod; if (prod &lt; min) min = prod; if (prod === 0) break; // 0 * any = 0 } var tmax = min * rmin; if (min * rmax &gt; tmax) tmax = min * rmax; if (max * rmin &gt; tmax) tmax = max * rmin; if (max * rmax &gt; tmax) tmax = max * rmax; return Math.max(lv, rv, tmax);} 动态规划解法这道题除了能使用分治之外，还可以使用动态规划来解。假定状态dp[i]表示[0…i]的最大连续子数组积的最大值，dp[i]如何和dp[i-1]或者其他已知的状态联系起来呢？这样其实不太好联系起来。 可以将状态dp[i]定义成以乘积包含nums[i]的子数组的积的最大值，那状态转移方程为dp[i]=max(nums[i], dp[i-1]*nums[i], min[i-1]*nums[i]，注意到还有min，因为可能存在负数的情况，所以要还要定义最小值状态。所以最终状态转移方程就是： dpmax[i]=max(nums[i], dpmax[i-1]*nums[i], dpmin[i-1]*nums[i]) dpmin[i]=min(nums[i], dpmax[i-1]*nums[i], dpmin[i-1]*nums[i]) 涵盖的情况有两种： nums[i]符号和前一个结果异号，那么最大或最小值其实就是该值自身 如果同号，可能是正也可能是负，都计算一下然后取最大值/最小值 代码：123456789101112var maxProduct = function(nums) { var n = nums.length; var pmin = nums[0], pmax = nums[0], max = nums[0]; var max = nums[0]; for (var i = 0;i &lt; n;i++) { var tm = pmax * nums[i], tmin = pmin * nums[i]; pmax = Math.max(nums[i], tm, tmin); pmin = Math.max(nums[i], tm, tmin); max = Math.max(max, pmax); } return max;}因为只需要前一个状态，所以可以只前一个状态的值，而不需要一个数组了。时间复杂度O(n)，空间复杂度O(1)。神奇的是，leetcode上，执行时间比O(nlogn)的分治算法长，不知道为什么。 扩展思考那如果是求最大和，动态规划怎么解呢？dp[i]=max(dp[i-1]+nums[i], nums[i])","link":"/2020/05/17/algorithm/leetcode/%E5%88%86%E6%B2%BB/maximum-product-subarray/"},{"title":"Wildcard Matching","text":"问题描述通配符模式匹配问题，给定一个字符串s和模式字符串p，判断s是否匹配p。其中s由s-z之间的任意小写字符组成，p由s-z之间的任意小写字符以及*和？组成。 *表示匹配任意长度的字符串，长度为0；?表示匹配长度为1的字符串。 例如:12345678输入: s=&quot;aa&quot; p=&quot;a&quot;输出: false输入: s=&quot;ba&quot; p=&quot;?a&quot;输入: true输入: s=&quot;aa&quot; p=&quot;*&quot;输出: true 题解看到通配符匹配的问题第一反应肯定是用有限状态机来解决，由通配符表达式生成有限状态机。将输入字符串和有限状态机去比对，看是否符合。 但在这个问题中，比较简单，不需要有限状态机那么复杂的判断方式，首先可以考虑用动态规划解，然后再考虑其他的算法。 动态规划解法首先尝试将(i,j)定义为串s[0…i]和p[0…j]是否匹配，那么状态转移方程为(i+1, j) = p[j]=='*' &amp;&amp; (i,j)，(i,j+1)=p[j+1]=='*' &amp;&amp; (i,j)，(i+1,j+1) = s[i+1]==p[j+1] || p[j+1]=='*' || p[j+1]=='?'。状态初始状态(0,0)的值=s[0]==p[0] || p[0]==? || p[0]==*，边界条件，p.length == 0, s.length==0, false;代码如下： 123456789101112131415161718192021222324252627282930function judge(s, p) { if (p.length == 0 &amp;&amp; s.length == 0) return true; else if(p.length == 0) return false; if (s.length == 0) { for (var i = 0;i &lt; p.length;i++) { if (p[i] != '*') return false; } return true; } var status = [] for (var i = 0; i &lt; s.length; i++) status[i] = []; status[0][0] = (s[0] == p[0]) || (p[0] == '?') || (p[0] == '*'); var matched = status[0][0] &amp;&amp; (p[0]!='*'); for (var j = 1; j &lt; p.length; j++) { var c1 = (p[j] == '*') &amp;&amp; status[0][j - 1]; var c2 = ((s[0] == p[j])||(p[j]=='?')) &amp;&amp; status[0][j-1]&amp;&amp;!matched; if (c2 &amp;&amp; !matched) matched = true; status[0][j] = c1 || c2; } for (var i = 1; i &lt; s.length; i++) status[i][0] = (p[0] == '*'); for (var i = 1; i &lt; s.length; i++) { for (var j = 1; j &lt; p.length; j++) { var c1 = status[i][j - 1] &amp;&amp; (p[j] == '*'); var c2 = status[i - 1][j] &amp;&amp; (p[j] == '*'); var c3 = status[i - 1][j - 1] &amp;&amp; ((s[i] == p[j]) || (p[j] == '*') || (p[j] == '?')); status[i][j] = c1 || c2 || c3; } } return status[s.length - 1][p.length - 1];} 上面给的递推方程是思路，实际上都是用减法的方程，由i-1推出i这种形式，代码中也是这样处理的。注意边界，status[0][j]和status[i][0]这个边界条件要计算好。尤其是计算status[0][j]，这里引入了matched来表示s[0]是否被匹配过了，因为使用递推的方式没有办法解决类似s='a'，p='*?*?'这样的问题。 该算法的时间复杂度是O(n2)。 贪心+回溯算法尽可能多的匹配，例如`aa和aaaa，会先找到最后一个a，发现模式还剩a`没有匹配，回溯上一个a，匹配，发现匹配失败，再回溯一个a，知道匹配成功。这样的时间复杂度最差情况下是O(n!)，可以通过优化一下判断条件来优化时间。","link":"/2020/05/09/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Wildcard-Matching/"},{"title":"二叉树的非递归遍历","text":"二叉树有两种遍历方式，一种是深度优先，一种是广度优先。深度优先一般采用递归，广度优先一般采用队列来实现。但是深度优先也可以使用非递归算法来遍历，这篇文章分析二叉树的非递归遍历算法，包括前序、中序、后序三种遍历方式。 前序遍历二叉树的前序遍历规则是：根-&gt;左-&gt;右，先访问根，在遍历左子树，然后是右子树。递归形式的写法如下:123456traverse(root): if root is null then return else: visit root traverse(root.left) traverse(root.right)从上面的伪代码中我们分析几个关键点：当前根结点:root；判断条件:是否为空；先访问根节点，再访问左右节点。递归遍历会有堆栈信息，能够知道函数返回后的上下文，非递归遍历我们需要自己使用栈来存下这些信息。接下来我们根据这几个条件给出非递归遍历算法的伪代码：123456789101112none-recursive-traverse(root) curr = root and stack = [] while(true) if curr == null if stack is empty traverse end else curr = stack.pop().right else visit curr stack.push(curr) curr = curr.left流程图如下：1234567891011121314 start | curr = root stack = [] | ||-&gt; curr null? ---&gt; stack empty? ---&gt; traverse end| | no yes |no yes| | || visit curr curr = stack.pop().right| stack.push(curr) |--- curr = curr.left || ||______________________|可以看到我们先判断curr是不是空，如果是空，那么说明走到叶子节点了，这时候可能遍历结束了，可能还没有；根据栈是否为空来判断，如果栈不空，那么肯定是访问完左子树或者右子树返回了，只要取栈顶的节点的右孩子，因为访问完左子树栈顶节点是根结点，下一个访问右节点；访问完右子树栈顶节点是祖父节点，下一个访问父节点的兄弟节点。 这里不关心是从左子树返回还是右子树返回，因为根结点在最开始访问了，而且访问右子树的时候根结点已经出栈了，从右子树返回的时候访问的访问的是祖父节点。在后序遍历的时候会关心到底是从左子树返回的还是右子树返回了，因为只有右子树返回的时候才访问根结点。 如果栈空，说明全部访问结束了。 代码实现：123456789101112function preorder(root) { var curr = root, stack = []; while(true) { if(curr != null) { console.log(curr.value); stack.push(curr); curr = curr.left; } else if(stack.length) { curr = stack.pop().right; } else return; }} 中序遍历中序遍历和前序遍历最大的区别是，根结点在访问完左节点之后，访问右节点之前。在上面的流程图中，访问左子树结束，右子树开始之前的位置很明显，在curr = stack.pop().right之前访问根结点即可。修改后的流程图如下：123456789101112131415 start | curr = root stack = [] | ||-&gt; curr null? ---&gt; stack empty? ---&gt; traverse end| | no yes |no yes| | || stack.push(curr) |--- curr = curr.left curr = stack.pop()| visit curr| curr = curr.right| ||______________________| 后序遍历后序遍历比前面复杂的地方在，要区分是从左子树返回还是从右子树返回，如果是从右子树返回，才访问根结点。在上面的流程图中，我们第一次回到根结点的时候就将根结点出栈然后访问右子树，在后序遍历时，我们只有访问完了右子树才能将根结点出栈。所以我们要加一个标识，标识是访问完左子树还是右子树。 修改后的流程图如下：123456789101112131415161718 start | curr = root stack = [] | ||-&gt; curr null? -------------&gt; stack empty? ---&gt; traverse end| | no yes | |no yes| | | || stack.push(curr,1) | stack top is 1?--- curr = curr.left | || | no / \\yes| | / \\| |__pop stk set top 2 | and visit curr = top.right| curr | ||____________________________________|或者使用另一种方式，当前访问的节点肯定是栈顶节点的子节点，这样可以用判断当前节点是左子树还是右子树来得到。 练习leetcode 226. Invert Binary Tree反转二叉树，使用后序遍历，先反转左右子树，然后返回根结点的左右孩子。代码如下：1234567891011121314151617181920212223242526272829303132333435363738/** * Definition for a binary tree node. * function TreeNode(val) { * this.val = val; * this.left = this.right = null; * } *//** * @param {TreeNode} root * @return {TreeNode} */var invertTree = function(root) { var stack = [], curr = root; l1:while(true) { if(curr == null) { while(true) { if(stack.length === 0) break l1; else { var top = stack[stack.length - 1]; if(top[1]== 1) { top[1] = 2; curr = top[0].right; break; } else { curr = stack.pop()[0]; var t = curr.left; curr.left = curr.right; curr.right = t; } } } } else { stack.push([curr,1]); curr = curr.left; } } return root;};","link":"/2019/11/07/algorithm/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%9D%9E%E9%80%92%E5%BD%92%E9%81%8D%E5%8E%86/"},{"title":"Longest Valid Parentheses","text":"问题描述给定一个包含”(“和”)”的字符串，找到最长的合法括号子串，例如：12345输入：&quot;(()&quot;输出：2输入：&quot;)()())&quot;输出：4 题解这个问题需要找到一个括号串的最长合法括号子串。需要解决几个关键的问题： 怎么知道一个子串是不是合法子串？ 怎么找到最长的子串？ 枚举法解决了这两个问题，那么这个问题就解决了。一个最简单的解法就是，枚举所有可能的子串，然后判断该子串是不是合法的括号子串，如果是，更新最大值。判断一个子串是不是合法可以用栈来实现，遍历子串，遇到”(“就入栈，遇到”)”就出栈，并判断出栈的是不是”(“，不是则不合法，遍历完成后，判断以下栈是否为空，为空说明子串合法。 这种解法的事件复杂度是O(n3)，枚举子串的事件复杂度是O(n2)，因为子串需要用(i,j)来表示，枚举i和j的事件复杂度是n*n。判断子串是否合法的事件复杂度是O(n)，因为要遍历一遍子串。代码：1234567891011121314151617181920212223242526var longestValidParentheses = function(s) { var i = 0, j = i + 1, len = s.length, max = 0; for(;i &lt; len;i++) { for(j = i+1;j &lt;= len;j++) { var substr = substring(i, j); if (isValid(substr)) { if (substr.length &gt; max) max = substr.length; } } } return max;}function isValid(s) { if (s.length % 2 != 0) return false; var stack = []; for (var i = 0;i &lt; s.length;i++) { var c = s.charAt(i); if (c == '(') stack.push(c); else { if (stack.length == 0) return false; var pc = stack.pop(); if (pc != '(') return false; } } return stack.length == 0;} 动态规划枚举法可以给出正确的解，但是时间复杂度太高了，提交枚举代码后直接超时了。接下来就是想一想怎么优化了，是不是可以考虑动态规划呢，动态规划的核心是状态和状态转移方程，能不能根据已有状态来推断出下一个状态呢？这样就可以节省很多计算时间。动态规划需要解决两个问题： 状态是什么，怎么定义这个状态？ 状态如何转移？串和子串的状态怎么联系起来？ 定义状态i表示以i位置结尾的最长合法子串，d[i]表示以i结尾的合法串的最大长度，一个合法的串最后一个字符肯定是”)”，如果不是则d[i]一定为0，所以只需要考虑s[i]==’)’的情况。如果s[i-1]==’(‘，那么d[i]=d[i-2]+2；如果s[i-1]==’)’，串形如”…))”，如果s[i-d[i-1]-1]==’(‘，那么肯定符合，因为d[i-1]如果不为0，那s[i-d[i-1]-1…i-1]这个子串是合法的，所以d[i]=d[i-1]+d[i-d[i-1]-2]+2; 初始情况，d[0]=0，如果s[0..1]=”()”则d[1]=2，否则等于0。d[2]开始就可以递推了。代码如下：123456789101112131415161718var longestValidParentheses = function(s) { var d = [0]; if (s[0] == '(' &amp;&amp; s[1] == ')') d[1] = 2; else d[1] = 0; var max = d[1]; for (var i = 2;i &lt; s.lenth;i++){ if (s[i] == '(') d[i] = 0; else if (s[i-1] == '(') d[i] = d[i-2] + 2; else if (s[i-1] == ')' &amp;&amp; s[i-d[i-1]-1] == '(') { if (i-d[i-1]-2 &gt;= 0) d[i] = d[i-1] + d[i-d[i-1]-2] + 2; else d[i] = d[i-1] + 2; } if (d[i] &gt; max) max = d[i]; } return max;} 动态规划解题要点：动态规划最重要的是状态的定义和状态转移方程，同一个问题可能有多种状态定义方式和多种状态转移方程都能得到正确的结果。解动态规划问题，最重要的是先找到状态，这个题中，状态的第一思路可能是(i,j)代表始末位置为(i,j)的子串的最大合法子串的长度，但是这个状态就不好递推了。或者是(i,j)代表以始末位置为(i,j)的子串是否合法，如果合法值就为该子串的长度，否则为0。如果(i,j)合法，则'('+(i,j)+')'也合法，但是还有一种情形就不好判断了，例如()()，模式为xx（x表示合法子串），因为无法知道相邻的子串的是否合法以及最大多少合法。所以这种状态设计方案没有解决最大的问题，而且用(i,j)来标识状态求解的时间复杂度为O(n2)。那能不能用一维的状态来表示呢？例如i表示以i结尾的最大合法子串的长度，那这样就知道以i结尾的串是否合法，并可以解决形如xx的问题。当遇到动态规划问题的时候可以按照1维到2维这样状态定义顺序来设计状态和状态转移。 栈可以考虑用栈来解决这个问题，且时间复杂度为O(n)，空间复杂度为O(n)。栈可以判断一个子串是不是合法的，可以从头到尾遍历一遍字符串，遍及每一个字符的时候都使用栈判断当前是否合法，栈长度为0时更新一下最大值。遍历的时候如果遇到非法的，清空栈，从非法字符开始重新计数。因为如果一个部分是非法的，那么所有包含该部分（完全包含或者有交集）的串都是非法的。代码如下：12345678910111213141516171819202122var longestValidParentheses = function(s) { var stack = [], max = 0, tcount = 0; for (var i = 0; i &lt; s.length; i++) { if (s[i] == '(') stack.push(i); else { if (stack.length == 0) tcount = 0; else { stack.pop(); tcount += 2; if (stack.length == 0) max = tcount; } } } var tlength = s.length; while (stack.length &gt; 0) { var lastlp = stack.pop(); tcount = tlength - lastlp - 1; tlength = lastlp; if (tcount &gt; max) max = tcount; } return max;}这里栈的思想类似于俄罗斯方块消去的思想，遇到匹配的”()”就会被消去，当遇到’(‘入栈，遇到’)’出栈，出栈相当于消去。子串消去的时候有三种情况： 到i结尾的子串的结尾字符s[i]==’)’，且刚好消去(stack.length == 1)，此时肯定有满足的子串，判断子串的长度并更新最大值 到i结尾的子串的结尾字符s[i]==’)’，且栈已经为空(stack.length == 0)，包含s[i]的串肯定不是合法串，清空计数。 到i结尾的子串的结尾字符s[i]==’(‘，入栈s[i]。遍历一遍字符完成消去之后，栈中如果还剩下了’(’，则这些’(‘之间被消去的空洞就是合法的子串，比较这些子串的长度并更新最大值。 两次遍历上一部分的消去思想起始可以进一步总结，消去之后，剩下的子串只可能有三种情况，1.全是’(‘，2.全是’)’，3.前面是若干’)’后面是若干’(‘。 假定从左到右遍历字符串，遇到’(‘计数+1，遇到’)’计数减1，减到0的时候更新一下最大值。多于的’)’直接跳过，肯定不合法。这样就不需要栈了，只需要两个变量——一个记录消去计数、一个记录当前合法子串的起始位置。这样可以解决2、3中’)’的问题，但是多于的’(‘没法判断，例如(((())这种情况。解决方案也很简单，对称的思想，从右向左再遍历一遍，将规则反一下，然后更新最大值。代码如下： 12345678910111213141516171819202122232425var longestValidParentheses = function(s) { var count = 0, start = -1, i = 0, max = 0; function traverse(tcondif, tincf, tlenf, c) { for(;tcondif(i);tincf()) { if (s[i] == c) { count++; if (start == -1) start = i; } else { count--; if (count == 0) { // var len = i - start + 1; var len = tlenf(i); if (len &gt; max) max = len; } else if (count &lt; 0) { start = -1; count = 0; } } } } traverse(i=&gt;i&lt;s.length,()=&gt;i++,i=&gt;i-start+1,'('); count = 0, start = -1, i = s.length - 1; traverse(i=&gt;i&gt;=0,()=&gt;i--,i=&gt;start-i+1,')'); return max;}","link":"/2020/05/07/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/Longest-Valid-Parentheses/"},{"title":"decode-ways","text":"问题描述假设字符到数字的匹配是：1234A =&gt; 1B =&gt; 2...Z =&gt; 26问题：给定一个数字序列，由字符串编码得到该数字序列的方法的个数。 例如：1234输入： &quot;12&quot;输出： &quot;2&quot;A =&gt; 1 b=&gt;2，或者L =&gt; 12，两种编码方式都可以得到&quot;12&quot; 题解使用动态规划来解，因为对于字符串s[0…i]，其总数可以由s[0…i-1]和s[0…i-2]推出来。 状态定义：状态i表示字符串s[0…i]可能的解码方法数状态转移方程：dp[i] = (s[i]!=0?dp[i-1]:0) + (s[i-1]!=0&amp;&amp;s[i-2…i]&lt;=26?dp[i-2]:0)。思考方式是，s[0...i-1] + 非零字符是一种方式，s[0...i-2] + 大于9的数字是另一种方式，满足的话将这两种情况夹起来就可以。 代码：123456789101112var numDecodings = function(s) { if (s.length == 0) return 0; var dp = []; dp[0] = s[0]!=0?1:0; if (s.length &gt;= 1) { dp[1] = (s[1]!=0?dp[0]:0) + ((Number(s[0]+s[1])&gt;=10&amp;&amp;Number(s[0+s[1]])&lt;=26)?1:0); for (var i = 2;i &lt; s.length;i++) { dp[i] = (s[i]!=0?dp[i-1]:0) + ((Number(s[i-1]+s[i])&gt;=10&amp;&amp;Number(s[i-1+s[1]])&lt;=26)?dp[i-2]:0); } } return dp[s.length-1];}","link":"/2020/05/11/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/decode-ways/"},{"title":"triangle","text":"问题描述给定一个三角形数字矩阵，找到该矩阵从上到下的最小路径和。每一步只能找相邻的路径。例如12345678910输入：[ [2], [3,4], [6,5,7], [4,1,8,3]]输出：11 (2-&gt;3-&gt;5-&gt;1) 题解这是一道典型的动态规划题，假定状态(i,j)为矩阵位置(i,j)开始到底部的最小路径和，那么状态转移方程为(i,j)=MIN((i+1,j),(i+1,j+1)), if j+1 &lt; triangle[i+1}.length或者MIN((i+1,j-1), (i+1,j)), if j-1 &gt;= 0。 上代码：12345678910111213141516171819202122var minimumTotal = function(triangle) { if (triangle.length == 0) return 0; if (triangle.length == 1) return triangle[0][0]; function linearPos(i, j) { return ((i+1)*i)/2 + j + 1; } for (var i = triangle.length - 1;i &gt;= 0;i--) { for (var j = 0;j &lt; triangle[i].length;j++) { var pos = linearPos(i,j); if (i+1 == triangle.length) { dp[pos] = triangle[i][j]; } else { if (j+1 &lt; triangle[i+1].length) { dp[pos] = triangle[i][j]+Math.min(dp[linearPos(i+1,j), dp[linearPos(i+1,j-1)]]); } else if (j-1 &gt;= 0) { dp[pos] = triangle[i][j]+Math.min(dp[linearPos(i+1,j-1)], dp[linearPos(i+1,j)]); } } } } return dp[1];}时间复杂度O(n2)，空间复杂度O(n2)，使用一维数组而不是二维数组可以减少一半的存储空间。 存储空间优化上述解法是O(n2)的空间复杂度，如果可以修改原triangle数组，那么空间复杂度可以降到O(1)，triangle[i][j]直接表示状态(i,j)的最小路径和。如果不能修改triangle数组，那么空间复杂度也可以降到O(n)，其实只需要两个O(n)的一维数组就可以完成计算。例如使用两个数组dp[0]和dp[1]，dp[1]表示下一行的计算结果，dp[0]表示本行的计算结果。dp[0]计算完成后，dp[0]作为下一行，dp[1]作为本行，如此循环。","link":"/2020/05/15/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/triangle/"},{"title":"unique path II","text":"问题描述给定一个二维格子矩阵，一个机器人初始位于最左上角，每次只能向右或者向下移动一个格子，格子有两种，有障碍物的和没有障碍物的，没有障碍物的可以走。求机器人的最大路线数。 例如：12345678910输入:[ [0,0,0], [0,1,0], [0,0,0]]输出：2因为中间的1挡住了，从左上角到右下角只有两种可能的走法，先右再下或者先下再右。 题解动态规划，设状态(i,j)为到达位置(i,j)的最大路径数，状态转移方程为(i,j) = (i,j-1)+(i-1,j)，因为只有从左边和上面能到(i,j)。注意处理一下边界条件，代码如下：1234567891011121314151617function aa(obstacleGrid) { if (obstacleGrid.length == 0 || obstacleGrid[0].length == 0) return 0; var dp = []; for (var i = 0; i &lt; obstacleGrid.length; i++) dp[i] = []; dp[0][0] = 1; for (var i = 0; i &lt; obstacleGrid.length; i++) { var column = obstacleGrid[i]; for (var j = 0; j &lt; column.length; j++) { if (!dp[i][j]) dp[i][j] = 0; if (!obstacleGrid[i][j]) { if (i - 1 &gt;= 0) dp[i][j] += dp[i - 1][j]; if (j - 1 &gt;= 0) dp[i][j] += dp[i][j - 1]; } } } return dp[obstacleGrid.length - 1][obstacleGrid[0].length - 1];}","link":"/2020/05/09/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/unique-path-II/"},{"title":"leetcode题解：Shortest Unsorted Continuous Subarray","text":"问题描述Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too. You need to find the shortest such subarray and output its length.1234Example 1:Input: [2, 6, 4, 8, 10, 9, 15]Output: 5Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.Note: Then length of the input array is in range [1, 10,000]. The input array may contain duplicates, so ascending order here means &lt;=. 问题分析题目要求是：给定一个数组，找到最小的未升序排序的连续子数组，或者说，找到一个最小连续子数组，将这个子数组排序后，整个数组是升序的。 很简单的一个思路是，复制一个一模一样的数组，将复制后的数组排序，然后比较排序后的数组和排序前的数组，就看出来哪一个最小连续子数组是无序的。具体的比较方式是，逐个数组元素从前向后和从后向前比较，直到找到前面不相等的位置和后面不相等的位置，中间的子数组就是需要排序的。例如对于[2,6,4,8,10,9,15]有：12input: [2,6,4,8,10,9,15]sorted copy: [2,4,6,8,9,10,15]一对比，前面2==2，6!=4，后面15==15，9!=10。所以最小连续无序的子数组是[6,4,8,19,9]。或者这样想，我将这个子数组排序后，才能让原数组有序。上代码，注意边界条件的处理：12345678910111213var findUnsortedSubarray = function(nums) { var numst = [].concat(nums); numst.sort(function(a,b) { return a - b; }); var p1 = 0, p2 = nums.length-1; while((nums[p1] == numst[p1] || nums[p2] == numst[p2]) &amp;&amp; p1 &lt;= p2) { if(nums[p1] == numst[p1] &amp;&amp; p1 &lt;= p2) p1++; if(nums[p2] == numst[p2] &amp;&amp; p1 &lt;= p2) p2--; } return p2-p1+1;};时间复杂度O(nlogn)，空间复杂度O(n)。 注意：js中的Array.prototype.sort方法，接收一个参数，该参数是带有两个参数的函数；如果没有该函数，默认按照升序排列，排序规则是将所有元素转成字符串，然后按照utf-16字符串来排序，这样和数字排序有什么区别呢？utf-16的数字的码点不一定是有序的，而且’10’和’9’按照字符串排序’10’是小于’9’的，因为逐个字符比较，’1’&lt;’9’。使用sort的函数参数可以自定义排序规则，该函数的两个参数分别表示比较的两个元素，这两个元素的类型和数组元素的类型相同；如果函数返回负数，表示第一个参数a的index在第二个参数b后面，如果返回0，表示两者的相对位置不变，但是仍会和其他元素一起排序；如果返回整数，表示a在b后面。 更好的解法上面给出的解法时间复杂度O(nlogn)，空间复杂度O(n)。能不能给出一种时间复杂度O(n)，空间复杂度O(1)的解法呢？肯定是可以的，通过两次线形遍历，可以找出来哪一部分是无序的。 对于一个数组，我们线形遍历希望找出最前面的不满足有序的边界，再找出后面的边界，两个边界之间就是需要排序的数组。从左到右，肯定希望是升序的，如果遇到了逆序，那么该逆序对的较小元素与左边肯定存在一个连续数组需要排序；从左到右遍历，并记住遍历过的部分的最大的元素，向右遍历时右边比左边最大元素小的都是逆序。这样过一遍，我们就找到了最右边的需要排序的边界，但是左边的还不知道。同样的原理，从右向左过一遍就能找到左边的边界。 例如，对于[2,6,4,8,10,9,15]： （从左向右）初始rEdge=-1，max=2，min=15，lEdge=-1 遍历6，6&gt; max，max = 6，rEdge = -1 遍历4，4&lt; max，max = 6，rEdge = 2 遍历8，8&gt; max，max = 8，rEdge = 2 … 遍历9，9&lt; max，max = 10，rEdge = 5 遍历15，15&gt; max，max = 15，rEdge = 5 (从右向左)… 遍历2，2&lt; min，min=2，lEdge = 1 代码：12345678910111213141516171819var findUnsortedSubarray = function(nums) { var lEdge = -1, rEdge = -1; var temp = nums[0]; for(var i = 1;i &lt; nums.length;i++) { if(temp &lt;= nums[i]) temp = nums[i]; else rEdge = i; } if(rEdge == -1) return 0; temp = nums[nums.length-1]; for(var i = nums.length - 2;i&gt;=0;i--) { if(temp &gt;= nums[i]) temp = nums[i]; else lEdge = i; } return rEdge - lEdge + 1;};时间复杂度O(n)，空间复杂度O(1)。注意相等的情形。","link":"/2019/12/13/algorithm/leetcode/%E6%95%B0%E7%BB%84/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9AShortest-Unsorted-Continuous-Subarray/"},{"title":"interleaving string","text":"问题描述给定三个字符串，判断第三个是不是有前两个交错构成。 例如：12输入：s1=&quot;aabcc', s2=&quot;dbbca&quot;, s3=&quot;aadbbcbcac&quot;输出：true 题解回溯法使用两个指针，指向s1，s2的当前字符位置。每次前移一个指针，如果移动s1的指针，那么将s1指向的字符与s3对应的位置的字符比较，如果相同，则继续，如果不相同，回溯到s1指针移动前，移动s2的指针比较。 最差情况下的时间复杂度为O(2^n)。 动态规划定义dp[i][j]为s1[0…i-1]和s2[0…j-1]能否构成s3[0…i+j-1]。 dp[i][j] = (dp[i-1][j]&amp;&amp;(s1[i-1]==s3[i+j-1])) || (dp[i][j-1]&amp;&amp;(s2[j-1]==s3[i+j-1])) 代码就是两个循环加状态转移方程，注意边界处理，dp[0][0]=true表示字符串长度为0的情况。","link":"/2020/05/19/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/interleaving-string/"},{"title":"Link List II","text":"问题给定一个链表，找出链表中循环的位置开始的地方，如果没有，返回null。使用整数pos表示循环开始的位置（0开始），如果没有环，pos为-1. 注意：不要修改链表 示例","link":"/2019/11/06/algorithm/leetcode/%E9%93%BE%E8%A1%A8/Link-List-II/"},{"title":"Copy List with Random Pointer","text":"问题描述给定一个链表，给出该链表的深克隆结果。链表的结构如下：12345struct Node { int val; Node* next; Node* random;}random是指向任意链表中任意节点的指针。 题解克隆一个链表很容易，直接根据next遍历链表，然后对每个节点生成一个相同的节点不就可以了。想法是这样，但是有一个问题，random怎么处理呢？random的问题又可以分为下面三问题： random指向的节点在链表的什么位置？ 该结点是否已经被克隆过了？ 怎么通过位置找到克隆的节点呢？ 第一个问题是，我们已经知道了源链表的random指向的节点，那么我们怎么直到克隆的random指向哪一个克隆的节点呢？答案是可以通过位置来判断，源链表指向链表中的第几个节点，克隆的链表的random也指向第几个节点。所以现在问题就变成了，已知random指向的对象，如何知道它是第几个节点。最简单粗暴的方式就是遍历链表，找到该结点，然后返回该节点的序号。这样每次找random都需要遍历依次链表，事件复杂度是O(n2)。 另一种解决方案是将节点在链表中的序号存起来，可以采用键为对象的hash表，或者在对象中增加一个属性记录序号。本解法使用javascript采用第二种方式。这样第一个问题就解决了。 第二个问题是，怎么知道random指向的对象是否被克隆了呢？一种方法是比较当前的序号和random节点的序号，如果当前的大，则random节点已经克隆了；如果小，则random节点还没有克隆。已经克隆的情况比较简单，没有克隆时怎么办呢？是先克隆，还是记录位置稍后克隆呢？如果先克隆，则要额外的结构记录和标记该位置的节点是否被克隆（例如一个标记数组），如果后克隆也要记录，当对应的节点被克隆时，设置这个节点的random指向（例如一个map）。 另一种方法是先直接克隆链表，第二次再设置random，这种实现方式的事件复杂度稍微高一点（但也是同一个量级），本解法采用这种方式。这种解法能够保证所有节点都被克隆并且不会重复克隆。采用这种解法需要解决第三个问题，第一个问题已经知道了源链表中一个节点所在的序号，第三个问题需要由序号找到已克隆的节点，采用hash表的方式可以降低事件复杂度。 代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243// function Node(val, next, random) {// this.val = val;// this.next = next;// this.random = random;// }var copyRandomList = function(head) { var temp = head; var res = null, tres = null, lastres = null; function init(t) { return { val: t.val, next: null, random: null }; } var resmap = {}; var index = 0; // 第一遍记录序号并克隆，同时记录序号和被克隆节点的映射 while(temp != null) { if (res == null) { res = init(temp); tres = lastres = res; } else { tres = init(temp); lastres.next = tres; lastres = tres; } temp._index = index; resmap[index] = tres; index++; tepm = temp.next; } temp = head; tres = res; while(temp != null &amp;&amp; tres != null) { var random = temp.random; if (random) random = resmap[random._index]; else random = null; tres.random = random; temp = temp.next; tres = tres.next; }}","link":"/2020/05/06/algorithm/leetcode/%E9%93%BE%E8%A1%A8/Copy-List-with-Random-Pointer/"},{"title":"leetcode题解：Intersection of Two Linked List","text":"问题Write a program to find the node at which the intersection of two singly linked lists begins. For example, the following two linked lists: begin to intersect at node c1. 解析根据题目描述，给定两个链表，我们要找出链表公共部分的起始节点。要求在O(n)时间复杂度、O(1)空间复杂度内解决。所给的链表都没有环。 有三种方法： 第一种也是我们最容易想到的方法：对于每一个A的节点，遍历B，直到找到相同地址的节点。时间复杂度O(mn)，空间复杂度O(1) 第二种是哈希表：直接将一个链表节点做hash，然后遍历B，如果B的节点在hash表中，则找到。时间复杂度O(m+n)，空间复杂度O(m)或O(n) 第三种是双指针法：这种是最推荐的方法，时间复杂度是O(m+n)，空间复杂度O(1)，接下来我们具体分析这种方法。 双指针法 这里所说的双指针法是一种笼统的概括，具体就是用两个指针去解决问题。至于如何移动这两个指针，指针指向的初始位置在哪，在不同的题目中都不一样，有的题目是头尾两个指针，有的是两个指针指向不同的位置。 那这里的双指针怎么指呢？一个指向A一个指向B吗？那A的每一个节点和B的每一个节点都有可能是相同的，可能的情况不是有O(mn)中吗？怎么做到O(m+n)呢？ 这里我们用到了一些技巧，看下图：12345A B S[1,2,3][4,5,2,3]B A S[4,5,2,3][1,2,3]这里我们是要找公共的后缀，那么A和B一定在尾部有相同的部分，我们将B接在A后面，得到长度为m+n的链表；A接在B后面，也得到长度为m+n的链表。二者两个链表尾部一定有一部分是相同的（上图中的S）。 所以我们拼接两个链表（不一定是真的拼接，可以使用指针切换模拟拼接的效果，看下面的代码），然后用两个指针，一个指向A，一个指向B，同时每次移动一个节点，直到两个指针的值相同。如果存在就找到了公共的，如果不存在，就说明没有公共部分。 代码12345678910111213141516171819202122232425262728293031/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */struct ListNode *getIntersectionNode(struct ListNode *headA, struct ListNode *headB) { struct ListNode *tha = headA; struct ListNode *thb = headB; int flaga = 0, flagb = 0; while(tha &amp;&amp; thb) { if(!tha || !thb) { return NULL; }else if( tha == thb) { return tha; } tha = tha-&gt;next; thb = thb-&gt;next; if(!tha &amp;&amp; !flaga) { flaga = 1; tha = headB; } if(!thb &amp;&amp; !flagb) { flagb = 1; thb = headA; } } return NULL;} 思考这个题目中，用枚举法是O(mn)。但是我们发现了公共后缀子串的性质——将子串拼接起来后缀相同。我们不需要枚举所有可能的情况，利用这个性质，我们只需要判断一部分情况就能得到正确的结果。","link":"/2019/11/30/algorithm/leetcode/%E9%93%BE%E8%A1%A8/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9AIntersection-of-Two-Linked-List/"},{"title":"sort list","text":"问题给定一个数组，在O(nlogn)的时间复杂度和常量空间复杂度内对该链表排序。 12345678Example 1:Input: 4-&gt;2-&gt;1-&gt;3Output: 1-&gt;2-&gt;3-&gt;4Example 2:Input: -1-&gt;5-&gt;3-&gt;4-&gt;0Output: -1-&gt;0-&gt;3-&gt;4-&gt;5 思路要在O(nlogn)的时间复杂度内排序，我们可以考虑使用分治算法。核心问题就是如何分合，链表不像数组那样好取到数组中的任何一个元素。但是我们可以通过遍历链表来取到中间元素和最后一个元素，通过改变遍历的速率。 分治算法的通用伪代码如下：12345devide_conquer(list): [left, middle, right] = partition(list) divide_conquer(left, middle) divide_conquer(middle, right) merge(left, middle, right)大致的思想就是：分-&gt;计算左右-&gt;合。其中我们要保证分、合的最大时间复杂度为O(n)，这样才能保证整体的时间复杂度是O(nlogn)。 实现先上代码，然后再分析：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465/** * Definition for singly-linked list. * function ListNode(val) { * this.val = val; * this.next = null; * } *//** * @param {ListNode} head * @return {ListNode} */var sortList = function(head) { if (head == null || head.next == null) return head; else { var p = partition(head); var h1 = sortList(p[0]); var h2 = sortList(p[1]); return merge(h1, h2); }};function partition(head) { var slower = head, faster = head.next; while (faster !== null) { faster = faster.next; if (faster) { faster = faster.next; slower = slower.next; } } var next = slower.next; slower.next = null; return [head, next];}function merge(h1, h2) { var h = null, ht = null; while (h1 || h2) { var t; if (!h2) { t = h1; h1 = h1.next; } else if (!h1) { t = h2; h2 = h2.next; } else { if (h1.val &gt;= h2.val) { t = h2; h2 = h2.next; } else { t = h1; h1 = h1.next; } } if (!h) { h = ht = t; } else { ht.next = t; ht = t; } } return h;}可以看到我们的算法严格遵循了上面的伪代码公式，但是我们要注意的有三点： partition和merge的时间复杂度必须在O(n)之内 partition采用了“不同步长”的思想，通过两个指针，一个步长为1，一个步长为2，来找到中间位置的节点，需要主要的是边界条件，步长为二的从第二个节点开始，这样才能保证步长为1的节点在中间位置。 merge和归并算法的merge完全相同，注意while(h1 || h2) 注意边界条件，当递归到只有一个节点时，结束递归","link":"/2019/11/06/algorithm/leetcode/%E9%93%BE%E8%A1%A8/sort-list/"},{"title":"Template Method模式","text":"在父类中定义处理流程框架，在子类中实现具体处理的模式就称为Template Method模式。这样可以将流程处理和其实现分开，举个例子，我们使用字帖来描字，无论使用什么笔来描，描出来的字形都是一样的；反过来说，使用不同颜色和种类的笔，就可以描出不同颜色的字，就算我没有钢笔，我可以用铅笔来写。在这个例子中，描字这个行为是抽象出来的模板，具体使用什么笔去描是具体的实现。模板和实现是分开的，这样就可以实现解藕的目的。 在Template Method模式中，利用的也是模板的思想，在父类或者接口中定义好处理流程，在子类中去具体实现。这样可以将流程的调用和关系和其实现解藕。在父类中只知道各个方法的调用关系，在子类中去具体实现。 角色在Template Method模式中，只有两种角色，一种是抽象类，一种是具体类。 抽象类抽象类定义了处理流程，具体来说就是相关接口的各方法的调用关系，不涉及接口的具体实现。 具体类具体类是抽象类的实现，负责实现抽象类中定义的方法。 示例1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950/** * Template Method模式示例 */namespace DesignPattern { export abstract class AbstractDisplay { protected abstract open(): void; protected abstract print(): void; protected abstract close(): void; public display(): void { this.open(); for(let i = 0;i &lt; 5;i++) { this.print(); } this.close(); } } export class CharDisplay extends AbstractDisplay { open(): void { console.log('#') } print(): void { console.log('data') } close(): void { console.log('#') } } export class StringDisplay extends AbstractDisplay { open(): void { console.log('string start') } print(): void { console.log('string print') } close(): void { console.log('string close') } }}function main() { const cd: DesignPattern.AbstractDisplay = new DesignPattern.CharDisplay(); const sd: DesignPattern.StringDisplay = new DesignPattern.StringDisplay(); cd.display(); sd.display();}main(); 思考java中的泛型和c++中的模板其实也是一种相同的思想，泛型机制是将类型抽象出来。这样可以将处理逻辑通用化，不同的类型都可以调用这一份代码。 泛型可以使逻辑处理通用化Template method也有这样的优点，假设我们有很多的类，处理流程相同，但是处理细节不同，这样我们可以将具体的流程算法提取出来作为模板。具体的处理过程实现这个模板，假定要修改现有流程，只需要改模板即可。如果没有提取抽象模板，如果有多个类，那么修改流程时，这些所有类都需要修改。不写重复的代码，这样可以减少工作量，提高可维护性 父类和子类之间的合作在Template Method模式中，父类和子类是相互关联的，子类必须知道父类的具体实现过程。 与Strategy模式相比，Template模式用于抽象处理逻辑，而Strategy模式用于替换整个算法逻辑。 父类和子类的关系从子类的角度看： 可以复用父类已有的方法 可以在父类方法的基础上定义自己的方法 通过重写父类方法可以改变程序的行为 从父类的角度看： 规定子类应该实现的抽象方法 假设我们站在父类的角度思考，我们可以提取所有通过的处理逻辑，而期待子类去实现具体内容。这样在调用的时候，只调用父类的抽象，而不关心具体的实现。 这也是抽象类的作用，抽象类不能实例化，那么不能实例化的类有什么用呢？Template Method给了我们答案，抽象类如其名，用于抽象，将其逻辑和逻辑方法的调用关系抽象出来，具体的实现交给子类。在语法层面贯彻了Template Method的思想。 练习题 java.io.InputStream使用了Template Mehod模式。找出需要java.io.InputStream的子类需要实现的方法。 答：查看java.io.InputStream的文档，发现其中只有read一个抽象方法，用于读取流中的下一个字节。InputStream中的其他方法都调用这个方法，当我们要自定义InputStream时，只需要实现read方法，其他方法的调用逻辑都写在的InputStream这个抽象类中，这就是一种Template Method模式。 为什么不能用接口来实现Template Method模式呢？答：因为接口中不包含具体的实现，而Template Method需要定义调用逻辑，需要有具体的实现方法。所以只能用抽象类实现Template Method模式。","link":"/2019/10/16/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/Template-Method%E6%A8%A1%E5%BC%8F/"},{"title":"Iterator模式","text":"Iterator模式也翻译成“迭代器模式”，主要作用是对某一个集合的逐个遍历进行抽象。例如，我们常常写：123for (let i = 0;i &lt; arr.length;i++) { console.log(arr[i])} 在上例中我们对arr进行了遍历，该示例是对数据进行从前到后的遍历，通过递增的i来实现逐个遍历元素。 而Iterator模式就是对上述形式的抽象，我们提取出上述的遍历行为，而不关心其具体的遍历行为，具体的遍历行为交给具体的实现去完成。 设计模式是比较抽象的层面，更加注重的是程序中出现的角色和其相互关系，示例是用来对某一个具体情况来做演示，我们应该首先理解设计模式中的相关角色及其关系，然后了解其使用的场景，最后在根据具体的示例来加深理解和记忆 示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// 迭代器模式示例文件，相关的类都在这个文件中namespace DesignPattern { // 将数据集抽象成一个集合 export interface Aggregate { iterator(): Iterator&lt;any&gt;; } // 将遍历行为抽象成遍历器 export interface Iterator&lt;T&gt; { hasNext(): boolean; next(): T; } // 集合的具体实现，在Iterator模式中并不关心集合内部如何存储数据 // 只需要实现集合的基本操作：从集合中取数据，向集合中插入数据。将这些接口暴露给遍历器 // 就可以不关心集合到底如何存数据，如何取数据，这些都是集合内部的事情，达到了解藕的目的 // 将对集合的具体遍历行为交给遍历器 export class BookShelf implements Aggregate { private bookArr: Book[] = []; private len: number = 0; constructor(bookArr: Book[]) { this.bookArr = bookArr; } iterator(): Iterator&lt;any&gt; { return new BookIterator(this); } getBookAt(index: number) { return this.bookArr[index]; } length() { return this.len; } } // 遍历器的具体实现，在Iterator模式中并不关心遍历器如何遍历数据 // 只需要实现的next、hasnext方法 // 如何遍历是Iterator内部的事情 export class BookIterator implements Iterator&lt;Book&gt; { private bookshelf: BookShelf = null; private index: number = 0; constructor(bookshelf: BookShelf) { this.bookshelf = bookshelf; } next(): Book { return this.bookshelf.getBookAt(this.index++) } hasNext(): boolean { return this.index &lt; this.bookshelf.length(); } } export class Book { bookName: string; price: number; constructor(bookName: string, price: number) { this.bookName = bookName; this.price = price; } }}// 接下来我们希望对集合进行遍历// 这样我们就完成了解藕，每个角色只做自己的事情// 如果想将集合实现从数组改称链表，只要再实现一个新的链表集合，其他的均不需要改动function main() { let arr: DesignPattern.Book[] = []; for(var i = 0;i &lt; 10;i++) { arr.push(new DesignPattern.Book('name'+i, i+100)); } let bookshelf = new DesignPattern.BookShelf(arr); let iterator = bookshelf.iterator(); while(iterator.hasNext()) { console.log(iterator.next()); }} 角色在Iterator模式中我们出现了以下角色： 抽象集合：提供生成遍历器的抽象方法iterator 抽象遍历器：提供了遍历器必须的抽象方法hasNext，next 集合实现：实现了抽象集合，提供集合的具体实现，包括生成遍历器实例，集合操作等 遍历器实现：实现了如何具体的去遍历集合 访问者（main方法）：遍历集合 在上面的实现中，遍历器和集合是相互关联的，遍历器知道如何访问集合内部的元素，这样我们才能使用遍历器去访问集合。当修改了集合的实现时，如果暴露给遍历器的API改变了，那么遍历器的实现也要改变。一般不同的集合会有自己的遍历器实现。但是由于我们还有抽象接口这一层，事实上我们可以仅仅返回抽象接口，从而完全将对集合遍历这一行为抽象行为。 简单的讲，对访问者而言，其只要调用集合的iterator方法，取得Iterator实例，然后用Iterator实例的next方法去遍历就行了，其他细节一概不关心。 思考为什么要有这么多角色呢？直接遍历集合不就可以吗？声明这么多角色的目的主要是解藕，如果直接遍历集合，那么集合和其遍历是耦合的。如果我们要修改集合的底层实现，那么其遍历行为也要改变。 一个集合类在一个项目中肯定不只一次使用，那么每一处对集合的遍历都要进行修改。我们将遍历行为抽象出来，遍历就只和遍历器打交道。即便集合修改了导致要修改其对应的遍历器的实现，也最多只需要修改两处。 而且遍历器的行为不一定是从前向后遍历，可以是任意一种遍历形式。我们只需要使用上面的思想进行抽象，可以实现任意独立的不耦合的遍历行为。 同时我们还看到，一个角色只进行独立的工作，这样可以减轻耦合，减小维护成本。","link":"/2019/10/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Iterator%E6%A8%A1%E5%BC%8F/"},{"title":"Factory Method模式","text":"在Template Method模式中，我们在父类中规定处理的流程，在子类中实现具体的处理。如果我们将该模式用于生成实例，就变成了Factory Method模式。用Template method 模式来构建生成实例的工厂，这就是Factory Method模式。 角色Factory Method模式中，一共有四种角色，抽象工厂、抽象产品、具体工厂、具体产品。 抽象工厂：抽象工厂中定义了构建一个产品的流程，但是并没有给出具体的实现，这是Template Method的一种体现 抽象产品：抽象产品中定义了一个产品的所有方法定义 具体工厂：抽象工厂的实现，具体创建什么产品由具体工厂来决定 具体产品：抽象产品的实现，抽象产品的具体行为在具体产品中定义‘ 使用抽象类的一个优势就是解藕，抽象类给出模式，而具体类给出实现。程序设计中的一个重要思想就是一段程序只解决一个问题，这样可以将不同的问题分离开，便于开发和维护，同时将单个问题的解进行组合，可以解决复杂问题。 示例我们使用上面的四个角色来给出一个Factory Method模式的示例：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657/** * 工厂模式的示例代码 */namespace DesignPattern { export abstract class Factory { public create(owner: string) { const p:Product = this.createProduct(owner); this.registerProduct(p); return p; } protected abstract createProduct(owner: string):Product; protected abstract registerProduct(product: Product):void; } export abstract class Product { public abstract use():void; } export class IDCardFactory extends Factory { private owners: string[] = []; constructor() { super(); } protected createProduct(owner: string) { return new IDCard(owner); } protected registerProduct(product: Product) { this.owners.push((&lt;IDCard&gt;product).getOwner()); } } export class IDCard extends Product { owner: string; // 构造函数可以也可以见添加访问控制符，例如public，这样可以控制该类可以在哪些范围内可以实例化 constructor(owner: string) { super(); this.owner = owner; } public use() { console.log(`use ${this.owner}'s id card`); } getOwner() { return this.owner; } }}const factory = new DesignPattern.IDCardFactory();const names = ['mike', 'jack', 'bob', 'jummy'];// 在调用的时候，只需要调用Factory的create就能创建Product对象// 当我们明确知道Product的类型时，可以向下转型，这样可以调用具体类型的中定义的方法// 当我们不明确知道Product的类型时，或者不需要知道具体类型时，直接向上转型，获得Prodcut类型names.forEach(item =&gt; { const p = &lt;DesignPattern.IDCard&gt;factory.create(item); p.use();}) 上面的示例中我们创建了抽象工厂和抽象产品，然后给出具体产品工厂IDCardFactory以及具体产品IDCard。在抽象工厂中我们定义了生成示例所要执行的一系列流程，先创建产品，再注册产品，在这里，我们只定义产品创建要执行的流程，并没有给出实现，实现再具体类中，这就是Factory Method模式。在Factory具体的实现中我们给出要创建怎么样的产品，在Product的具体实现中我们给出了创建的产品的具体性质（owner）。工厂和产品可以是一对一的关系，也可以是一对多的关系，据具体的场景来定。 练习 在示例程序中添加卡号以及卡号和所有人的对应关系表。答：分析题目，我们脑海中第一个问题一定是：卡号加在哪呢？对应关系表加在哪呢？这需要根据我们的生活，卡号肯定是IDCard的号码，所以其一定是IDCard的属性。对应关系是卡号和其所有人构成，对应关系表一定存着所有的对应关系，肯定不可能在某一个产品示例中，我们可以存在哪呢？Product的静态属性？factory的属性？一个工厂可以要记录下自己生产过哪些实例，这个对应关系表可以存在工厂实例中。所以我们得出答案，卡号添加在IDCard类中，对应关系表添加到工厂中，在工厂中创建实例的时候，将对应关系注册进去。修改后的代码如下：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263 /** * 练习代码 */namespace Practice { export abstract class Factory { public create(owner: string, cardNum: number) { const p:Product = this.createProduct(owner, cardNum); this.registerProduct(p); return p; } protected abstract createProduct(owner: string, cardNum: number):Product; protected abstract registerProduct(product: Product):void; } export abstract class Product { public abstract use():void; } export class IDCardFactory extends Factory { private owners:Map&lt;string, number&gt; = new Map(); constructor() { super(); } protected createProduct(owner: string, cardNum: number) { return new IDCard(owner, cardNum); } protected registerProduct(product: Product) { this.owners.set((&lt;IDCard&gt;product).getOwner(), (&lt;IDCard&gt;product).getCardNumber()); } public cardNameMap() { return this.owners; } } export class IDCard extends Product { private owner: string; private cardNumber: number; // 构造函数可以也可以见添加访问控制符，例如public，这样可以控制该类可以在哪些范围内可以实例化 constructor(owner: string, cardNum: number) { super(); this.owner = owner; this.cardNumber = cardNum; } public use() { console.log(`use ${this.owner}'s id card, id card number is ${this.cardNumber}`); } getOwner() { return this.owner; } getCardNumber() { return this.cardNumber; } }}const factory_p = new Practice.IDCardFactory();const names_p = [['mike', 123], ['jack', 456], ['bob', 567], ['jummy', 890]];names_p.forEach(item =&gt; { const p = &lt;DesignPattern.IDCard&gt;factory_p.create(&lt;string&gt;item[0], &lt;number&gt;item[1]); p.use();})console.log(factory_p.cardNameMap());","link":"/2019/10/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/Factory-Method%E6%A8%A1%E5%BC%8F/"},{"title":"leetcode题解：Palindrome Lined List","text":"问题描述Given a singly linked list, determine if it is a palindrome. Example 1:12Input: 1-&gt;2Output: falseExample 2:12Input: 1-&gt;2-&gt;2-&gt;1Output: trueFollow up:Could you do it in O(n) time and O(1) space? 问题分析本题需要判断一个链表是不是一个回文串，回文串的性质是顺着读和倒着读是完全一样的，即$a_{i}=a_{n-i-1}$。在数组中我们只要顺着和倒着比一遍就可以了，但是在链表中，只能单向遍历，现在要解决的问题就是如何反向遍历。 在不考虑时间复杂度和空间复杂度的情况下，很容易想到下面两种方案： 方案1：找到节点$a_{i}$和$a_{n-i-1}$，比较两者，其中i&lt;=n/2。这样的时间复杂度是$O(n^2)$，空间复杂度是O(1)。方案2：利用栈反转链表，然后逐个比较，这样的时间复杂度是O(n)，空间复杂度是O(n)。 然而我们的最佳方案需要O(n)的时间复杂度，O(1)的空间复杂度，能不能进一步优化呢？答案是肯定的。在方案2中我们利用栈反转链表，那么能不能不用栈就反转链表呢？答案也是肯定的，这个题是可以改变原链表的，所以我们直接修改原链表没有问题。O(n)时间复杂度，O(1)空间复杂度的反转链表的算法如下： 两个指针a,b初始都指向链表头部，移动b到b-&gt;next 临时指针指向头部a，a=b，b=b-&gt;next，a-&gt;next=临时指针 重复2，直到b为空 12345678a bA-&gt;B-&gt;C-&gt;D a bA&lt;-B C-&gt;D a bA&lt;-B&lt;-C D a bA&lt;-B&lt;-C&lt;-D-&gt;NULL 最终方案：将链表分成左右两部分，反转右边的部分，然后逐次比较左右是否相同。 寻找链表的中间位置：通过两个指针遍历，一个步长为1，另一个步长为2，这样就可以找到中间位置。奇数个节点找到的是最中间的，偶数个找到的是中间靠右的。 代码1234567891011121314151617181920212223242526272829303132333435363738394041/** * Definition for singly-linked list. * struct ListNode { * int val; * struct ListNode *next; * }; */struct ListNode* findCenterNode(struct ListNode* head) { struct ListNode *temp1 = head, *temp2 = head; while(temp2 &amp;&amp; temp2-&gt;next) { temp1 = temp1-&gt;next; temp2 = temp2-&gt;next-&gt;next; } return temp1;}struct ListNode* reverseLinkedList(struct ListNode* head) { struct ListNode *temp1 = head, *temp2 = head-&gt;next; temp1-&gt;next = NULL; while(temp2) { struct ListNode* temp = temp1; temp1 = temp2; temp2 = temp2-&gt;next; temp1-&gt;next = temp; } return temp1;}bool isPalindrome(struct ListNode* head){ if(head == NULL) return true; struct ListNode* cNode = findCenterNode(head); struct ListNode* reversedNode = reverseLinkedList(cNode); struct ListNode* p1 = head, *p2 = reversedNode; while(p1 != cNode &amp;&amp; p2 != NULL) { if(p1-&gt;val != p2-&gt;val) return false; p1 = p1-&gt;next; p2 = p2-&gt;next; } return true;}","link":"/2019/12/12/algorithm/leetcode/%E9%93%BE%E8%A1%A8/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9APalindrome-Lined-List/"},{"title":"Singleton 模式","text":"在我们的程序中，我们可能只希望某一个类始终只有一个实例，例如可视化程序中的一个窗口，或者表示程序设置的类。Singleton模式（单例模式）要达到下面两个目的： 确保任何情况下都只生成一个实例 在程序上体现出来“只存在一个实例” 角色单例模式中只有一个角色，就是只有一个实例的类，该类是一个具体类，有一个静态方法getInstance用于获取该类的实例。 实例12345678910111213141516171819202122/** * 单例模式实例代码 */namespace DesignPattern { export class Singleton { private static singleton: Singleton = null; private constructor() { console.log('生成了一个实例'); } public static getInstance(): Singleton { if(Singleton.singleton === null) { Singleton.singleton = new Singleton(); } return Singleton.singleton; } }}DesignPattern.Singleton.getInstance();DesignPattern.Singleton.getInstance();DesignPattern.Singleton.getInstance();DesignPattern.Singleton.getInstance(); 在上例中，只有一个类，类只有静态属性，构造函数是private，这样可以保证不能在类的外部通过new实例化。只能通过getInstance来获取实例","link":"/2019/10/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/Singleton-%E6%A8%A1%E5%BC%8F/"},{"title":"Adapter模式","text":"Adapter模式用于解决现有程序无法直接使用的问题，通过进行一定的适配，就能够在不修改源程序的基础上，使用现有程序的功能。宏观来说，只要两个接口不一样，而且有一定的练习，就可以考虑用适配器来进行适配，以达到弥补接口差异的目的。 角色适配器模式中会出现三种角色： 使用者：希望使用某一项功能，提出某种需求 适配器：将被适配者的能力转换，转换成需求的形式 被适配者：被适配的对象 什么时候使用Adapter模式？需要复用已有的类的时候需要复用已有的经过稳定测试的类的一些功能，希望通过一些处理复用已有的逻辑。如果要基于已有的功能添加新的功能，这种模式叫做**装饰器模式（Decorator） 适配新的接口假如我们开发了新的API，现有的类需要适配新的API，现有的类一般都是经过测试的。如果直接修改现有的类，需要重新测试，而且可能会影响原有的功能，这样我们可以使用适配器模式 兼容老版本我们开发了新版本，但是希望可以向下兼容老版本，可以通过适配器将老版本的API映射到新版本实现向下兼容。 实例示例我们基于之前实现的Iterator模式样例来实现，假定我们现在的需求是一个需要跳跃遍历的Iterator。利用Iterator模式解藕的特性，我们可以很容易的实现一个新的BookJumpIterator，但是这样的话，我们需要重新写一个BookJumpIterator类，而其实现其实是和BookIerator类似的，我们就要编写一个可能费时又重复的类。这时候适配器模式就是更好的解决方案，我们通过一个适配器，将已有的BookIterator转换成我们想要的样子，这样工作量小，还放心不会有很多bug（因为BookIterator是经过严格测试的，即便要测试，重点测一下BookIterator就行了），岂不是很完美！ 上代码：12345678910111213141516171819202122232425import { DesignPattern as Iterator } from './Iterator'namespace DesignPattern { // 这个适配器模式我们基于之前实现的Iterator来实现 // 利用适配器模式实现一个跳跃遍历的遍历器 // 我们需要的接口类型如下 export interface JumpIterator { hasNext(): boolean; jumpNext(): Iterator.Book; } // 被适配的接口类型：BookIterator // 适配器 export class JumpIteratorAdapter extends Iterator.BookIterator implements JumpIterator { constructor(bookshelf: Iterator.BookShelf) { super(bookshelf); } jumpNext(): Iterator.Book { this.next(); return this.next(); } }}适配器模式有两种实现方式，上一种叫做继承实现，另一种是委托实现，我们看一下委托实现：12345678910111213141516171819export abstract class JumpIterator { public abstract hasNext(): boolean; public abstract jumpNext(): Iterator.Book;}export class JumpIteratorAdapter extends JumpIterator { bookiterator: Iterator.BookIterator = null; constructor(arr: Iterator.BookShelf) { super(); this.bookiterator = new Iterator.BookIterator(arr); } public hasNext() { return this.bookiterator.hasNext(); } public jumpNext(): Iterator.Book { this.bookiterator.next(); return this.bookiterator.next(); }}区别就是一个是通过继承获取原始类的能力，另一个是通过实例化一个原始类作为属性。 练习Node.js可以通过stream.Readable和stream.Writable来获取输入输出流的能力。 我们需要一个可以读入键值对并输出到文件的接口，现在已经有一个从流中读入、写出属性的类Properties，希望写一个适配器，将该类适配成能从文件中读入、写出键值对的类FileProperties。 Properties提供的接口如下：123456interface Properties { // 从输入流中取出键值对 load(in: Readable): void; // 向输出流中写入属性集合，header是注释文字 store(out: Writable, header: string): void;}需求的接口如下：123456export interface FileIO { readFromFile(filename: string): void; writeToFile(filename: string): void; setValue(key: string, value: string): void; getValue(key: string): string;} 答： 我们的目的是实现一个适配器，将已有的接口转换成我们需要的FileIO中的接口，通过观察，Properties提供了从流中读入输出键值对的方法，而我们想要的是给定文件名，能够从文件中读入输出键值对，我们需要做的就是，将文件名转成流，这样就可以对接上Properties的接口，正好文件流是一种非常常见的形式：12345678910111213141516export class FileProperty extends Properties implements FileIO { readFromFile(filename: string): void { const readable = fs.createReadStream(filename); this.load(readable); } writeToFile(filename: string): void { const writable = fs.createWriteStream(filename); this.store(writable); } setValue(key: string, value: string): void { this.properties[key] = value; } getValue(key: string): string { return this.properties[key]; } } 完整代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import { Readable, Writable } from \"stream\";// Adapter模式的练习题namespace Practice { export class Properties { protected properties = {}; public load(readable: Readable): void { let data = ''; readable.setEncoding('utf8'); readable.on('data', (chunk) =&gt; { data += chunk; }); readable.on('end', () =&gt; { let arr = data.split('\\n'); arr.forEach((item: string) =&gt; { let prop = item.split('='); this.properties[prop[0]] = this.properties[prop[1]]; }) }) } public store(writable: Writable): void { let keys = Object.keys(this.properties); for(let key of keys) { writable.write(key+'='+this.properties[key]+'\\n'); } writable.end(); } } export interface FileIO { readFromFile(filename: string): void; writeToFile(filename: string): void; setValue(key: string, value: string): void; getValue(key: string): string; } export class FileProperty extends Properties implements FileIO { readFromFile(filename: string): void { const readable = fs.createReadStream(filename); this.load(readable); } writeToFile(filename: string): void { const writable = fs.createWriteStream(filename); this.store(writable); } setValue(key: string, value: string): void { this.properties[key] = value; } getValue(key: string): string { return this.properties[key]; } }} 思考适配器模式更多的是弥补不同接口之间的差异，达到复用已有功能的目的，对比于Decorator（装饰器）模式，适配器模式不会增加新的功能，适配器模式只利用利用已有的能力对不同的接口进行适配，以此来达到兼容性的复用已有的组件、向下兼容等目的。 如上面的练习中的适配，需求的接口和已有的接口不一致，我们可以通过一个适配器进行适配，弥补这个差异。也如上面的示例，我们通过适配器，将已有的Iterator的能力转换，以得到新的接口。","link":"/2019/10/11/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E5%9B%BE%E8%A7%A3%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/Adapter%E6%A8%A1%E5%BC%8F/"},{"title":"unique binary search trees ii","text":"问题描述给一个整数n，生成所有包含值1…n的可能的独特的BST。例如：1234567891011121314输入：3输出：[ [1,null,3,2], [3,2,null,1], ...]解释：1 3 \\ / 3 2 ... / /2 1 题解递归最容易想到的方法当然是递归了，对于1…n中的每一个值i，都有可能是树根。如果i是树根，那么[0…i-1]的结果集构成左子树，[i+1…n]的结果集构成右子树，左右子树结果集两两组合就是最终结果。 整体思路是这样，最开始要求的是[1,n]这个这个范围的所有可能BST，然后遍及[1,n]中的每一个值i，将i作为根结点。比小的肯定是i的左子树中的节点。递归处理[1,i-1]作为左子树的结果集（返回一个数组），递归处理[i+1,n]作为右子树的结果集（返回一个数组），然后将这两个结果集两两组合作为i的左子树和右子树。代码如下： 1234567891011121314151617181920212223242526272829var generateTrees = function(n) { return generate(1, n);};function generate(left, right) { if (left &gt; right) return []; var res = []; for (var i = left;i &lt;= right;i++) { var ln = generate(left, i-1); var rn = generate(i+1, right); if (rn.length==0&amp;&amp;ln.length==0) { res.push({val:i,left:null,right:null}); } else if (rn.length==0) { for (var l = 0;l &lt; ln.length;l++) { res.push({val:i,left:ln[l],right:null}); } } else if (ln.length == 0) { for (var r = 0;r &lt; rn.length;r++) { res.push({val:i,left:null,right:rn[r]}); } } else { for (var l = 0;l &lt; ln.length;l++) { for (var r = 0;r &lt; rn.length;r++) { res.push({val:i,left:ln[l],right:rn[r]}); } } } } return res;} 结果缓存上面的递归算法是不是可以进一步优化呢？观察到(left,right)之间的结果是一个固定的结果，也就是(1,3)这个范围限定了，那么其结果集也限定了。但是再上面的递归算法中，其实存在重复计算，考虑5会求3，6也会求3，这样就重复求了两次。将(1,3)的结果缓存了，就不需要重复求了。 改造一下代码：123456789101112function generate(left, right, cache) { if (left &gt; right) return []; if (cache[left][right]) return cache[left][right]; var res = []; for (var i = left; i &lt;= right; i++) { var ln = generate(left, i - 1, cache); var rn = generate(i + 1, right, cache); // ... } cache[left][right] = res; return res;} 动态规划将(left,len)状态定义为[left,left+len-1]的BST数组，那么(left,len+1)=(left,i-1)*i*(i+1,len+left-i)，其中i为[left,left+len-1]中的任意元素（结果求和），*表示结果组合。 代码如下：1// 结构和generate类似，只不过改成循环，注意边界条件判断，今天时间有限就不写代码了","link":"/2020/05/12/algorithm/leetcode/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/unique-binary-search-trees-ii/"}],"tags":[{"name":"英语","slug":"英语","link":"/tags/%E8%8B%B1%E8%AF%AD/"},{"name":"单词","slug":"单词","link":"/tags/%E5%8D%95%E8%AF%8D/"},{"name":"编程语言","slug":"编程语言","link":"/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"C语言","slug":"C语言","link":"/tags/C%E8%AF%AD%E8%A8%80/"},{"name":"GCC","slug":"GCC","link":"/tags/GCC/"},{"name":"计算机网络","slug":"计算机网络","link":"/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"问题记录","slug":"问题记录","link":"/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"css","slug":"css","link":"/tags/css/"},{"name":"css工具","slug":"css工具","link":"/tags/css%E5%B7%A5%E5%85%B7/"},{"name":"browserslist","slug":"browserslist","link":"/tags/browserslist/"},{"name":"css基础","slug":"css基础","link":"/tags/css%E5%9F%BA%E7%A1%80/"},{"name":"wireshark","slug":"wireshark","link":"/tags/wireshark/"},{"name":"css单位","slug":"css单位","link":"/tags/css%E5%8D%95%E4%BD%8D/"},{"name":"css布局","slug":"css布局","link":"/tags/css%E5%B8%83%E5%B1%80/"},{"name":"数据结构","slug":"数据结构","link":"/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"图","slug":"图","link":"/tags/%E5%9B%BE/"},{"name":"docker","slug":"docker","link":"/tags/docker/"},{"name":"docker swarm","slug":"docker-swarm","link":"/tags/docker-swarm/"},{"name":"git","slug":"git","link":"/tags/git/"},{"name":"docker基础","slug":"docker基础","link":"/tags/docker%E5%9F%BA%E7%A1%80/"},{"name":"hexo","slug":"hexo","link":"/tags/hexo/"},{"name":"html5","slug":"html5","link":"/tags/html5/"},{"name":"dom","slug":"dom","link":"/tags/dom/"},{"name":"dom基础","slug":"dom基础","link":"/tags/dom%E5%9F%BA%E7%A1%80/"},{"name":"tips","slug":"tips","link":"/tags/tips/"},{"name":"html5标签和属性","slug":"html5标签和属性","link":"/tags/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"},{"name":"html5 API","slug":"html5-API","link":"/tags/html5-API/"},{"name":"svg","slug":"svg","link":"/tags/svg/"},{"name":"svg基础","slug":"svg基础","link":"/tags/svg%E5%9F%BA%E7%A1%80/"},{"name":"实战","slug":"实战","link":"/tags/%E5%AE%9E%E6%88%98/"},{"name":"Java","slug":"Java","link":"/tags/Java/"},{"name":"Maven","slug":"Maven","link":"/tags/Maven/"},{"name":"svg定位","slug":"svg定位","link":"/tags/svg%E5%AE%9A%E4%BD%8D/"},{"name":"html Permission API","slug":"html-Permission-API","link":"/tags/html-Permission-API/"},{"name":"xml","slug":"xml","link":"/tags/xml/"},{"name":"基础","slug":"基础","link":"/tags/%E5%9F%BA%E7%A1%80/"},{"name":"js","slug":"js","link":"/tags/js/"},{"name":"正则表达式","slug":"正则表达式","link":"/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"js基础","slug":"js基础","link":"/tags/js%E5%9F%BA%E7%A1%80/"},{"name":"异步编程","slug":"异步编程","link":"/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"},{"name":"js对象","slug":"js对象","link":"/tags/js%E5%AF%B9%E8%B1%A1/"},{"name":"js数组","slug":"js数组","link":"/tags/js%E6%95%B0%E7%BB%84/"},{"name":"typescript","slug":"typescript","link":"/tags/typescript/"},{"name":"tslint基础","slug":"tslint基础","link":"/tags/tslint%E5%9F%BA%E7%A1%80/"},{"name":"js对象类型判断","slug":"js对象类型判断","link":"/tags/js%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"},{"name":"数学","slug":"数学","link":"/tags/%E6%95%B0%E5%AD%A6/"},{"name":"高数1","slug":"高数1","link":"/tags/%E9%AB%98%E6%95%B01/"},{"name":"nginx","slug":"nginx","link":"/tags/nginx/"},{"name":"node.js","slug":"node-js","link":"/tags/node-js/"},{"name":"命令行工具","slug":"命令行工具","link":"/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"Open Source","slug":"Open-Source","link":"/tags/Open-Source/"},{"name":"Huaxu","slug":"Huaxu","link":"/tags/Huaxu/"},{"name":"npm","slug":"npm","link":"/tags/npm/"},{"name":"centos7工具","slug":"centos7工具","link":"/tags/centos7%E5%B7%A5%E5%85%B7/"},{"name":"ssh","slug":"ssh","link":"/tags/ssh/"},{"name":"linux远程连接","slug":"linux远程连接","link":"/tags/linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"},{"name":"vue","slug":"vue","link":"/tags/vue/"},{"name":"vue-router","slug":"vue-router","link":"/tags/vue-router/"},{"name":"vue基础","slug":"vue基础","link":"/tags/vue%E5%9F%BA%E7%A1%80/"},{"name":"vue-tips","slug":"vue-tips","link":"/tags/vue-tips/"},{"name":"vue-cli","slug":"vue-cli","link":"/tags/vue-cli/"},{"name":"vue实战","slug":"vue实战","link":"/tags/vue%E5%AE%9E%E6%88%98/"},{"name":"vue博客后台开发","slug":"vue博客后台开发","link":"/tags/vue%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"},{"name":"Webpack","slug":"Webpack","link":"/tags/Webpack/"},{"name":"Webpack实战","slug":"Webpack实战","link":"/tags/Webpack%E5%AE%9E%E6%88%98/"},{"name":"Webpack基础","slug":"Webpack基础","link":"/tags/Webpack%E5%9F%BA%E7%A1%80/"},{"name":"树莓派","slug":"树莓派","link":"/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"vue进阶","slug":"vue进阶","link":"/tags/vue%E8%BF%9B%E9%98%B6/"},{"name":"毕设","slug":"毕设","link":"/tags/%E6%AF%95%E8%AE%BE/"},{"name":"权限","slug":"权限","link":"/tags/%E6%9D%83%E9%99%90/"},{"name":"算法","slug":"算法","link":"/tags/%E7%AE%97%E6%B3%95/"},{"name":"深度优先搜索","slug":"深度优先搜索","link":"/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"《C语言编程魔法书》","slug":"《C语言编程魔法书》","link":"/tags/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E3%80%8B/"},{"name":"《C Primer》","slug":"《C-Primer》","link":"/tags/%E3%80%8AC-Primer%E3%80%8B/"},{"name":"less","slug":"less","link":"/tags/less/"},{"name":"postcss","slug":"postcss","link":"/tags/postcss/"},{"name":"autoprefixer","slug":"autoprefixer","link":"/tags/autoprefixer/"},{"name":"数据库","slug":"数据库","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"mysql","slug":"mysql","link":"/tags/mysql/"},{"name":"导论","slug":"导论","link":"/tags/%E5%AF%BC%E8%AE%BA/"},{"name":"数据库设计","slug":"数据库设计","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"name":"数据库编程","slug":"数据库编程","link":"/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"},{"name":"String","slug":"String","link":"/tags/String/"},{"name":"模式匹配","slug":"模式匹配","link":"/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"name":"sql语句","slug":"sql语句","link":"/tags/sql%E8%AF%AD%E5%8F%A5/"},{"name":"spring-boot","slug":"spring-boot","link":"/tags/spring-boot/"},{"name":"开发工具","slug":"开发工具","link":"/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"读书笔记","slug":"读书笔记","link":"/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"},{"name":"Linux命令行与shell脚本编程","slug":"Linux命令行与shell脚本编程","link":"/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"},{"name":"spring","slug":"spring","link":"/tags/spring/"},{"name":"spring实战","slug":"spring实战","link":"/tags/spring%E5%AE%9E%E6%88%98/"},{"name":"踩坑指南","slug":"踩坑指南","link":"/tags/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"name":"《Linux命令行和Shell脚本编程》","slug":"《Linux命令行和Shell脚本编程》","link":"/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8CShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E3%80%8B/"},{"name":"操作系统","slug":"操作系统","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"linux命令","slug":"linux命令","link":"/tags/linux%E5%91%BD%E4%BB%A4/"},{"name":"ucore","slug":"ucore","link":"/tags/ucore/"},{"name":"操作系统原理","slug":"操作系统原理","link":"/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"ucore-os","slug":"ucore-os","link":"/tags/ucore-os/"},{"name":"安全","slug":"安全","link":"/tags/%E5%AE%89%E5%85%A8/"},{"name":"密码技术","slug":"密码技术","link":"/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"},{"name":"《图解密码技术》","slug":"《图解密码技术》","link":"/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B/"},{"name":"vue组件开发","slug":"vue组件开发","link":"/tags/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"leetcode","slug":"leetcode","link":"/tags/leetcode/"},{"name":"二叉树","slug":"二叉树","link":"/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"},{"name":"分治","slug":"分治","link":"/tags/%E5%88%86%E6%B2%BB/"},{"name":"动态规划","slug":"动态规划","link":"/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"},{"name":"数组","slug":"数组","link":"/tags/%E6%95%B0%E7%BB%84/"},{"name":"链表","slug":"链表","link":"/tags/%E9%93%BE%E8%A1%A8/"},{"name":"设计模式","slug":"设计模式","link":"/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"交给子类","slug":"交给子类","link":"/tags/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"},{"name":"Template Method模式","slug":"Template-Method模式","link":"/tags/Template-Method%E6%A8%A1%E5%BC%8F/"},{"name":"适应设计模式","slug":"适应设计模式","link":"/tags/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"Iterator模式","slug":"Iterator模式","link":"/tags/Iterator%E6%A8%A1%E5%BC%8F/"},{"name":"生成实例","slug":"生成实例","link":"/tags/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"},{"name":"Adapter模式","slug":"Adapter模式","link":"/tags/Adapter%E6%A8%A1%E5%BC%8F/"}],"categories":[{"name":"英语","slug":"英语","link":"/categories/%E8%8B%B1%E8%AF%AD/"},{"name":"生词","slug":"英语/生词","link":"/categories/%E8%8B%B1%E8%AF%AD/%E7%94%9F%E8%AF%8D/"},{"name":"编程语言","slug":"编程语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"},{"name":"计算机网络","slug":"计算机网络","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"},{"name":"C语言","slug":"编程语言/C语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"},{"name":"css","slug":"css","link":"/categories/css/"},{"name":"问题记录","slug":"计算机网络/问题记录","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"},{"name":"学习打卡","slug":"学习打卡","link":"/categories/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/"},{"name":"数据结构","slug":"数据结构","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"docker","slug":"docker","link":"/categories/docker/"},{"name":"git","slug":"git","link":"/categories/git/"},{"name":"css工具","slug":"css/css工具","link":"/categories/css/css%E5%B7%A5%E5%85%B7/"},{"name":"hexo","slug":"hexo","link":"/categories/hexo/"},{"name":"css基础","slug":"css/css基础","link":"/categories/css/css%E5%9F%BA%E7%A1%80/"},{"name":"html5","slug":"html5","link":"/categories/html5/"},{"name":"wireshark","slug":"计算机网络/wireshark","link":"/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wireshark/"},{"name":"Java","slug":"编程语言/Java","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"},{"name":"java","slug":"编程语言/java","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"},{"name":"xml","slug":"xml","link":"/categories/xml/"},{"name":"js","slug":"js","link":"/categories/js/"},{"name":"图","slug":"数据结构/图","link":"/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"},{"name":"nginx","slug":"nginx","link":"/categories/nginx/"},{"name":"docker swarm","slug":"docker/docker-swarm","link":"/categories/docker/docker-swarm/"},{"name":"node.js","slug":"node-js","link":"/categories/node-js/"},{"name":"Open Source","slug":"Open-Source","link":"/categories/Open-Source/"},{"name":"linux","slug":"linux","link":"/categories/linux/"},{"name":"docker基础","slug":"docker/docker基础","link":"/categories/docker/docker%E5%9F%BA%E7%A1%80/"},{"name":"php","slug":"php","link":"/categories/php/"},{"name":"vue","slug":"vue","link":"/categories/vue/"},{"name":"Webpack","slug":"Webpack","link":"/categories/Webpack/"},{"name":"树莓派","slug":"树莓派","link":"/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"},{"name":"毕设","slug":"毕设","link":"/categories/%E6%AF%95%E8%AE%BE/"},{"name":"dom","slug":"html5/dom","link":"/categories/html5/dom/"},{"name":"tips","slug":"html5/tips","link":"/categories/html5/tips/"},{"name":"html5标签和属性","slug":"html5/html5标签和属性","link":"/categories/html5/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"},{"name":"html5 API","slug":"html5/html5-API","link":"/categories/html5/html5-API/"},{"name":"svg","slug":"html5/svg","link":"/categories/html5/svg/"},{"name":"实战","slug":"html5/实战","link":"/categories/html5/%E5%AE%9E%E6%88%98/"},{"name":"基础","slug":"xml/基础","link":"/categories/xml/%E5%9F%BA%E7%A1%80/"},{"name":"正则表达式","slug":"js/正则表达式","link":"/categories/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"},{"name":"js基础","slug":"js/js基础","link":"/categories/js/js%E5%9F%BA%E7%A1%80/"},{"name":"typescript","slug":"js/typescript","link":"/categories/js/typescript/"},{"name":"命令行工具","slug":"node-js/命令行工具","link":"/categories/node-js/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"},{"name":"Huaxu","slug":"Open-Source/Huaxu","link":"/categories/Open-Source/Huaxu/"},{"name":"npm","slug":"node-js/npm","link":"/categories/node-js/npm/"},{"name":"工具","slug":"linux/工具","link":"/categories/linux/%E5%B7%A5%E5%85%B7/"},{"name":"vue-router","slug":"vue/vue-router","link":"/categories/vue/vue-router/"},{"name":"基础","slug":"vue/基础","link":"/categories/vue/%E5%9F%BA%E7%A1%80/"},{"name":"tips","slug":"vue/tips","link":"/categories/vue/tips/"},{"name":"cli","slug":"vue/cli","link":"/categories/vue/cli/"},{"name":"vue实战","slug":"vue/vue实战","link":"/categories/vue/vue%E5%AE%9E%E6%88%98/"},{"name":"Webpack实战","slug":"Webpack/Webpack实战","link":"/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/"},{"name":"Webpack基础","slug":"Webpack/Webpack基础","link":"/categories/Webpack/Webpack%E5%9F%BA%E7%A1%80/"},{"name":"算法","slug":"算法","link":"/categories/%E7%AE%97%E6%B3%95/"},{"name":"C","slug":"编程语言/C","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"},{"name":"深度优先搜索","slug":"算法/深度优先搜索","link":"/categories/%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"},{"name":"语言","slug":"编程语言/C/语言","link":"/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E8%A8%80/"},{"name":"less","slug":"css/less","link":"/categories/css/less/"},{"name":"数据库","slug":"数据库","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"},{"name":"sass","slug":"css/sass","link":"/categories/css/sass/"},{"name":"mysql","slug":"数据库/mysql","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"},{"name":"导论","slug":"数据库/导论","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AF%BC%E8%AE%BA/"},{"name":"数据库设计","slug":"数据库/数据库设计","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"},{"name":"数据库编程","slug":"数据库/数据库编程","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"},{"name":"模式匹配","slug":"算法/模式匹配","link":"/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"},{"name":"sql语句","slug":"数据库/sql语句","link":"/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%AF%AD%E5%8F%A5/"},{"name":"spring-boot","slug":"spring-boot","link":"/categories/spring-boot/"},{"name":"操作系统","slug":"操作系统","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"},{"name":"Java","slug":"Java","link":"/categories/Java/"},{"name":"typescript","slug":"typescript","link":"/categories/typescript/"},{"name":"开发工具","slug":"spring-boot/开发工具","link":"/categories/spring-boot/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"},{"name":"ucore","slug":"操作系统/ucore","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/"},{"name":"shell","slug":"操作系统/shell","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/"},{"name":"spring实战","slug":"Java/spring实战","link":"/categories/Java/spring%E5%AE%9E%E6%88%98/"},{"name":"踩坑指南","slug":"typescript/踩坑指南","link":"/categories/typescript/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"},{"name":"操作系统原理","slug":"操作系统/操作系统原理","link":"/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"},{"name":"安全","slug":"安全","link":"/categories/%E5%AE%89%E5%85%A8/"},{"name":"vue组件开发","slug":"vue/vue组件开发","link":"/categories/vue/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"},{"name":"密码技术","slug":"安全/密码技术","link":"/categories/%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"},{"name":"leetcode","slug":"算法/leetcode","link":"/categories/%E7%AE%97%E6%B3%95/leetcode/"},{"name":"设计模式","slug":"设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"交给子类","slug":"设计模式/交给子类","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"},{"name":"生成实例","slug":"设计模式/生成实例","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"},{"name":"适应设计模式","slug":"设计模式/适应设计模式","link":"/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}]}