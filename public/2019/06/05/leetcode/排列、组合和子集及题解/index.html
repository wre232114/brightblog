<!DOCTYPE html>
<html>

  <head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  
  <title>排列、组合和子集算法及题解 | Bright的个人博客</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <link rel="stylesheet" href="/css/reset.css">
  <link rel="stylesheet" href="/css/style.css">
  
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
      extensions: ["tex2jax.js"],
      jax: ["input/TeX","output/HTML-CSS"],
      tex2jax: {inlineMath: [["$","$"],["\\(","\\)"]]}
    });
  </script>
    <script src="/js/MathJax.js"></script>
  
</head>
  <body>
      
    <header id="header" class="card">
  <span>Bright的个人博客</span>
  <nav>
    <ul>
    
      <li>
        <a href="/">首页 </a>
      </li>
    
      <li>
        <a href="/archives">归档 </a>
      </li>
    
      <li>
        <a href="/categories">分类 </a>
      </li>
    
      <li>
        <i class="fa search">
      </i></li>
    </ul>
  </nav>
</header>
    <main id="main">
    
    
<aside id="left-sidebar" class="margin-right">
  <nav class="card sidebar-component">
  <div class="card-title">文章归档</div>
  <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">23</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">2</span></li></ul>
</nav>
  <nav class="card sidebar-component">
  <div class="card-title">文章分类</div>
  <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/">c/c++</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/c-c/gcc/">gcc</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/">css</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/css/less/">less</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/css/sass/">sass</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/git/">git</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/hexo/">hexo</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/nginx/">nginx</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/php/">php</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/shell/">shell</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/学习打卡/">学习打卡</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/">操作系统</a><span class="category-list-count">3</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/ucore/">ucore</a><span class="category-list-count">2</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统/ucore-os/">ucore-os</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统原理和实现/">操作系统原理和实现</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/操作系统原理和实现/ucore-os/">ucore_os</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/">数据结构</a><span class="category-list-count">1</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/数据结构/二叉树遍历/">二叉树遍历</a><span class="category-list-count">1</span></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/">算法</a><span class="category-list-count">2</span><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/算法/二叉树遍历/">二叉树遍历</a><span class="category-list-count">1</span></li><li class="category-list-item"><a class="category-list-link" href="/categories/算法/深度优先搜索/">深度优先搜索</a><span class="category-list-count">1</span></li></ul></li></ul>
</nav>
  <nav class="card sidebar-component">
  <div class="card-title">最近文章</div>
  <ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2019/06/23/php/Smarty快速入门/">Smarty块度入门</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/22/leetcode/二叉树的层级遍历/">二叉树的层级遍历</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/21/leetcode/由先序、中序遍历结果构造二叉树/">数据结构基础：根据先序、中序遍历结果构造二叉树</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/19/reading-record/Linux命令行和shell脚本编程/shell-script基本语法/">shell script基础</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/18/vue/vue基础：官方文档要点/">vue基础：官方文档要点</a></li><li class="post-list-item"><a class="post-list-link" href="/2019/06/18/math/高数1：函数/">高数1：函数</a></li></ul>
</nav>
</aside>


    <!--
<aside id="right-sidebar">
  <nav class="card margin-bottom">
  
</nav>
</aside>

-->
    <article id="article" class="card margin-right">
      
  <h1>排列、组合和子集算法及题解</h1>
  <hr>
  <h2 id="1-排列、组合以及子集问题"><a href="#1-排列、组合以及子集问题" class="headerlink" title="1. 排列、组合以及子集问题"></a>1. 排列、组合以及子集问题</h2><h3 id="1-1-什么是排列、组合和子集？"><a href="#1-1-什么是排列、组合和子集？" class="headerlink" title="1.1 什么是排列、组合和子集？"></a>1.1 什么是排列、组合和子集？</h3><p>排列分为全排列和普通排列，全排列表示方法：$A{^n_n}$，表示1到n的阶乘（$\prod_{i=1}^ni$），普通排列$A{^m_n}$，表示(n-m+1)到n的阶乘。（这时数学里面的定义）</p>
<p>例如：$A{^3_3}=3*2*1 = 6$，$A{^4_2}=4*3=12$</p>
<p>那全排列有什么应用呢？举个例子，数字排列问题：将1-9排在9个位置，有多少中排法？例如，123456789是一种，213456789也是一种，那么一共多多少种呢？第一个位置有9种情况，第二个位置有8种情况，…，第九个位置有1种情况，总的可能数就是9<em>8</em>7…*1=$A{^9_9}$.</p>
<p>组合和排列类似，但是组合不考虑顺序问题，也就是123和321其实是一种情况。例如：有四个数，要从中选两个数，有几种选法？数学解法是$C{^4_2}=\frac{4<em>3}{2</em>1}=6$，</p>
<p>子集呢？一个n个元素的集合的子集个数是$2^n$个，子集可能是空集，一个元素的集合一直到n个元素的集合。例如集合{1,2}，其子集可能是{$\emptyset$, {1}, {2}, {1,2}}</p>
<h2 id="2-用深度优先算法解决排列、组合和子集问题"><a href="#2-用深度优先算法解决排列、组合和子集问题" class="headerlink" title="2 用深度优先算法解决排列、组合和子集问题"></a>2 用深度优先算法解决排列、组合和子集问题</h2><h3 id="2-1-排列"><a href="#2-1-排列" class="headerlink" title="2.1 排列"></a>2.1 排列</h3><h4 id="2-1-1-问题描述"><a href="#2-1-1-问题描述" class="headerlink" title="2.1.1 问题描述"></a>2.1.1 问题描述</h4><p>输入一系列数字，例如123，给出所有可能的排列结果，例如对于输入123，输出123、132、213、231、321、312.</p>
<h4 id="2-1-2-算法思路"><a href="#2-1-2-算法思路" class="headerlink" title="2.1.2 算法思路"></a>2.1.2 算法思路</h4><p>对于123而言，有三个位置，我们可以枚举每一个位置，在深度优先搜索中位置的个数就是深度。在每一个位置都枚举可能取的值，注意数字不能重。</p>
<p>上代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> permute = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    dfs(<span class="number">0</span>,nums,[],result,[]);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">depth,nums,temp,result,visited</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(depth == nums.length) &#123;</span><br><span class="line">        result.push([].concat(temp));</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i]) &#123;</span><br><span class="line">            visited[i] = <span class="literal">true</span>;</span><br><span class="line">            temp.push(nums[i]);</span><br><span class="line">            dfs(depth+<span class="number">1</span>,nums,temp,result,visited);</span><br><span class="line">            temp.pop(); <span class="comment">// 回溯思想，当前数字被处理了后，在其他情况中还可能需要被处理。</span></span><br><span class="line">            visited[i] = <span class="literal">false</span>; <span class="comment">// 同上</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-2-组合"><a href="#2-2-组合" class="headerlink" title="2.2 组合"></a>2.2 组合</h3><h4 id="2-2-1-问题描述"><a href="#2-2-1-问题描述" class="headerlink" title="2.2.1 问题描述"></a>2.2.1 问题描述</h4><p>给定一个集合{1,2,3}，选出其中的2个数组成新集合，不能重复。例如：输入{1,2,3}，输出[[1,2],[1,3],[2,3]]</p>
<h4 id="2-2-2-算法思路"><a href="#2-2-2-算法思路" class="headerlink" title="2.2.2 算法思路"></a>2.2.2 算法思路</h4><p>我们还是应用深度优先搜索的思想，只不过示例中的深度是2。第一层我们可以取的值是，1|2|3，第一层取了的第二层就不能取了。而且为了避免重复，加入我们第一层取2，那么第二层就不能取1了，因为12，21是相同的。第二层只能从3开始取。</p>
<p>上代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> combination = <span class="function"><span class="keyword">function</span>(<span class="params">nums,m</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = [];</span><br><span class="line">  dfs(<span class="number">0</span>,m,nums,[],result,<span class="number">0</span>);</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// spos是下一次遍历数组时开始的位置，如果上一次我们遍历了1，那么下一次要从2开始，这样才能保证不重复</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">depth,tdep,nums,temp,result,spos</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(depth == tdep) &#123;</span><br><span class="line">      result.push([].concat(temp))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = spos;i &lt; nums.length;i++) &#123;</span><br><span class="line">      temp.push(nums[i]);</span><br><span class="line">      dfs(depth+<span class="number">1</span>,tdep,nums,temp,result,i+<span class="number">1</span>);</span><br><span class="line">      temp.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="2-3-子集"><a href="#2-3-子集" class="headerlink" title="2.3 子集"></a>2.3 子集</h3><h4 id="2-3-1-问题描述"><a href="#2-3-1-问题描述" class="headerlink" title="2.3.1 问题描述"></a>2.3.1 问题描述</h4><p>给定一个集合，比如{1,2,3}，求其所有子集。<br>例如：输入{1,2}，{$\emptyset$, {1}, {2}, {1,2}}</p>
<h4 id="2-3-2-算法思路"><a href="#2-3-2-算法思路" class="headerlink" title="2.3.2 算法思路"></a>2.3.2 算法思路</h4><p>通过观察我们可以发现，一个集合的子集的元素个数是有规律的，子集中的元素有可能有0个（空集），1个，2个，…，n个。</p>
<p>然后我们就可以将问题缩小了，问题变成了从集合中选出1个（2、3、…n）元素组成新集合？我们发现这变成了一个组合问题了。</p>
<p>所以我们的算法分两步，第一步枚举子集元素的个数，假定当前为i，第二步，求出集合中取i个元素构成的子集，我们可以复用上面组合的代码。</p>
<p>上代码：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;number[]&#125; nums</span></span><br><span class="line"><span class="comment"> * @return &#123;number[][]&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> subsets = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>;i &lt;= nums.length;i++)&#123;</span><br><span class="line">        dfs(<span class="number">0</span>,i, nums,[],result,<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 下面时求集合中取tdep个元素的组合，直接复用了求组合的代码</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">dfs</span>(<span class="params">depth,tdep,nums,temp,result,spos</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(depth == tdep) &#123;</span><br><span class="line">      result.push([].concat(temp))</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> i = spos;i &lt; nums.length;i++) &#123;</span><br><span class="line">      temp.push(nums[i]);</span><br><span class="line">      dfs(depth+<span class="number">1</span>,tdep,nums,temp,result,i+<span class="number">1</span>);</span><br><span class="line">      temp.pop();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="3-思考-amp-总结"><a href="#3-思考-amp-总结" class="headerlink" title="3 思考&amp;总结"></a>3 思考&amp;总结</h2><p>这里我们总结排列、组合和子集问题的解法。这是最基本的算法，许多问题可能是这几种思想的变体.</p>
<p>例如，<a href="https://leetcode.com/problems/combination-sum/" target="_blank" rel="noopener">leetcode组合求和问题</a>：给定一个数字集合和一个目标数字，求出所有和是这个数字的数字集合：<br>输入[1,2,3]，4<br>那么输出[[1,3],[2,2]]，因为1+3=4,2+2=4，还要保证不重复。</p>
<p>这个问题可以利用我们前面总结的组合问题的思想，我们求[1,2,3]的组合（这里的组合与上面区别是选取元素个数是不确定的，而且元素可以重复，只要值没到4，就可以一直加）。如果组合集合数字和为4，那么输出这个集合，同时还可以采用回溯的思想优化，如果当前的和或者当前数字的值大于目标数字，那就没必要继续算了，直接回溯。</p>
<p>上面讨论了一种变体，还有很多这类问题的变体，理解了关键思想，就都不困难了。</p>


      </article>
    </main>
    <footer id="footer">
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 Bright<br>
      powered_by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
  </body>
</html>