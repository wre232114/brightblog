<!doctype html>
<html lang="de"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Bright的个人博客</title><meta description="前端开发的技术分享和个人笔记总结"><meta property="og:type" content="blog"><meta property="og:title" content="Bright的个人博客"><meta property="og:url" content="https://www.brightblog.cn/"><meta property="og:site_name" content="Bright的个人博客"><meta property="og:description" content="前端开发的技术分享和个人笔记总结"><meta property="og:image" content="https://www.brightblog.cn/img/og_image.png"><meta property="article:author" content="Bright"><meta property="article:tag" content="前端开发 个人博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.brightblog.cn"},"headline":"Bright的个人博客","image":["https://www.brightblog.cn/img/og_image.png"],"author":{"@type":"Person","name":"Bright"},"description":"前端开发的技术分享和个人笔记总结"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-13T12:42:11.000Z" title="2019-12-13T12:42:11.000Z">2019-12-13</time><span class="level-item"><a class="link-muted" href="/categories/css/">css</a><span> / </span><a class="link-muted" href="/categories/css/css%E5%9F%BA%E7%A1%80/">css基础</a></span><span class="level-item">a few seconds read (About 0 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/13/css/css%E5%B8%83%E5%B1%80%EF%BC%9Aflex/">css布局：flex</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-13T10:34:09.000Z" title="2019-12-13T10:34:09.000Z">2019-12-13</time><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/leetcode/">leetcode</a></span><span class="level-item">8 minutes read (About 1142 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/13/algorithm/leetcode/%E6%95%B0%E7%BB%84/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9AShortest-Unsorted-Continuous-Subarray/">leetcode题解：Shortest Unsorted Continuous Subarray</a></h1><div class="content"><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given an integer array, you need to find one continuous subarray that if you only sort this subarray in ascending order, then the whole array will be sorted in ascending order, too.</p>
<p>You need to find the shortest such subarray and output its length.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Example 1:</span><br><span class="line">Input: [2, 6, 4, 8, 10, 9, 15]</span><br><span class="line">Output: 5</span><br><span class="line">Explanation: You need to sort [6, 4, 8, 10, 9] in ascending order to make the whole array sorted in ascending order.</span><br></pre></td></tr></table></figure><br>Note:</p>
<ol>
<li>Then length of the input array is in range [1, 10,000].</li>
<li>The input array may contain duplicates, so ascending order here means &lt;=.</li>
</ol>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>题目要求是：给定一个数组，找到最小的未升序排序的连续子数组，或者说，找到一个最小连续子数组，将这个子数组排序后，整个数组是升序的。</p>
<p>很简单的一个思路是，复制一个一模一样的数组，将复制后的数组排序，然后比较排序后的数组和排序前的数组，就看出来哪一个最小连续子数组是无序的。具体的比较方式是，逐个数组元素从前向后和从后向前比较，直到找到前面不相等的位置和后面不相等的位置，中间的子数组就是需要排序的。例如对于<code>[2,6,4,8,10,9,15]</code>有：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">input:       [2,6,4,8,10,9,15]</span><br><span class="line">sorted copy: [2,4,6,8,9,10,15]</span><br></pre></td></tr></table></figure><br>一对比，前面2==2，6!=4，后面15==15，9!=10。所以最小连续无序的子数组是<code>[6,4,8,19,9]</code>。或者这样想，我将这个子数组排序后，才能让原数组有序。上代码，注意边界条件的处理：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findUnsortedSubarray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> numst = [].concat(nums);</span><br><span class="line">    numst.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> a - b;</span><br><span class="line">    &#125;);</span><br><span class="line">    <span class="keyword">var</span> p1 = <span class="number">0</span>, p2 = nums.length<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">while</span>((nums[p1] == numst[p1] || nums[p2] == numst[p2]) &amp;&amp; p1 &lt;= p2) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[p1] == numst[p1] &amp;&amp; p1 &lt;= p2) p1++;</span><br><span class="line">        <span class="keyword">if</span>(nums[p2] == numst[p2] &amp;&amp; p1 &lt;= p2) p2--;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> p2-p1+<span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>时间复杂度O(nlogn)，空间复杂度O(n)。</p>
<blockquote>
<p>注意：js中的Array.prototype.sort方法，接收一个参数，该参数是带有两个参数的函数；如果没有该函数，<strong>默认按照升序排列，排序规则是将所有元素转成字符串，然后按照utf-16字符串来排序</strong>，这样和数字排序有什么区别呢？utf-16的数字的码点不一定是有序的，而且’10’和’9’按照字符串排序’10’是小于’9’的，因为逐个字符比较，’1’&lt;’9’。使用sort的函数参数可以自定义排序规则，该函数的两个参数分别表示比较的两个元素，这两个元素的类型和数组元素的类型相同；如果函数返回负数，表示第一个参数a的index在第二个参数b后面，如果返回0，表示两者的相对位置不变，但是仍会和其他元素一起排序；如果返回整数，表示a在b后面。</p>
</blockquote>
<h2 id="更好的解法"><a href="#更好的解法" class="headerlink" title="更好的解法"></a>更好的解法</h2><p>上面给出的解法时间复杂度O(nlogn)，空间复杂度O(n)。能不能给出一种时间复杂度O(n)，空间复杂度O(1)的解法呢？肯定是可以的，通过两次线形遍历，可以找出来哪一部分是无序的。</p>
<p>对于一个数组，我们线形遍历希望找出最前面的不满足有序的边界，再找出后面的边界，两个边界之间就是需要排序的数组。从左到右，肯定希望是升序的，如果遇到了逆序，那么该逆序对的较小元素与左边肯定存在一个连续数组需要排序；从左到右遍历，并记住遍历过的部分的最大的元素，向右遍历时右边比左边最大元素小的都是逆序。这样过一遍，我们就找到了最右边的需要排序的边界，但是左边的还不知道。同样的原理，从右向左过一遍就能找到左边的边界。</p>
<p>例如，对于<code>[2,6,4,8,10,9,15]</code>：</p>
<ul>
<li>（从左向右）初始rEdge=-1，max=2，min=15，lEdge=-1</li>
<li>遍历6，6&gt; max，max = 6，rEdge = -1</li>
<li>遍历4，4&lt; max，max = 6，rEdge = 2</li>
<li>遍历8，8&gt; max，max = 8，rEdge = 2</li>
<li>…</li>
<li>遍历9，9&lt; max，max = 10，rEdge = 5</li>
<li>遍历15，15&gt; max，max = 15，rEdge = 5</li>
<li>(从右向左)…</li>
<li>遍历2，2&lt; min，min=2，lEdge = 1</li>
</ul>
<p>代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findUnsortedSubarray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> lEdge = <span class="number">-1</span>, rEdge = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> temp = nums[<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>;i &lt; nums.length;i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp &lt;= nums[i]) temp = nums[i];</span><br><span class="line">        <span class="keyword">else</span> rEdge = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(rEdge == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    temp = nums[nums.length<span class="number">-1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = nums.length - <span class="number">2</span>;i&gt;=<span class="number">0</span>;i--) &#123;</span><br><span class="line">        <span class="keyword">if</span>(temp &gt;= nums[i]) temp = nums[i];</span><br><span class="line">        <span class="keyword">else</span> lEdge = i;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rEdge - lEdge + <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>时间复杂度O(n)，空间复杂度O(1)。注意相等的情形。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-13T02:05:34.000Z" title="2019-12-13T02:05:34.000Z">2019-12-13</time><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/leetcode/">leetcode</a></span><span class="level-item">5 minutes read (About 688 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/13/algorithm/leetcode/%E4%BA%8C%E5%8F%89%E6%A0%91/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9AMerge-Two-Binary-Trees/">leetcode题解：Merge Two Binary Trees</a></h1><div class="content"><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p>
<p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">	Tree 1                     Tree 2                  </span><br><span class="line">          1                         2                             </span><br><span class="line">         &#x2F; \                       &#x2F; \                            </span><br><span class="line">        3   2                     1   3                        </span><br><span class="line">       &#x2F;                           \   \                      </span><br><span class="line">      5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">	     3</span><br><span class="line">	    &#x2F; \</span><br><span class="line">	   4   5</span><br><span class="line">	  &#x2F; \   \ </span><br><span class="line">	 5   4   7</span><br></pre></td></tr></table></figure></p>
<p>Note: The merging process must start from the root nodes of both trees.</p>
<h2 id="问题解析"><a href="#问题解析" class="headerlink" title="问题解析"></a>问题解析</h2><p>这个题的要求是：给定两棵树，然后将这两棵树重叠，两个非空的重叠的节点的值相加作为新节点的值，一个空一个不空的重叠的节点，不空的直接覆盖空的。</p>
<p>我们很容易想到，同时深度优先遍历两颗二叉树，即两个树中每次遍历的节点在树中的位置相同。如果两个节点非空，直接相加作为新的重合节点。在遍历时，可以以一棵树为基准，例如就遍历左边的树。那如果遇到了左边子树为空，右边子树不空的情况呢？需要再遍历右边的子树吗？当然不用，直接将右边的子树拿过来就可以了。</p>
<p>所以遍历的时候，以其中一棵树为基准，只有两个树相同位置的节点都不为空时继续遍历。同时也不同新建一个树来存储，可以直接将结果放在基准树中。</p>
<p>这里可以采用前序遍历，有递归和非递归两种形式，下面分别给出代码：</p>
<p>递归形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> recursive(t1,t2);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">recursive</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(t1 &amp;&amp; t2) &#123;</span><br><span class="line">        t1.val = t1.val + t2.val;</span><br><span class="line">        t1.left = recursive(t1.left, t2.left);</span><br><span class="line">        t1.right = recursive(t1.right, t2.right);</span><br><span class="line">        <span class="keyword">return</span> t1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> t1 || t2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>注意递归形式中，递归处理左子树和右子树，当其中一个节点为空时，直接返回非空节点即可。</p>
<p>非递归形式：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mergeTrees = <span class="function"><span class="keyword">function</span>(<span class="params">t1, t2</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">var</span> stack = [], h = t1 || t2,p = [];</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(t1 &amp;&amp; t2) &#123;</span><br><span class="line">            stack.push([t1,t2]);</span><br><span class="line">            t1.val = t1.val + t2.val</span><br><span class="line">            p[<span class="number">0</span>] = t1;</span><br><span class="line">            t1 = t1.left;</span><br><span class="line">            t2 = t2.left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果左边为空，并且有父节点，将右边相同位置的节点直接赋过来</span></span><br><span class="line">            <span class="keyword">if</span>(!t1 &amp;&amp; p[<span class="number">0</span>]) &#123;</span><br><span class="line">                <span class="comment">// 需要判断处理的是父节点的左子树还是右子树</span></span><br><span class="line">                <span class="keyword">if</span>(stack.length &amp;&amp; stack[stack.length<span class="number">-1</span>][<span class="number">0</span>] == p[<span class="number">0</span>]) p[<span class="number">0</span>].left = t2;</span><br><span class="line">                <span class="keyword">else</span> p[<span class="number">0</span>].right = t2;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 出栈，访问右子树</span></span><br><span class="line">            <span class="keyword">if</span>(stack.length) &#123;</span><br><span class="line">                p = stack.pop();</span><br><span class="line">                t1 = p[<span class="number">0</span>].right;t2 = p[<span class="number">1</span>].right;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(!stack.length) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> h;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>注意非递归形式我们要记住父节点，同时要判断当前处理的是父节点的左子节点还是右子节点。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-11T23:12:56.000Z" title="2019-12-11T23:12:56.000Z">2019-12-12</time><span class="level-item"><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/">算法</a><span> / </span><a class="link-muted" href="/categories/%E7%AE%97%E6%B3%95/leetcode/">leetcode</a></span><span class="level-item">5 minutes read (About 694 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/12/algorithm/leetcode/%E9%93%BE%E8%A1%A8/leetcode%E9%A2%98%E8%A7%A3%EF%BC%9APalindrome-Lined-List/">leetcode题解：Palindrome Lined List</a></h1><div class="content"><h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>Given a singly linked list, determine if it is a palindrome.</p>
<p>Example 1:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><br>Example 2:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;2-&gt;1</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><br>Follow up:<br>Could you do it in O(n) time and O(1) space?</p>
<h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>本题需要判断一个链表是不是一个回文串，回文串的性质是顺着读和倒着读是完全一样的，即$a_{i}=a_{n-i-1}$。在数组中我们只要顺着和倒着比一遍就可以了，但是在链表中，只能单向遍历，现在要解决的问题就是如何反向遍历。</p>
<p>在不考虑时间复杂度和空间复杂度的情况下，很容易想到下面两种方案：</p>
<p>方案1：找到节点$a_{i}$和$a_{n-i-1}$，比较两者，其中i&lt;=n/2。这样的时间复杂度是$O(n^2)$，空间复杂度是<code>O(1)</code>。<br>方案2：利用栈反转链表，然后逐个比较，这样的时间复杂度是O(n)，空间复杂度是O(n)。</p>
<p>然而我们的最佳方案需要O(n)的时间复杂度，O(1)的空间复杂度，能不能进一步优化呢？答案是肯定的。在方案2中我们利用栈反转链表，那么能不能不用栈就反转链表呢？答案也是肯定的，这个题是可以改变原链表的，所以我们直接修改原链表没有问题。O(n)时间复杂度，O(1)空间复杂度的反转链表的算法如下：</p>
<ol>
<li>两个指针a,b初始都指向链表头部，移动b到b-&gt;next</li>
<li>临时指针指向头部a，a=b，b=b-&gt;next，a-&gt;next=临时指针</li>
<li>重复2，直到b为空</li>
</ol>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">a  b</span><br><span class="line">A-&gt;B-&gt;C-&gt;D</span><br><span class="line">   a b</span><br><span class="line">A&lt;-B C-&gt;D</span><br><span class="line">      a b</span><br><span class="line">A&lt;-B&lt;-C D</span><br><span class="line">         a  b</span><br><span class="line">A&lt;-B&lt;-C&lt;-D-&gt;NULL</span><br></pre></td></tr></table></figure>
<p>最终方案：将链表分成左右两部分，反转右边的部分，然后逐次比较左右是否相同。</p>
<blockquote>
<p>寻找链表的中间位置：通过两个指针遍历，一个步长为1，另一个步长为2，这样就可以找到中间位置。奇数个节点找到的是最中间的，偶数个找到的是中间靠右的。</p>
</blockquote>
<h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     struct ListNode *next;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">struct ListNode* <span class="title">findCenterNode</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp1</span> = <span class="title">head</span>, *<span class="title">temp2</span> = <span class="title">head</span>;</span></span><br><span class="line">  <span class="keyword">while</span>(temp2 &amp;&amp; temp2-&gt;next) &#123;</span><br><span class="line">    temp1 = temp1-&gt;next;</span><br><span class="line">    temp2 = temp2-&gt;next-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct ListNode* <span class="title">reverseLinkedList</span><span class="params">(struct ListNode* head)</span> </span>&#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span> *<span class="title">temp1</span> = <span class="title">head</span>, *<span class="title">temp2</span> = <span class="title">head</span>-&gt;<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">  temp1-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">  <span class="keyword">while</span>(temp2) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">temp</span> = <span class="title">temp1</span>;</span></span><br><span class="line">    temp1 = temp2;</span><br><span class="line">    temp2 = temp2-&gt;next;</span><br><span class="line">    temp1-&gt;next = temp;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> temp1;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(struct ListNode* head)</span></span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(head == <span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">cNode</span> = <span class="title">findCenterNode</span>(<span class="title">head</span>);</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">reversedNode</span> = <span class="title">reverseLinkedList</span>(<span class="title">cNode</span>);</span></span><br><span class="line">  </span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ListNode</span>* <span class="title">p1</span> = <span class="title">head</span>, *<span class="title">p2</span> = <span class="title">reversedNode</span>;</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(p1 != cNode &amp;&amp; p2 != <span class="literal">NULL</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(p1-&gt;val != p2-&gt;val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    p1 = p1-&gt;next;</span><br><span class="line">    p2 = p2-&gt;next;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-03T03:20:50.000Z" title="2019-12-03T03:20:50.000Z">2019-12-03</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">33 minutes read (About 4944 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B04%EF%BC%9Abios%E5%92%8Cbootloader%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">ucore-os笔记4：bios和bootloader的启动过程</a></h1><div class="content"><p>这篇笔记学习BIOS和bootloader的执行过程，将详细分析机器加电后执行的第一条指令到操作系统的第一行代码中间经历的过程。</p>
<h2 id="BOIS的启动过程"><a href="#BOIS的启动过程" class="headerlink" title="BOIS的启动过程"></a>BOIS的启动过程</h2><p>计算机开机后并不是直接启动操作系统，而是先要执行一小部分初始化软件。在80386体系结构下由BIOS和BOOTLOADER组成。BOIS是存储在主板上ROM中的一个小程序，承担了最基础的输入输出功能（电脑没装系统时，我们也可以进入BOIS，BOIS中可以看到计算机的硬件信息，设置启动盘等等，其包括了对硬件最最基本的访问能力）。</p>
<p>计算机加电后，将BIOS加载内存中开始执行。会从一条特定的地址开始执行，该指令调转到BIOS程序的起始地址执行。BIOS会检测硬件并进行初始化，然后会选择一个启动设备。然后将该设备的第一个扇区（512字节）加载到内存的特定地址（0x7c00）。然后将控制权转交给0x7c00地址处的程序开始执行。</p>
<p>简单来说，当我们按下电脑的开机键后，CPU会进行如下的处理：</p>
<ol>
<li>BIOS被加载到内存中</li>
<li>CPU的第一条指令是调转到BIOS程序的第一条指令（1、2步都是硬件预先设计好的）</li>
<li>开始执行BIOS，BIOS会初始化显示器、检测计算机总线上连接的所有硬件；一切正常后将启动盘的第一个扇区（512个字节）加载到内存的0x7c00处，然后调转到0x7c00执行。所以我们的bootloader会放在磁盘的第一个扇区，大小小于512字节，BIOS执行完了就会执行bootloader的指令。</li>
<li>bootloader执行，切换执行模式，加载操作系统内核，将控制权交给操作系统。</li>
<li>操作系统初始化</li>
</ol>
<blockquote>
<p>BIOS初始化是硬件自动的。启动的时候，硬件会将BIOS映射到高位内存地址中，以保证向下兼容8086的启动模式。</p>
</blockquote>
<h2 id="bootloader的启动过程"><a href="#bootloader的启动过程" class="headerlink" title="bootloader的启动过程"></a>bootloader的启动过程</h2><p>BIOS读取硬件扇区到0x7c00的内存中，并调转到0x7c00执行。所以bootloader被放在0x7c00的位置开始执行。（<strong>所以在makefile中链接bootblock的时候，将代码段地址设置成0x7c00。目前不懂这里链接指定的地址有什么用？后面学会了回来该</strong>）</p>
<p>bootloader的主要工作是：</p>
<ul>
<li>切换到保护模式，启用分段机制</li>
<li>读取ELF执行文件格式ucore操作系统到内存中</li>
<li>显示字符串信息</li>
<li>把控制权交给ucore操作系统</li>
</ul>
<p>接下来我们详细分析下面两个部分：</p>
<ul>
<li>如何切换到保护模式？（如果不了解什么是保护模式，请先阅读<a href="#">实模式与保护模式</a>）</li>
<li>如何读取ELF执行文件格式？（如果不了解elf文件格式，请先阅读<a href="#">elf文件结构</a>）</li>
</ul>
<h3 id="如何从实模式切换到保护模式"><a href="#如何从实模式切换到保护模式" class="headerlink" title="如何从实模式切换到保护模式"></a>如何从实模式切换到保护模式</h3><p>从实模式切换到保护模式要经历两个步骤：</p>
<ol>
<li>开启a20 gate</li>
<li>启用80386的分段机制实现保护</li>
</ol>
<p>下面分别说明这两个部分：</p>
<ol>
<li>开启a20 gate<br>8086处理器是16位的，只能以实模式运行，最大只能访问1MB内存。但是通过segment:offset的形式，可以得到高于1MB的地址。在这种情况下，8086会将高于1MB的地址“回卷”（只取前20位，溢出的部分舍弃），变成低于1MB的地址。一些8086的软件用到了这样的特性。在80386中，最大内存是4GB，超过1MB就不会“回卷”了，这样就不向下兼容了。所以有了A20 gate（A0-A19是20根地址线），A20 gate默认是不启用的，这样实模式下就只能访问1MB的内存，<strong>保证向下兼容</strong>。</li>
</ol>
<p><strong>因为a20 gate只是控制第21根地址的开启和关闭</strong>。在80386下（大于1MB的内存），如果开启了a20 gate：</p>
<ul>
<li>实模式下就可以访问<code>ffff0+0ffff=10ffef=1088KB</code>的内存，超出的64KB也能访问；</li>
<li>保护模式下能够访问完整的4G内存</li>
</ul>
<p>如果没有开启a20 gate：</p>
<ul>
<li>实模式下只能访问1MB的内存</li>
<li>保护模式下，<strong>a20始终位0</strong>，那么只能访问奇数兆的内存0-1M，2-3M…</li>
</ul>
<p>计算机开机以后是以实模式运行，我们的操作系统是面向32位CPU设计的，所以在bootloader中要启用全部的32根地址线。从实模式切换到保护模式的第一步就是开启a20 gate。</p>
<p>a20 gate的开启和关闭使用<strong>通过键盘控制器8042来控制</strong>的（需要通过一种方式来控制a20的开启和关闭，工程师们为了<strong>节省硬件设计成本</strong>将其集成到了键盘控制器中，a20 gate和键盘没有关系），所以我们需要通过io指令向键盘控制器8042发出控制命令，启用a20。bootasm.S中相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60</span><br></pre></td></tr></table></figure><br><img src="/img/8042键盘控制器.png" alt="8042键盘控制器"><br>8042对外暴露了两个端口：0x60和0x64，下面是对8042的简单介绍：</p>
<ul>
<li>键盘控制器的端口是0x60-0x6f，但是只使用了0x60和0x64两个端口。通过这两个端口给键盘控制器发送命令或者读取状态</li>
<li><p>8042有两个寄存器，一个是状态寄存器，保存了控制器当前的状态信息（键盘使用启用，buffer中是否有数据等），另一个是控制寄存器。状态寄存器各位信息如下：<br>  | bit  | meaning  |<br>  |—|—|<br>  |0 |output    register    (60h)    中有数据|<br>  |1 |input    register    (60h/64h)    有数据|<br>  |2 |系统标志(上电复位后被置为0)|<br>  |3 |data    in    input    register    is    command    (1)    or    data    (0)|<br>  |4 |1=keyboard    enabled,    0=keyboard    disabled    (via    switch)|<br>  |5 |1=transmit    timeout    (data    transmit    not    complete|)<br>  |6 |1=receive    timeout    (data    transmit    not    complete)|<br>  |7 |1=even    parity    rec’d,    0=odd    parity    rec’d    (should    be    odd)|</p>
</li>
<li><p>0x64端口用于写入命令，读取状态信息。0x60用于写入和读取数据。在0x64端口状态信息；写0x64端口写入命令。</p>
</li>
<li>8042有两个内部端口（上图中有），这两个内部端口在内部电路中使用，程序员不可见，但是通过向0x64端口写入特定的命令可以改变这两个端口的数据。我们本次要改的a20控制就在内部输出端口的p21，这个信号控制a20的开启和关闭。</li>
</ul>
<p>设置键盘控制器的步骤是：</p>
<ol>
<li>等待8042的输入缓存为空。等待上一条IO命令结束，结束后会清空标识寄存器。因为CPU的速度远快于IO设备的速度，所以一定要加这个判断。</li>
<li>向0x64写入设置内部输出端口的命令</li>
<li>等待输入缓存为空</li>
<li>向0x60写入要设置的值</li>
</ol>
<p>在代码中，<code>inb $0x64,%al</code>和<code>testb 0x2,%al</code>用于判断键盘控制器的输入缓存是否为空。0x2=00000010，对照上面状态寄存器的第二位，1表示input register中有数据，当有数据时，重复，直到没有数据为止。</p>
<p>然后向0x64写入命令0xd1，表示写内部输出端口，然后写入0xdf(11011111)，将p21置高电平，其他的位可以不管，是键盘控制器细节相关的，我们这里只了解一下就可以了。</p>
<blockquote>
<p>计算机接口技术课程的相关知识：一个IO设备控制器一般会占用多个端口，分别是状态端口、数据端口、控制端口，一般都是通过控制端口输入控制字，控制字可以设置要对IO控制器进行的操作，如读取IO设备状态、向设备写入数据等等；控制寄存器用于写入IO设备控制器的操作命令，通过改变控制寄存器的相关位，就可以改变控制器的工作模式，例如从写数据切换到读数据。通过地址总线或者IO总线来寻址到特定设备端口，通过数据总线向控制器端口写入或者读取数据，通过控制总线发出一些特定的控制信号。一般来说IO操作的步骤是：</p>
<p>1.向IO设备控制器的控制端口写入控制字<br>2.根据控制字的设置向数据端口写入或者从数据端口读取数据</p>
<p>Intel 80386相关知识：通过out指令寻址的IO设备使用的是IO地址空间，该地址空间和内存地址空间独立。</p>
</blockquote>
<ol start="2">
<li>开启分段机制进入保护模式<blockquote>
<p>这里需要了解保护模式的知识（请学习<a href="#">GDT与保护模式</a>）</p>
</blockquote>
</li>
</ol>
<p>先看bootasm.S中的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure><br>80386及之后的CPU提供了保护模式，主要通过GDTR寄存器和GDT（全局描述符表）来实现。GDTR中存了GDT的入口地址。第一步我们将GDT的地址加载到GDTR寄存器中，使用<code>lgdt gdtdesc</code>从内存中加载GDT的大小和地址到GDTR寄存器中。注意这个时候cr0寄存器中的PE位没有打开，所以CPU还没有启用分段机制，所以此时的内存访问就不涉及到分段的问题。</p>
<p>接下来设置cr0中的PE位，开启了CPU的保护模式。这时候就要设置段寄存器的值了，因为接下来的内存访问就会从GDT中取找对应的段了。所以接下来通过ljmp设置CS寄存器的值，因为CS寄存器的值只能通过调转指令间接设置。然后通过mov指令设置其他段寄存器的值。这样我们就开启了CPU的保护模式。</p>
<h3 id="如何加载操作系统"><a href="#如何加载操作系统" class="headerlink" title="如何加载操作系统"></a>如何加载操作系统</h3><p>前面提到了操作系统的加载由bootloader来实现，bootloader是放在硬盘第一个扇区、大小小于512字节的一段程序，bootloader主要做了两部分的工作，一个是<code>从实模式切换到保护模式</code>，另一个是<code>加载操作系统到ram中并移交控制权</code>。前面我们讨论了如何从实模式切换到保护模式，这里如何加载操作系统。</p>
<p>要理解如何加载操作系统，需要直到两方面的知识，第一个是操作系统的格式细节，这里我们使用的操作系统是ELF格式；另一个如何访问硬盘。下面我们先分别介绍这两方面的知识，因为只有直到ELF文件的格式之后，才能直到如何去读取操作系统并运行。</p>
<h4 id="ELF文件格式介绍"><a href="#ELF文件格式介绍" class="headerlink" title="ELF文件格式介绍"></a>ELF文件格式介绍</h4><p>ELF(Executable    and    linking    format)文件格式是Linux系统下的一种常用目标文件(object file)格<br>式，有三种主要类型:</p>
<ul>
<li>用于执行的可执行文件(executable file),用于提供程序的进程映像,加载的内存执行。<br>这也是本实验的OS文件类型。</li>
<li>用于连接的可重定位文件(relocatable file),可与其它目标文件一起创建可执行文件和共<br>享目标文件。</li>
<li>共享目标文件(shared object file),连接器可将它与其它可重定位文件和共享目标文件连接<br>成其它的目标文件,动态连接器又可将它与可执行文件和其它共享目标文件结合起来创<br>建一个进程映像。</li>
</ul>
<blockquote>
<p>参考资料：<img src="http://www.skyfree.org/linux/references/ELF_Format.pdf" alt="ELF_format"><br>这里只介绍第一种，也就是可执行文件的格式。</p>
</blockquote>
<p><a href="/img/elf-overview.png">elf-overview</a></p>
<p>可以看到ELF文件最开始的部分是ELF header，header包含了elf文件的所有信息，包括程序的每一部分大小、位置等等。对于可执行文件，其次最重要的就是<code>program header table(pht)</code>，pht包含了如何创建一个进程映像的信息，可执行文件必须含有pht。pht并不一定就紧跟在header后面，除了elf header以外的其他部分的顺序是不确定的。</p>
<h5 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_magic;     <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> e_type;      <span class="comment">// 1=relocatable, 2=executable, 3=shared object, 4=core image</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_machine;   <span class="comment">// 3=x86, 4=68K, etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_version;   <span class="comment">// file version, always 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_entry;     <span class="comment">// entry point if executable</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_phoff;     <span class="comment">// file position of program header or 0，程序头表在文件中的字节偏移。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_shoff;     <span class="comment">// file position of section header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_flags;     <span class="comment">// architecture-specific flags, usually 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_ehsize;    <span class="comment">// size of this elf header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phentsize; <span class="comment">// size of an entry in program header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phnum;     <span class="comment">// number of entries in program header or 0，程序头表的项数。</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shentsize; <span class="comment">// size of an entry in section header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shnum;     <span class="comment">// number of entries in section header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shstrndx;  <span class="comment">// section number that contains section name strings</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>elf header的前16个字节用于标识一个elf文件，前四个字节是magic number，表示这个文件是一个elf文件，后面的12个字节表示elf文件类别，平台等等，这里没有用到，所以我们用<code>uchar elf[12]</code>表示了。其他重要的有entry——程序入口的虚拟地址、program header和phnum。</p>
<p>对于可执行文件其次最重要的是program header，program header是一个特定结构的数组，数组中的每一个元素代表一个section。结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_type;   <span class="comment">// loadable code or data, dynamic linking info,etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_offset; <span class="comment">// file offset of segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_va;     <span class="comment">// virtual address to map segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_pa;     <span class="comment">// physical address, not used</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_filesz; <span class="comment">// size of segment in file</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_memsz;  <span class="comment">// size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_flags;  <span class="comment">// read/write/execute bits</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_align;  <span class="comment">// required alignment, invariably hardware page size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>包含section的偏移，虚拟地址、物理地址、大小等等信息。ucore-os的加载将会利用这些信息，将每一个段加载到指定的内存地址中。</p>
<blockquote>
<p>elf其他格式的解析，会结合操作系统程序的链接、加载一起学习，请看<a href="#">操作系统程序的链接、加载</a></p>
</blockquote>
<h4 id="硬盘访问概述"><a href="#硬盘访问概述" class="headerlink" title="硬盘访问概述"></a>硬盘访问概述</h4><p>当前硬盘数据是储存到硬盘扇区中,一个扇区大小为512字节。读一个扇区的流程(可参看<br>boot/bootmain.c中的readsect函数实现)大致如下:</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p>硬盘访问的具体细节，我们在其他的文章中学习，因为涉及到计算机接口、计算机组成原理等的知识，请看<a href="#">x86下的IO访问详解</a></p>
<h4 id="操作系统加载"><a href="#操作系统加载" class="headerlink" title="操作系统加载"></a>操作系统加载</h4><p>前面我们了解了基础知识，接下来分析操作系统的加载过程，首先分析代码中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the 1st page off disk</span></span><br><span class="line"><span class="comment">// 读取磁盘的第一页到内存中的ELFHRD（0x10000）位置，1页是4K，8个扇区。</span></span><br><span class="line"><span class="comment">// ELF可执行文件的ELF头在最开始的位置，这里将头读出来，然后根据头中的信息去读程序信息</span></span><br><span class="line">readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is this a valid ELF?</span></span><br><span class="line"><span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line"><span class="comment">// ph是程序头段的开始地址</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line"><span class="comment">// eph是程序头段的结束地址（指针+数字的值是：指针值+数据类型大小*数字）</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">    <span class="comment">// 这里p_offset按照扇区对齐去读</span></span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return</span></span><br><span class="line"><span class="comment">// 将ELF文件读入之后，到elf程序的开始地址执行</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br></pre></td></tr></table></figure><br>最开始直接将硬盘的第一页读取到设定的内核起始位置0x10000，注意这个是从第二个扇区开始读，因为第一个扇区是bootloader，所以有<code>offset / SECSIZE + 1</code>。读取的第一页中可能也包含了其他的段，但是这里我们只关心elf header，其他的段后段会再读，读的时候可能会覆盖本次读的段，这些都没有问题。事实上我们也可以按照扇区大小和header的大小向上取整读若干个扇区，但是这里为了方便就直接读一页了。</p>
<p>硬盘读取是一次读取一个扇区，所以我们的硬盘访问分为两个方面：</p>
<p>第一个是按照段来解析，从program header中读取每一个段的虚拟地址、大小和偏移，虚拟地址是加载到内存中的地址，虚拟地址+大小就能确定这个段的范围；这里要注意偏移是指段在文件中的偏移位置，不一定按照扇区对齐了，而读取硬盘却是按照一个一个扇区读取的，所以我们要按照扇区来对齐进行读取，<code>offset / SECSIZE + 1</code>就是扇区号（从1开始，因为0是bootloader），而且这里将硬盘中的内容加载到<strong>连续的内存中</strong>，offset向下取整了，所以其映射到内存位置也要向下调整，所以有<code>va -= offset % SECSIZE</code>。</p>
<p>第二个是按照扇区来读，前面我们已经得到了段的范围和偏移，由偏移可以确定起始扇区，范围可以确定扇区的个数。先按照扇区对齐，然后逐个读入扇区到内存中，就将对应的段加载到了内存中。</p>
<p>最后调用<code>((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))()</code>，将入口地址作为一个没有返回值没有参数的函数指针调用，就将控制权交给了操作系统，后面执行的就是操作系统内核代码了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-03T01:41:03.000Z" title="2019-12-03T01:41:03.000Z">2019-12-03</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">9 minutes read (About 1395 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B03%EF%BC%9Aqemu%E5%92%8Cgdb%E8%B0%83%E8%AF%95/">ucore-os笔记4：qemu和gdb调试</a></h1><div class="content"><p>本篇笔记我们学习qemu和gdb调试，这是调试操作系统内核代码必备的技能。</p>
<p>qemu是通用开源的硬件模拟器，可以模拟完整计算机系统，包括多种CPU架构（x86、x86_61、MIPS、ARM等）、系统总线（PCI、ISA桥等）、VGA显示、PS/2键鼠、PCI和ISA网络适配器、串行端口、USB。这里我们不详细讨论所有的相关知识，只学习我们目前使用到的这一部分。</p>
<p>gdb是gnu调试工具，可以调试编译后的程序。我们在编译操作系统时，要使用GCC的-g选项生成调试信息才能使用gdb调试。gdb提供了单步调试，指令单步调试，调用栈显示等等功能。</p>
<h2 id="qemu基础知识"><a href="#qemu基础知识" class="headerlink" title="qemu基础知识"></a>qemu基础知识</h2><p>通过qemu命令就可以启动qemu模拟器，通过qemu命令的参数可以指令模拟的硬件的参数，例如指定硬盘、串行端口、CPU核心数等等。一个基础示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;</span><br></pre></td></tr></table></figure><br>该命令会启动一个PC系统模拟器，并指定了其并行端口、串行端口、和硬盘镜像。模拟器会模拟一台计算机的启动过程，从硬盘镜像中加载BIOS和bootloader，然后将控制权交给bootloader。</p>
<p>部分命令行参数说明：</p>
<ul>
<li>-no-reboot：退出不重启</li>
<li>-parallel stdio：将模拟器的并行端口重定向为stdio。stdio是unix系统下的标准输入输出，标准输入一般指键盘输入，标准输出和程序执行的进程相关，从shell启动的程序输出到控制台</li>
<li>-hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像。模拟PC启动的时候会从该镜像加载bootloader和操作系统</li>
<li>-serial null：将模拟器的串行端口重新向为null</li>
<li>-monitor stdio：将显示器重定向到stdio</li>
<li>-S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作</li>
<li>-s：-gdb::1234的缩写，等待连接到端口1234。通过-s选项启动远程调试功能，gdb连接到1234端口就可以实现gdb调试qemu中执行的操作系统。</li>
</ul>
<h2 id="gdb基础知识"><a href="#gdb基础知识" class="headerlink" title="gdb基础知识"></a>gdb基础知识</h2><p>gdb是gnu调试器，通过gdb可以调试gcc通过-g选项生成的可执行文件。</p>
<p>gdb的使用很简单，在命令行输入gdb即可进入gdb命令行。-q表示不输出copyright信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bright@localhost ~]$ gdb -q</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><br>在gdb命令行中输入help，可查看可使用的gdb命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type "help" followed by a class name for a list of commands in that class.</span><br><span class="line">Type "help all" for the list of all commands.</span><br><span class="line">Type "help" followed by command name for full documentation.</span><br><span class="line">Type "apropos word" to search for commands related to "word".</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><br>我们看到通过gdb可以设置断点、查看数据、指定文件、查看堆栈、调试源程序等等。当我们要使用某一个功能时，可以通过help来查看，例如我想看调试相关的命令，输入<code>help running</code>，就会有很多调试相关的命令。要锻炼自己看工具说明文档的能力，授人以鱼不如授人以渔。</p>
<p>下面是一些常用命令的总结：</p>
<ul>
<li>run：启动调试程序</li>
<li>break breakpoint：打断点，breakpoint可以是地址或者符号名或者文件名加行号</li>
<li>continue：执行到下一个断点</li>
<li>next：执行下一条语句，调过函数。这个是C代码级的调试，调试汇编的使用需要使用nexti或者stepi。（例如调试bootloader的时候就要用nexti或者stepi）</li>
<li>nexti：执行下一条指令</li>
<li>step：执行下一条语句，进入函数。</li>
<li>stepi</li>
<li>file filename：加载filename文件中的调试信息。这一个指令在执行远程调试的时候必须有，因为远程调试不会加载调试的符号表，需要手动加载。</li>
<li>target remote address：远程调试address，利用这个功能来调试qemu中的操作系统。</li>
</ul>
<h2 id="qemu和gdb实现操作系统源码级调试"><a href="#qemu和gdb实现操作系统源码级调试" class="headerlink" title="qemu和gdb实现操作系统源码级调试"></a>qemu和gdb实现操作系统源码级调试</h2><p>实现源码级调试我们要用到上面提供的两个功能，一个是开启qemu的远程调试端口，另一个是用gdb远程连接qemu的调试端口。</p>
<p>所以我们要做的是，在启动qemu的时候通过-s选项启动:1234端口，通过-S暂停执行（等待gdb连接后在继续执行）:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;</span><br></pre></td></tr></table></figure></p>
<p>然后在gdb中加载符号表、远程连接、设置断点等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file bin&#x2F;kernel</span><br><span class="line">target remote :1234</span><br><span class="line">break *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure></p>
<p>接下来我们在gdb中就可以输入调试命令来调试操作系统内核了。有下面两点要注意：</p>
<ul>
<li>如果是调试bootloader，可以切换到8086调试实模式代码：<code>set arch i8086</code></li>
<li>调试汇编代码要使用stepi或者nexti</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-02T09:27:21.000Z" title="2019-12-02T09:27:21.000Z">2019-12-02</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">8 minutes read (About 1256 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/02/os/ucore_os/ucore-os%E5%AD%A6%E4%B9%A0%E5%89%8D%E8%A8%80/">ucore-os学习前言</a></h1><div class="content"><p>大四了，复习大学四年所学过的专业基础知识。操作系统是复习的第一门课，希望通过操作系统的学习，深入掌握计算机底层的工作原理、串联其他课程（计算机组成原理、计算机接口技术）、学习linux下C/C++的开发，希望能够将整个大学学的大部分知识串联起来。深入了解底层硬件的工作机制以及操作系统的原理和实现。（先不关注IO设备的访问这些，实验代码中都有，等完成所有操作系统实验后有时间再深入这部分细节）</p>
<p>这一系列笔记主要记录了ucore-os操作系统开发和学习的笔记。ucore-os是北大操作系统课程用的实验系统，基于MIT6.828，之前操作系统课程用的就是6.828，这次换成ucore-os，靠自己完整理解并实现操作系统的核心功能。</p>
<p>跟随本笔记的学习的过程是：直接从实验开始，从实验1开始，实验1的笔记中会有该次实验所需要的基础知识链接，先阅读基础知识，然后开始独立完成练<br>习，独立完成后再与笔记中的练习解析对照。基础知识可以先粗略的过一遍，之后遇到的时候不懂再回过来看。<strong>实验最难的部分是实验1和实验2，因为实验1和实验2涉及到大量的硬件知识、编译工具知识，花的时间也最多，但是独立完成实验1实验2并掌握相关的知识后，后面的实验结合操作系统原理知识将一马平川。万事开头难，贵在坚持！</strong></p>
<p>参考资料下载：</p>
<ul>
<li><a href="#">ucore-os-labdoc</a>：ucore-os开发的文档，有练习的要求和一些基础知识，<strong>需要结合该文档才能完成完整的实验</strong></li>
<li><a href="https://css.csail.mit.edu/6.858/2014/readings/i386/toc.htm">80386 refenrence manual</a>：ucore-os基于i386架构开发，所以一定要知道一些cpu硬件相关的知识，如果对于中断、分段、分页、IO、任务切换、保护等硬件机制方面有不理解，<strong>虽然笔记和ucore-os文档中有一些介绍，但是可能有不全或者让你不理解的地方，所以不明白的时候一定要看这个手册！！！贵在坚持！</strong></li>
<li><a href="#">现代操作系统</a>：操作系统原理教材</li>
</ul>
<p>笔记会完整记录：</p>
<ul>
<li>ucore-os开发所需的基础知识，包括基础的硬件知识（段页机制等）</li>
<li>相关开发工具的使用（GCC、make、GDB、qemu、ld等）；</li>
<li>ucore-os的8个实验每一个练习的解析，包括相关原理和代码解析；</li>
<li>ucore-os开发中相关的操作系统原理知识，例如进程调度算法的实现等；</li>
<li>elf文件格式、链接原理等相关知识；</li>
</ul>
<p>这系列笔记的最终目标是帮助能够希望学习和实现操作系统的同学无障碍的完成完整操作系统功能的开发。所以这一系列笔记会有大量的相关前置知识的学习，例如相关硬件知识（段页相关的硬件原理、IO设备访问等等）、软件知识（make工具、elf文件格式、链接器），希望能够解决没有基础的同学开发中的大量疑问。当然这些都是我自己的看的一些书和资料的总结，完全没基础也不行，只是希望能够尽量帮助自己了解相关知识。</p>
<p>我觉得在进行操作系统开发之前需要掌握的基础知识：</p>
<ul>
<li>C语言：C语言语法，尤其是对各种指针（数组指针、指针数组、函数指针）了解。还有结构体的内存分配、字节对齐等。可以参考我的<a href="#">C语言学习笔记</a></li>
<li>汇编语言：32位x86汇编，AT&amp;T语法</li>
<li>英语能力：intel 80386、gcc、make等的文档都是英文的，能够较为流畅的看这些文档。一些博客上有中文的使用教程，但是没有源文档那么详细，建议直接看源文档。</li>
</ul>
<p>其他的相关知识我的笔记里都有。在每一个实验的开头都会给出参考学习资料，里面有前置知识和相关的os原理。</p>
<p>希望通过这一系列的学习，将大学所学的知识融会贯通。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-02T09:24:08.000Z" title="2019-12-02T09:24:08.000Z">2019-12-02</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">7 minutes read (About 1114 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/02/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B05%EF%BC%9A%E5%AE%9E%E6%A8%A1%E5%BC%8F%E4%B8%8E%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F/">ucore-os笔记5：实模式与保护模式</a></h1><div class="content"><p>这一次笔记学习X86的实模式和保护模式，主要内容是实模式和保护模式的介绍，相关硬件机制的介绍（GDTR寄存器，GDT等），保护模式在内核中的作用，以及如何从实模式切换到保护模式。</p>
<h2 id="实模式与保护模式"><a href="#实模式与保护模式" class="headerlink" title="实模式与保护模式"></a>实模式与保护模式</h2><p>接下来开始实模式与保护模式的学习。在intel 80386以前的CPU，例如8086，使用的都是实模式。实模式下，CPU没有提供保护机制，可以寻址到任意的内存空间，通过segment:offset的形式可以访问任意的物理空间（segment*16+offset=物理空间地址）。而保护模式在CPU层面提供了对内存空间的保护。保护模式通过分段机制来实现对内存的保护，这个分段机制和8086等实模式CPU下的segment不同，实模式下的segment仅仅只是将内存分片，而保护模式下的分段机制，不仅仅将内存分段，并且CPU对各段内存的访问进行权限的检查，实现内存访问的保护。</p>
<p>保护模式为地址空间提供了抽象，实模式直接访问物理空间，那意味者所有的程序都可以访问所有的物理空间，一个程序可以篡改其他程序的数据，这就存在巨大的安全问题；而且直接访问物理内存，程序的并发运行也存在困难，如何确定多个程序的运行地址？如何进行内存的分配和回收？</p>
<p>所以CPU对物理内存空间进行了抽象：所有的进程拥有独立的内存空间，并且对进程的内存空间提供保护。CPU通过<code>重定向</code>来实现分离不同的内存空间，对于应用程序而言，其使用的地址会进行CPU的<code>重定向</code>来映射到真实的物理地址。CPU利用段寄存器GDTR和GDT来实现<code>重定向</code>的功能，程序员看到的地址到达CPU后，会经过GDTR和GDT的重定向，生成另一个地址；同时CPU也会检查GDT中描述符的保护位和当前保护位，来确定当前程序是否有权限访问指定的内存，而且会判断段基地址和段界限，确定访问的内存是否在该段内。由此实现了不同进程的内存之间的隔离、内存权限访问的分级。</p>
<p>CPU中进行内存管理的硬件称为MMU（Memory Management Unit），程序员设置的地址会经过MMU的转化后才会变成真实的物理地址送达地址总线。MMU提供了分段和分页机制来实现内存隔离、内存保护、虚拟内存等等功能。详情请看<a href="#">内存管理基础：分段和分页机制</a></p>
<h3 id="实模式"><a href="#实模式" class="headerlink" title="实模式"></a>实模式</h3><p>BIOS将bootloader加载进内存以后，在实模式下执行，实模式下CPU运行在16位模式，最大访问1MB的内存。内存地址访问地址真实物理地址，不提供任何抽象和保护机制。通过开启A20，设置CRO寄存器中的使能位，可以切换到保护模式，请看<a href="#">bios和bootloader的加载过程</a>。</p>
<h3 id="保护模式"><a href="#保护模式" class="headerlink" title="保护模式"></a>保护模式</h3><p>保护模式下能够访问所有的物理内存，同时对物理内存进行隔离和保护。通过CPU硬件检查特权位来实现保护，通过分段来进行地址空间的抽象和进程隔离。通过分页可以实现虚拟内存，允许地址空间比实际的物理空间大，通过在内存和磁盘之间进行交换实现。</p>
<p>保护模式下涉及到分段和分页两种机制，这两种机制对应的原理和相关的硬件介绍在<a href="#">内存管理基础：分段和分页机制</a>中学习。</p>
<p>在保护模式下，地址经历的转化过程是：逻辑地址-&gt;分段机制-&gt;线形地址-&gt;分页机制-&gt;物理地址。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-01T01:38:36.000Z" title="2019-12-01T01:38:36.000Z">2019-12-01</time><span class="level-item"><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/">编程语言</a><span> / </span><a class="link-muted" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/">C语言</a></span><span class="level-item">10 minutes read (About 1492 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/01/c-c++/GCC%E5%86%85%E8%81%94%E6%B1%87%E7%BC%96/">GCC内联汇编</a></h1><div class="content"><p>GCC提供了在C语言中嵌入汇编语言的能力。在C语言中嵌入汇编，在操作系统和嵌入式软件中开发很有用，编写底层软件时能够直接访问硬件。但是编写客户端软件时有些汇编指令是不可用的，所以编写windows或者linux下的客户端软件时，使用某些指令可能会出错。因为计算机系统的保护模式会提供对特定指令的保护，这些指令只能在内核态中运行；而一般的应用运行于应用层，特权级最低，仅能通过系统调用来获取访问系统资源。</p>
<h2 id="两种内联汇编语法"><a href="#两种内联汇编语法" class="headerlink" title="两种内联汇编语法"></a>两种内联汇编语法</h2><p>GCC有两种内联汇编语法，一种是简单内联汇编，另一种是扩展内联汇编。简单内联语法如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">asm [volatile] (asm instructions);</span><br></pre></td></tr></table></figure><br>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span> (<span class="string">"pushl %eax;movl $0,%eax;popl %eax;"</span>);</span><br></pre></td></tr></table></figure><br>这种情况下C语言不能和汇编进行交互，而且如果使用的寄存器恰被C编译器分配给其他变量，那么这里对寄存器重新赋值就会出现问题。扩展内联汇编语法</p>
<p>不同的汇编指令之间要用<code>\t\n</code>或者<code>;</code>隔开，表示不同的指令。</p>
<blockquote>
<p>asm、volatile和<code>__asm__和__volatile__</code>是完全相同的，两者均可。</p>
</blockquote>
<h2 id="扩展内联语法"><a href="#扩展内联语法" class="headerlink" title="扩展内联语法"></a>扩展内联语法</h2><p>GCC下通过asm可以在C语言中嵌入汇编指令，如下例：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">int</span> a = <span class="number">40</span>;</span><br><span class="line">  <span class="keyword">int</span> b;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">asm</span>(</span><br><span class="line">    <span class="string">"movl %1,%%eax;"</span></span><br><span class="line">    <span class="string">"shr %%eax;"</span></span><br><span class="line">    <span class="string">"movl %%eax,%0;"</span></span><br><span class="line">    : <span class="string">"=r"</span>(b)</span><br><span class="line">    : <span class="string">"r"</span>(a)</span><br><span class="line">    : <span class="string">"%eax"</span></span><br><span class="line">    );</span><br><span class="line">  </span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"a = %d, b = %d\n"</span>, a, b);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>上面的代码通过asm嵌入了一系列汇编指令。通过asm扩展语法，这些汇编指令能够和C语言中的变量进行交互，能够将C语言中变量的值传到汇编中，也能够将汇编中计算的值赋值给C语言中的变量。上面的示例就是将变量a赋值给eax寄存器，然后将eax寄存器右移一位（相当于除2），然后将结果输出给变量b。</p>
<p>asm的语法如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(汇编语言模板</span></span></span><br><span class="line"><span class="function"><span class="params">  : 输出操作数</span></span></span><br><span class="line"><span class="function"><span class="params">  : 输入操作数</span></span></span><br><span class="line"><span class="function"><span class="params">  : 使用的寄存器</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br></pre></td></tr></table></figure><br>volatile暗示编译器不需要对这部分代码进行优化。编译器优化时可能会调整指令的位置，如果我们不希望编译器这么做，可以加上volatile让编译器不优化。</p>
<h3 id="汇编语言模板"><a href="#汇编语言模板" class="headerlink" title="汇编语言模板"></a>汇编语言模板</h3><p>这个汇编语言模板起始就是汇编语言，只是指令的操作数用占位符代替。例如：<code>movl %eax, %0</code>。这里的<code>%0</code>就是一个占位符，通过占位符和C语言变量交互。</p>
<p>注意如下要点：</p>
<ul>
<li>模板中的寄存器有两个百分号<code>%%eax</code></li>
<li>使用%0，%1作为占位符和C语言变量交互。先输出后输入，意思就是，如果有2个输出，那么%0、%1就是输出，后面才是输入；如果有三个输出，那么%0、%1、%2是输出、后面是输出，依次类推。</li>
<li>可以通过寄存器寻址：<code>movb (%%eax),%al</code></li>
<li>数字以<code>$</code>开头：<code>$3</code></li>
<li>多个指令之间使用<code>\t\n</code>或者<code>;</code>隔开</li>
</ul>
<h3 id="输入输出参数"><a href="#输入输出参数" class="headerlink" title="输入输出参数"></a>输入输出参数</h3><p>通过输入输出参数可以将C语言变量匹配到内联汇编中。例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> <span class="built_in">array</span>[<span class="number">2</span>], i = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">array</span>[<span class="number">0</span>] = <span class="number">150</span>;</span><br><span class="line">  <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl %1,%%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"shl  %%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    <span class="string">"movl %%eax,%0;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">"=r"</span>(<span class="built_in">array</span>[i+<span class="number">1</span>])</span></span></span><br><span class="line"><span class="function"><span class="params">    : <span class="string">"r"</span>(<span class="built_in">array</span>[i])</span></span></span><br><span class="line"><span class="function"><span class="params">  )</span></span>;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">"array[0] = %d, array[1] = %d\n"</span>, <span class="built_in">array</span>[<span class="number">0</span>], <span class="built_in">array</span>[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure><br><code>&quot;=r&quot;(array[i+1])</code>中，<code>=</code>表示输出操作符，<code>r</code>表示值必须放在任意一个寄存器中，输入时会将变量加载到这个寄存器中，输出时会从这个寄存器输出到变量所在的内存中。除了r之外，常用的约束字母如下：</p>
<ul>
<li>m、v、o：内存单元</li>
<li>r：任何通用寄存器</li>
<li>q：abcd四个寄存器之一</li>
<li>l、h：直接操作数</li>
<li>E、F：浮点数</li>
<li>G：任意</li>
<li>a、b、c、d：eax/ax/al、ebx…</li>
<li>S、D：esi或者edi</li>
<li>I：常数（0-31）</li>
</ul>
<p>如果输入和输出时一个操作数，那么可以用下面的方式：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">asm</span>(<span class="string">"incw %0;"</span></span><br><span class="line">: <span class="string">"=a"</span>(counter)</span><br><span class="line">: <span class="string">"0"</span>(counter));</span><br></pre></td></tr></table></figure><br><code>&quot;0&quot;</code>表示引用<code>%0</code>表示的寄存器，所以输入和输出使用的是同一个寄存器。</p>
<h3 id="使用的寄存器"><a href="#使用的寄存器" class="headerlink" title="使用的寄存器"></a>使用的寄存器</h3><p>最后一个冒号接的是使用的寄存器，告诉编译器我需要这些寄存器或者这些寄存器的值已经改变；编译器在分配寄存器的时候就会考虑这些因素。</p>
<p>如果使用<code>memory</code>，表示某些内存中的值已经改变。如果之前编译器已经将该内存的值放在了寄存器中，那么会导致数据不一致。使用memory告诉编译器这个信息，编译器会处理这些情况。</p>
<h2 id="attribute"><a href="#attribute" class="headerlink" title="__attribute__"></a><code>__attribute__</code></h2><p><code>__attribute__</code>用于在函数和变量声明的时候，给编译器设置一些属性，从而实现对函数的优化和对变量声明的控制。</p>
<p>例如：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fatal_error</span><span class="params">()</span> __<span class="title">attribute__</span><span class="params">((noreturn))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mong</span> &#123;</span></span><br><span class="line">  <span class="keyword">char</span> id;</span><br><span class="line">  <span class="keyword">int</span> code __attribute__((align(<span class="number">4</span>)));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>告诉编译器这个函数没有返回值，所以编译器编译时会进行优化，不产生函数返回相关的代码；结构体中的成员按照4字节对齐。</p>
<p>常用的属性值如下：</p>
<ul>
<li>always-inline：将函数作为inline函数，尽可能优化并放在CPU能够尽快取到的位置</li>
<li>packed：用于结构体成员，表示拥有尽可能小的对齐属性；用于结构体，表示结构体的总大小尽可能小。</li>
</ul>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-11-30T02:10:02.000Z" title="2019-11-30T02:10:02.000Z">2019-11-30</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">13 minutes read (About 1952 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/11/30/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A02/">ucore-os实验1：lab1练习2</a></h1><div class="content"><p>练习1我们已经学习了make的基本语法，ucore-os是如何编译生成的。这个练习我们我们来学习ucore-os是如何启动的。包括内核如何被加载到内存中，内核加载后执行了哪些操作。重点详细学习启动过程中涉及到的硬件知识。部分汇编语言细节不深究，只了解操作系统宏观一些的概念和过程，以及各部分所起到的作用。汇编细节后续有时间再深入学习。</p>
<h2 id="练习2：使用qemu执行并调试lab1中的软件"><a href="#练习2：使用qemu执行并调试lab1中的软件" class="headerlink" title="练习2：使用qemu执行并调试lab1中的软件"></a>练习2：使用qemu执行并调试lab1中的软件</h2><p>重点是熟悉qemu和gdb的调试，进行如下练习：</p>
<ol>
<li>从CPU加电后执行的第一条指令开始，单步跟踪BIOS的执行</li>
<li>在初始化位置0x7c00设置实地址断点，测试断点正常</li>
<li>从0x7c00开始跟踪代码运行，将单步跟踪反汇编得到的代码于bootasm.S和bootblock.asm进行比较</li>
<li>自己找一个bootloader或内核中的代码位置，设置断点并进行测试</li>
</ol>
<h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><p>答：先对实验过程进行分析和记录，最后给出练习体的到答案</p>
<h3 id="启动qemu并于gdb联调"><a href="#启动qemu并于gdb联调" class="headerlink" title="启动qemu并于gdb联调"></a>启动qemu并于gdb联调</h3><p>首先我们学习硬件模拟器的一些命令和调试方法。通过qemu的命令行参数，可以指定模拟硬件的参数，例如硬盘、显示器等等属性信息。下面首先分析一些命令行参数信息。</p>
<p>Makefile中有：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">qemu-mon: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU)  -no-reboot -monitor stdio -hda $&lt; -serial null</span></span><br><span class="line">qemu: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU) -no-reboot -parallel stdio -hda $&lt; -serial null</span></span><br><span class="line">qemu-nox: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU)   -no-reboot -serial mon:stdio -hda $&lt; -nographic</span></span><br><span class="line">TERMINAL        :=gnome-terminal</span><br><span class="line">debug: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU) -S -s -parallel stdio -hda $&lt; -serial null &amp;</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)sleep 2</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(TERMINAL) -e <span class="string">"gdb -q -tui -x tools/gdbinit"</span></span></span><br><span class="line">debug-nox: $(UCOREIMG)</span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(QEMU) -S -s -serial mon:stdio -hda $&lt; -nographic &amp;</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)sleep 2</span></span><br><span class="line"><span class="meta">	$</span><span class="bash">(V)$(TERMINAL) -e <span class="string">"gdb -q -x tools/gdbinit"</span></span></span><br></pre></td></tr></table></figure><br>选项分析如下：</p>
<ul>
<li>-no-reboot：退出不重启</li>
<li>-parallel stdio：将模拟器的并行端口重定向为stdio</li>
<li>-hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像</li>
<li>-serial null：将模拟器的串行端口重新向为null</li>
<li>-monitor stdio：将显示器重定向到stdio</li>
<li>-S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作</li>
<li>-s：-gdb::1234的缩写，等待连接到端口1234</li>
</ul>
<p>相关命令分析如下：</p>
<ul>
<li>gnome-terminal -e command：启动一个新的gnome-terminal终端，-e command表示在该终端中将command字符串作为命令执行</li>
<li>gdb：运行gnu调试器，可以调试C程序<ul>
<li>-q：不打印copyright信息</li>
<li>-x file：从文件中执行gdb命令</li>
</ul>
</li>
<li>sleep 2：延迟两秒</li>
</ul>
<p>gdbinit中的内容如下（通过命令行输入gdb进行gdb命令模式，然后输入help file等查看命令详情）：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file bin/kernel # 表示调试bin/kernel文件，会读取文件中的符号表。该文件要使用-g选项生成才包含调试使用的信息。</span><br><span class="line">target remote :1234 # 连接到目标机器或者进程</span><br><span class="line">break kern_init # 在函数或者行数打断点</span><br><span class="line">continue # 继续执行</span><br></pre></td></tr></table></figure></p>
<p>学习上面的命令行参数，我们得到两个问题的答案：</p>
<ul>
<li>如何在qemu中启动我们生成的ucore.img镜像？使用-hda命令行参数，将ucore.img作为qemu的启动硬盘。启动后qemu模拟硬件会直接开始执行，通过-S参数可以暂停执行。</li>
<li>如何实现源码级调试？通过-s参数，开放qemu的1234端口，让gdb通过target remote命令来连接qemu开发的1234端口。连接以后就可以在gdb窗口中源码级远程调试qemu。</li>
</ul>
<blockquote>
<p>注意：远程调试必须在gdb中手动加载可执行文件，例如<code>file bin/kernel</code>。生成可执行文件的时候必须使用-g参数添加调试信息。调试bootloader时，只能使用逐指令调试（nexti）。调试内核时才能使用逐语句调试（next），推测可能bootloader是用汇编写的。</p>
</blockquote>
<h3 id="实验的预备知识"><a href="#实验的预备知识" class="headerlink" title="实验的预备知识"></a>实验的预备知识</h3><p>这里学习一下计算机开机以后经历的过程。包括BIOS启动、BOOTLOADER执行、操作系统启动等过程。</p>
<h4 id="保护模式和分段机制"><a href="#保护模式和分段机制" class="headerlink" title="保护模式和分段机制"></a>保护模式和分段机制</h4><p>bootloader执行的时候，还处于实模式运行状态，此时是16位的运行状态，只能访问1MB的内存（这些都是由硬件控制的，在硬件层面提供保护）。</p>
<p>实模式将内存分段，代码和数据位于不同的区域（和保护模式的分段不同）。每段最大$2^{16}$字节。通过段地址*16+偏移直接访问物理地址。且不区分操作系统内存和用户程序内存。程序指针能任意改变内存中的任意地址中的内容。</p>
<p>保护模式启用32位运行状态，能够访问4G的线性地址空间和物理地址空间。通过分段存储机制和分页管理机制提供保护。不同的段有不同的特权优先级（硬件层面进行），访问没有优先级的内存CPU将会触发异常。</p>
<blockquote>
<p>保护模式下有两个段表，GDT和LDT。ucore中只用了GDT。GDTR和LDTR两个48位寄存器分别存储了GDT和LDT的起始地址。</p>
</blockquote>
<p>GDTR，GDTR图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">47              16        0</span><br><span class="line">|-----基址-------|-段表长度-|</span><br></pre></td></tr></table></figure><br>LDT是GDT的下一级，如果段寄存器（cs、ds、ss、es、gs、fs等）中的GDT描述符的TL位是1，则说明存在LDT中，此时会先找GDT，GDT对应项的内容时LDT的索引，然后找LDT中的对应项。LDT中的段地址+偏移地址=线性地址。</p>
<p>如果TI=0，则直接从GDT中找。（硬件进行的）</p>
<blockquote>
<p>逻辑地址、线性地址、物理地址：</p>
<p>逻辑地址由段地址和偏移地址组成，段地址存在段寄存器中，偏移地址存在EIP中。逻辑地址也叫虚拟地址，程序中使用的是虚拟地址（指针中的只是逻辑地址中的偏移，还要加上段地址才能得到线性地址。不同程序的段地址不同，这就是硬件提供的保护机制）；段地址和偏移地址的地址表示形式就是逻辑地址。段地址+偏移地址=线性地址。线性地址在页处理机制处理后，就得到了物理地址。如果不启动分页机制，线性地址就是物理地址。</p>
</blockquote>
<p>GDTR存的是GDT的起始地址和长度。GDT表的表项是64位，其中包括段基地址32位，段界限20位，各种段属性。段寄存器中存的是选择子：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">段选择子</span><br><span class="line">15          3  2   0</span><br><span class="line">|----索引---|TI|RPL|</span><br></pre></td></tr></table></figure></p>
<ul>
<li>索引：表示第几个描述符（0开始），在转成地址的时候要*8（因为一个描述符8个字节）</li>
<li>TI：1则表示在LDT中，0表示在GDT中</li>
<li>RPL：请求优先级，0最高3最低。ucore是使用了0和3。在段选择符被加载进寄存器时就会触发特权检查，只有当前代码段以及段选择符特权均小于等于GDT中描述符中的特权位时，才允许访问，否则CPU会出现保护异常。（硬件判断）</li>
</ul>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous"><a href="/page/5/">Previous</a></div><div class="pagination-next"><a href="/page/7/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link" href="/">1</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/5/">5</a></li><li><a class="pagination-link is-current" href="/page/6/">6</a></li><li><a class="pagination-link" href="/page/7/">7</a></li><li><span class="pagination-ellipsis">&hellip;</span></li><li><a class="pagination-link" href="/page/16/">16</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Bright Wu"></figure><p class="title is-size-4 is-block line-height-inherit">Bright Wu</p><p class="is-size-6 is-block">working harder to be better</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing Chaoyang</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">154</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">84</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">115</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wre232114" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wre232114"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://brightblog.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">brightblog.cn</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/spring%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">spring实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/"><span class="level-start"><span class="level-item">Open Source</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/Huaxu/"><span class="level-start"><span class="level-item">Huaxu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/"><span class="level-start"><span class="level-item">Webpack</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Webpack基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">Webpack实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">css基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">css工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/less/"><span class="level-start"><span class="level-item">less</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/sass/"><span class="level-start"><span class="level-item">sass</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/docker/docker-swarm/"><span class="level-start"><span class="level-item">docker swarm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/docker/docker%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">docker基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/"><span class="level-start"><span class="level-item">html5</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/html5/dom/"><span class="level-start"><span class="level-item">dom</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5-API/"><span class="level-start"><span class="level-item">html5 API</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="level-start"><span class="level-item">html5标签和属性</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/svg/"><span class="level-start"><span class="level-item">svg</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/js/js%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">js基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="level-start"><span class="level-item">正则表达式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/linux/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/"><span class="level-start"><span class="level-item">node.js</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/node-js/npm/"><span class="level-start"><span class="level-item">npm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">命令行工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/php/"><span class="level-start"><span class="level-item">php</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/"><span class="level-start"><span class="level-item">spring-boot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/typescript/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">踩坑指南</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vue/cli/"><span class="level-start"><span class="level-item">cli</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue-router/"><span class="level-start"><span class="level-item">vue-router</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">vue实战</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">vue组件开发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/xml/"><span class="level-start"><span class="level-item">xml</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/xml/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/"><span class="level-start"><span class="level-item">学习打卡</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">密码技术</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/"><span class="level-start"><span class="level-item">shell</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/"><span class="level-start"><span class="level-item">ucore</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">操作系统原理</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%AF%AD%E5%8F%A5/"><span class="level-start"><span class="level-item">sql语句</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AF%BC%E8%AE%BA/"><span class="level-start"><span class="level-item">导论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">数据库编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">数据库设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"><span class="level-start"><span class="level-item">图</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="level-start"><span class="level-item">树莓派</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%AF%95%E8%AE%BE/"><span class="level-start"><span class="level-item">毕设</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="level-start"><span class="level-item">模式匹配</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="level-start"><span class="level-item">深度优先搜索</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C语言</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/%E7%94%9F%E8%AF%8D/"><span class="level-start"><span class="level-item">生词</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wireshark/"><span class="level-start"><span class="level-item">wireshark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">问题记录</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="level-start"><span class="level-item">交给子类</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="level-start"><span class="level-item">生成实例</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">适应设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-27T13:07:22.000Z">2020-06-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE3-5%E5%AF%B8%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A5%97%E8%A3%85%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">树莓派3.5寸显示器套装安装操作系统</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:21:47.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/opensource/%E8%B7%A8%E6%A1%86%E6%9E%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%8E%9F%E5%9E%8B%E6%A6%82%E8%A7%88/">跨框架、自定义主题的静态博客系统原型概览</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Open-Source/">Open Source</a> / <a class="link-muted" href="/categories/Open-Source/Huaxu/">Huaxu</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:18:37.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/webpack/webpack%E5%AE%9E%E6%88%98%EF%BC%9A%E6%89%93%E9%80%A0%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%91react%E5%92%8Cvue%E7%9A%84%E6%9E%84%E5%BB%BA%E5%BC%95%E6%93%8E/">webpack实战：打造同时编译react和vue的构建引擎</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Webpack/">Webpack</a> / <a class="link-muted" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/">Webpack实战</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.142Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/php/Smarty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Smarty块度入门</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/php/">php</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.122Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/git/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93/">在centos上搭建git服务器仓库</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/git/">git</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Adapter%E6%A8%A1%E5%BC%8F/"><span class="tag">Adapter模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC/"><span class="tag">GCC</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Huaxu/"><span class="tag">Huaxu</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iterator%E6%A8%A1%E5%BC%8F/"><span class="tag">Iterator模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"><span class="tag">Linux命令行与shell脚本编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Maven/"><span class="tag">Maven</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Open-Source/"><span class="tag">Open Source</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Template-Method%E6%A8%A1%E5%BC%8F/"><span class="tag">Template Method模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%9F%BA%E7%A1%80/"><span class="tag">Webpack基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%AE%9E%E6%88%98/"><span class="tag">Webpack实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/autoprefixer/"><span class="tag">autoprefixer</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/browserslist/"><span class="tag">browserslist</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos7%E5%B7%A5%E5%85%B7/"><span class="tag">centos7工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%8D%95%E4%BD%8D/"><span class="tag">css单位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%9F%BA%E7%A1%80/"><span class="tag">css基础</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B7%A5%E5%85%B7/"><span class="tag">css工具</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B8%83%E5%B1%80/"><span class="tag">css布局</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker-swarm/"><span class="tag">docker swarm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker%E5%9F%BA%E7%A1%80/"><span class="tag">docker基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom/"><span class="tag">dom</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom%E5%9F%BA%E7%A1%80/"><span class="tag">dom基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html-Permission-API/"><span class="tag">html Permission API</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5/"><span class="tag">html5</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5-API/"><span class="tag">html5 API</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="tag">html5标签和属性</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%9F%BA%E7%A1%80/"><span class="tag">js基础</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1/"><span class="tag">js对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"><span class="tag">js对象类型判断</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E6%95%B0%E7%BB%84/"><span class="tag">js数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less/"><span class="tag">less</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E5%91%BD%E4%BB%A4/"><span class="tag">linux命令</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"><span class="tag">linux远程连接</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node-js/"><span class="tag">node.js</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npm/"><span class="tag">npm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postcss/"><span class="tag">postcss</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-boot/"><span class="tag">spring-boot</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring%E5%AE%9E%E6%88%98/"><span class="tag">spring实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E8%AF%AD%E5%8F%A5/"><span class="tag">sql语句</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg/"><span class="tag">svg</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%9F%BA%E7%A1%80/"><span class="tag">svg基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%AE%9A%E4%BD%8D/"><span class="tag">svg定位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tips/"><span class="tag">tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tslint%E5%9F%BA%E7%A1%80/"><span class="tag">tslint基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typescript/"><span class="tag">typescript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore/"><span class="tag">ucore</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore-os/"><span class="tag">ucore-os</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-cli/"><span class="tag">vue-cli</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-router/"><span class="tag">vue-router</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-tips/"><span class="tag">vue-tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"><span class="tag">vue博客后台开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%9F%BA%E7%A1%80/"><span class="tag">vue基础</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%AE%9E%E6%88%98/"><span class="tag">vue实战</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="tag">vue组件开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E8%BF%9B%E9%98%B6/"><span class="tag">vue进阶</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wireshark/"><span class="tag">wireshark</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xml/"><span class="tag">xml</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC-Primer%E3%80%8B/"><span class="tag">《C Primer》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E3%80%8B/"><span class="tag">《C语言编程魔法书》</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8CShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E3%80%8B/"><span class="tag">《Linux命令行和Shell脚本编程》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B/"><span class="tag">《图解密码技术》</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"><span class="tag">二叉树</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="tag">交给子类</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E6%B2%BB/"><span class="tag">分治</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%AF%8D/"><span class="tag">单词</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="tag">命令行工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE/"><span class="tag">图</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%88%98/"><span class="tag">实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="tag">密码技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%BC%E8%AE%BA/"><span class="tag">导论</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><span class="tag">异步编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="tag">操作系统原理</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="tag">数据库编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="tag">数据库设计</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%83%E9%99%90/"><span class="tag">权限</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="tag">模式匹配</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="tag">正则表达式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%95%E8%AE%BE/"><span class="tag">毕设</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="tag">深度优先搜索</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="tag">生成实例</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="tag">踩坑指南</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">适应设计模式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="tag">问题记录</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%95%B01/"><span class="tag">高数1</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 Bright</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("default");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.brightblog.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>