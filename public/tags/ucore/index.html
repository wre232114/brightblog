<!doctype html>
<html lang="de"><head><meta charset="utf-8"><meta name="generator" content="Hexo 4.2.1"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><meta><title>Tag: ucore - Bright的个人博客</title><meta description="前端开发的技术分享和个人笔记总结"><meta property="og:type" content="blog"><meta property="og:title" content="Bright的个人博客"><meta property="og:url" content="https://www.brightblog.cn/"><meta property="og:site_name" content="Bright的个人博客"><meta property="og:description" content="前端开发的技术分享和个人笔记总结"><meta property="og:image" content="https://www.brightblog.cn/img/og_image.png"><meta property="article:author" content="Bright"><meta property="article:tag" content="前端开发 个人博客"><meta property="twitter:card" content="summary"><meta property="twitter:image" content="/img/og_image.png"><script type="application/ld+json">{"@context":"https://schema.org","@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"https://www.brightblog.cn"},"headline":"Bright的个人博客","image":["https://www.brightblog.cn/img/og_image.png"],"author":{"@type":"Person","name":"Bright"},"description":"前端开发的技术分享和个人笔记总结"}</script><link rel="icon" href="/img/favicon.svg"><link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.12.0/css/all.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/highlight.js@9.12.0/styles/atom-one-light.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Ubuntu:wght@400;600&amp;family=Source+Code+Pro"><link rel="stylesheet" href="/css/default.css"><style>body>.footer,body>.navbar,body>.section{opacity:0}</style><!--!--><!--!--><!--!--><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/css/lightgallery.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/css/justifiedGallery.min.css"><!--!--><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/pace-js@1.0.2/pace.min.js"></script></head><body class="is-3-column"><nav class="navbar navbar-main"><div class="container"><div class="navbar-brand justify-content-center"><a class="navbar-item navbar-logo" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a></div><div class="navbar-menu"><div class="navbar-start"><a class="navbar-item" href="/">Home</a><a class="navbar-item" href="/archives">Archives</a><a class="navbar-item" href="/categories">Categories</a><a class="navbar-item" href="/tags">Tags</a><a class="navbar-item" href="/about">About</a></div><div class="navbar-end"><a class="navbar-item" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a><a class="navbar-item search" title="Search" href="javascript:;"><i class="fas fa-search"></i></a></div></div></div></nav><section class="section"><div class="container"><div class="columns"><div class="column order-2 column-main is-8-tablet is-8-desktop is-6-widescreen"><div class="card"><div class="card-content"><nav class="breadcrumb" aria-label="breadcrumbs"><ul><li><a href="/tags">Tags</a></li><li class="is-active"><a href="#" aria-current="page">ucore</a></li></ul></nav></div></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-23T05:03:32.000Z" title="2020-01-23T05:03:32.000Z">2020-01-23</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">a few seconds read (About 0 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/23/os/ucore_os/ucore-os-lab8%EF%BC%9ASFS%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E8%AE%BE%E8%AE%A1%E5%92%8C%E5%AE%9E%E7%8E%B0/">ucore-os-lab8：SFS文件系统设计和实现</a></h1><div class="content"></div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2020-01-05T12:13:08.000Z" title="2020-01-05T12:13:08.000Z">2020-01-05</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">11 minutes read (About 1654 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2020/01/05/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B09%EF%BC%9ATSS%E5%92%8C%E8%BF%9B%E7%A8%8B%E6%8A%BD%E8%B1%A1%E8%AE%BE%E8%AE%A1/">ucore-os笔记9：TSS以及机制和策略的关系</a></h1><div class="content"><p>这篇文章主要介绍硬件提供的机制与操作系统设计的策略的联系，解决类似80386提供了LDT，ucore-os为什么没有使用呢？为什么不用TSS实现多进程呢？这类问题。同时也简要介绍的TSS相关的cpu硬件知识，因为ucore-os中使用了一小部分TSS的能力。</p>
<p>第一部分是个人的一些思考，关于机制和策略的思考，如果只想看TSS相关的知识，直接跳到第二部分。下面进入正体：</p>
<h2 id="机制和策略的关系"><a href="#机制和策略的关系" class="headerlink" title="机制和策略的关系"></a>机制和策略的关系</h2><p>为了对CPU的使用进行抽象，操作系统进行了进程的设计，intel 80386其实在硬件层面提供了进程抽象的支持，但是ucore-os并没有使用80386处理器提供的任务切换机制进行进程的设计。TSS机制是硬件多任务机制，ucore使用的软件多任务机制。原因可能如下：</p>
<ul>
<li>与硬件强相关，假如换成其他CPU架构，那进程模块的绝大部分功能都需要重写</li>
<li>有较大的限制，只能使用CPU指定的方式进行进程切换，切换使用指定的格式，不够灵活</li>
</ul>
<p>除了多进程设计之外，还有内存管理抽象机制。我们知道每一个进程都有独立的地址空间，80386也提供了LDT来进行进程地址空间的抽象，为每一个进程分配一个LDT即可实现线性地址的抽象。但是ucore-os没有使用LDT，使用的是页表来实现进程地址的抽象。</p>
<p>原因其实很简单，CPU只是提供了一种机制，我们只是在CPU的机制上进行操作系统的设计，用不用CPU的功能我们说了算，只要能够利用硬件能力满足我们系统设计的需求，就没有问题。所以我们看到80386的很多机制在ucore-os中都没有使用，随着系统的扩大需求增多，我们可能需要更多的CPU能力来满足系统设计的需要。</p>
<p>机制和策略是操作系统原理中常常强调的东西，机制是已有的能力或者框架，策略是在一定机制下进行的设计。可以参考分页机制，提供了一种分页的能力，怎么利用分页的能力来进行地址抽象的设计就是策略。</p>
<h2 id="TSS及相关的多任务硬件机制"><a href="#TSS及相关的多任务硬件机制" class="headerlink" title="TSS及相关的多任务硬件机制"></a>TSS及相关的多任务硬件机制</h2><p>intel 80386在硬件层面提供了多任务的支持，与下列硬件相关：</p>
<ul>
<li>Task state segment（TSS）：内存中的一段区域，用于描述一个task相关的</li>
<li>Task state segment descriptor：TSS描述符，放在GDT中，其中存了TSS的线性基址和DPL等信息</li>
<li>Task register（TR）：TSS描述符寄存器，存放当前运行的程序的TSS的选择符</li>
<li>Task gate descriptor：</li>
</ul>
<h3 id="TSS"><a href="#TSS" class="headerlink" title="TSS"></a>TSS</h3><blockquote>
<p>参考资料：<a href="https://css.csail.mit.edu/6.858/2014/readings/i386/c07.htm">80386 MultiTask</a></p>
</blockquote>
<p>CPU管理一个task的信息存在一个TSS中，TSS可以被放在内存的任意区域中，通过TR找到TSS描述符，通过TSS描述符找到TSS。</p>
<p>TSS的内容是大部分的寄存器（通用寄存器、段寄存器、EFLAGS、EIP）、上一个任务的TSS选择符、LDT、cr3、指向0-2优先级的esp（esp0、esp1、esp2）和IO map基址。</p>
<p>TSS图：<br><img src="/img/TSS.gif" alt="tss"></p>
<h3 id="TSS-descriptot"><a href="#TSS-descriptot" class="headerlink" title="TSS descriptot"></a>TSS descriptot</h3><p>TSS描述符只能放在GDT中，描述一个TSS的起始地址、大小、权限等信息，通过TR能从GDT中找到tss描述符、通过tss描述符可以找到TSS。</p>
<p>一个tss就对应着一个task（操作系统中称为进程），能访问TSS的程序就能导致任务切换。TSS不能读取和修改，要修改TSS只能通过TSS所在内存在进程的数据段的进程中修改。将TSS描述符加载到段寄存器中会导致一个错误。</p>
<p><img src="/img/tssdescriptor.gif" alt="tssd"></p>
<h3 id="TR和Task-Gate-descriptor"><a href="#TR和Task-Gate-descriptor" class="headerlink" title="TR和Task Gate descriptor"></a>TR和Task Gate descriptor</h3><p>task register是cpu的一个16位寄存器，和其他段寄存器类似，表示权限以及tss descriptor在GDT中的偏移。</p>
<p>通过ltr和str指令可以修改和存储tr的值。ltr是一条受限的指令，只能在CPU=0下执行。str则没有限制。通常在系统初始化时设置一个TR的初始值，之后TR的值通过任务切换改变。</p>
<p>Task Gate Descriptor（TGD）提供了一种不直接的方式访问TSS，TGD中存了TSS的选择符。TGD可以放在LDT或者IDT中。</p>
<h3 id="任务切换"><a href="#任务切换" class="headerlink" title="任务切换"></a>任务切换</h3><p>那怎么进行任务切换呢？80386提供了几种机制进行进程切换：</p>
<ul>
<li>使用jmp或者call来引用一个TSS descriptor或者Task gate</li>
<li>中断向量指向IDT中的Task gate</li>
<li>NT设置时使用IRET返回。NT用来处理嵌套的Iterrupt Task。ucore-os没有使用这一部分功能。</li>
</ul>
<p>任务切换时进行的步骤如下：</p>
<ul>
<li>检查权限和TSS描述符的合法性</li>
<li>TR存的是当前程序的TSS选择符，从TR保存当前的寄存器、页表、LDTR等到TSS中</li>
<li>将新任务的选择符加载到TR中</li>
<li>将寄存器的值从新任务的TSS中恢复，新任务恢复到上一次保存的CS：EIP处执行</li>
</ul>
<h2 id="ucore-os中的TSS"><a href="#ucore-os中的TSS" class="headerlink" title="ucore-os中的TSS"></a>ucore-os中的TSS</h2><p>TSS一般用于硬件的多任务切换。ucore-os使用的是软件多任务处理，但是也需要TSS的支持。ucore-os总共只使用了一个TSS，用于中断、系统调用等的堆栈切换。</p>
<p>中断时，如果发生了特权级的切换（从用户态到内核态），就会使用TSS中的SS0和ESP0，并将原来的SS和ESP压栈。TSS中除SS0和ESP0的其他内容在ucore-os中没有作用。</p>
<p>在多进程设计时，每个进程运行时都可能发生中断，所以要为每个进行分配独立的中断栈。进程切换时通过设置tss.esp0来实现独立的中断堆栈。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-30T02:58:18.000Z" title="2019-12-30T02:58:18.000Z">2019-12-30</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">4 minutes read (About 672 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/30/os/ucore_os/ucore-os-lab2%EF%BC%9A%E5%AE%9E%E9%AA%8C%E5%87%86%E5%A4%87/">ucore-os-lab2：实验准备</a></h1><div class="content"><p>经过实验1的学习和练习，我们应该能熟练掌握下面的知识：</p>
<ul>
<li>操作系统的基本硬件知识：分段、中断、计算机加电后的执行过程、IO设备初始化过程（选学）</li>
<li>软件知识：函数堆栈、x86常用汇编指令、bootloader的工作原理、ELF格式、操作系统的初始化过程</li>
<li>工具知识：make、gdb、gcc、qemu、shell、c和汇编的混合编译和链接</li>
</ul>
<p>实验2需要掌握的知识：</p>
<ul>
<li>硬件：分段分页机制结合</li>
<li>软件：分段分页机制下的bootloader和操作系统的初始化过程、双向链表</li>
<li>工具：链接器生成的虚拟地址以及如何生成虚拟地址</li>
</ul>
<p>下面的相关笔记会介绍一些相关的知识：</p>
<ul>
<li><img src="#" alt="操作系统初始化过程（启用分页）"></li>
<li><img src="#" alt="ld链接器"></li>
<li>diff和patch命令的使用</li>
</ul>
<h2 id="diff和patch命令的使用"><a href="#diff和patch命令的使用" class="headerlink" title="diff和patch命令的使用"></a>diff和patch命令的使用</h2><p>diff是linux命令用于比较文件和文件夹的差异，patch也是linux命令，可以通过patch应用diff得到的结果，将差异应用到目标文件夹中。<strong>类似git的merge功能。</strong></p>
<p>例如：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">diff	-r	-u	-P	proj_a_original	proj_a_mine	&gt;	diff.patch</span><br><span class="line">cd	proj_b</span><br><span class="line">patch	-p1	-u	&lt;	../diff.patch</span><br></pre></td></tr></table></figure><br>上面的diff将proj_a_mine相对于proj_a_original的修改输出到diff.patch文件中。proj_a_original表示修改之前的文件夹，proj_a_mine表示修改之后的文件夹。</p>
<p>后面的patch将a文件夹的修改应用到b文件夹。例如我们在完成了实验1后，可以用diff比较我们修改的实验1和原始实验1文件夹的差异，然后将修改应用到实验2，这样就能在实验2的文件夹中使用实验1的结果了。</p>
<p>下面对diff和patch的参数做一个分析，diff：</p>
<ul>
<li>-r：递归处理子目录</li>
<li>-u：在合并的上下文中输出行号</li>
<li>-P：显示每一个修改的C函数</li>
</ul>
<p>patch：</p>
<ul>
<li>-p1：去除文件名前面的一个component，这个用于子目录同步，例如./lab2/xxxx和当前为lab3目录下，就需要使用p2，因为差了两级目录，如果是lab2/xxx，就用p1，因为只差了一级目录（从’/‘分割来看，尽管./lab2/xxx和lab2/xxx表示的路径相同）</li>
<li>-u：作为一个整体的差异翻译patch文件</li>
</ul>
<p>这里需要注意patch也需要<code>&lt;</code>来从文件重定向输入。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-26T02:40:10.000Z" title="2019-12-26T02:40:10.000Z">2019-12-26</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">9 minutes read (About 1403 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/26/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B08%EF%BC%9A%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E6%80%BB%E7%BB%93/">ucore-os笔记8：汇编指令总结</a></h1><div class="content"><p>这篇文章总结了ucore-os中使用的汇编语言伪指令，便于更好的理解ucore-os的源码。</p>
<h2 id="汇编程序中的伪指令"><a href="#汇编程序中的伪指令" class="headerlink" title="汇编程序中的伪指令"></a>汇编程序中的伪指令</h2><p>汇编程序中伪指令以 “.”开头，例如.section，.globl等。下面是linux内核源码中常见的集中常见指令：</p>
<h3 id="ascii"><a href="#ascii" class="headerlink" title=".ascii"></a>.ascii</h3><p>  语法： .ascii “string”…<br>  .ascii表示另个或多个（用逗号隔开）字符串，并把每个字符串（结尾不自动加’\0’字符）中的字符放在连续的地址单元。另一个与.ascii类型的是.asciz，z代表’\0’，即每个字符串结尾自动加一个’\0’字符</p>
<h3 id="fill"><a href="#fill" class="headerlink" title=".fill"></a>.fill</h3><p>语法：.fill repeat,size,value<br>其中，repeat，size和value都是常量表达式。.fill和含义是反复拷贝size个字节，重复repeat次。repeat可以大于或者等于0。size也可以大于或者等于0，但不能超过8，超过8也只取8。size个字节的内容讲被填充为value的值，如果size的大小大于value的储存所需要的容量，则将高位用0来填充，例如，如果value的大小位4个字节，size为8，那么高4位的内容被填充为0，低4位内容置为value。<br>size和value为可选项。如果第二个逗号和value值不存在，则假定value为0.如果第一个逗号和size不存在，则假定size为1.</p>
<h3 id="globl"><a href="#globl" class="headerlink" title=".globl"></a>.globl</h3><p>语法：.globl symbol<br>.globl使得链接程序(ld)能够看到symbol。如果你的局部程序中定义了symbol，那么，与这个局部程序连接的其他局部程序也能存取symbol，例如：<br>某个.S 文件的源程序中某一段为如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.data</span><br><span class="line">.globl number</span><br><span class="line">.set number 10</span><br></pre></td></tr></table></figure><br>而与该文件属于同一个文件夹的另一.S 文件的某一段代码为<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">.text</span><br><span class="line">movl $number %eax</span><br></pre></td></tr></table></figure><br>在前一个文件中定义的.globl变量number在后一个文件中可以被引用。</p>
<h2 id="rept-endr"><a href="#rept-endr" class="headerlink" title=".rept .endr"></a>.rept .endr</h2><p>语法：.rept count<br>        ……<br>        .endr<br>把rept与.endr之间的行重复count次，例如：<br>.rept 3<br>.long 0<br>.endr<br>相当于：<br>.long 0<br>.long 0<br>.long 0<br>在这里， .rept 指令比较容易和.fill 指令混淆，它们的区别是.rept 是将.rept 与.endr 之间的指令重复 3 次，而.fill 则是单纯的重复填充数据。</p>
<h3 id="space"><a href="#space" class="headerlink" title=".space"></a>.space</h3><p>语法：.space size,fill<br>这个指令保留size个字节的空间，每个字节的值位fill。size和fill都是常量表达式。如果逗号和fill被省略，则假定fill为0.</p>
<h3 id="byte"><a href="#byte" class="headerlink" title=".byte"></a>.byte</h3><p>语法：.byre expressions<br>预留一个字节，并将这个字节的内容赋值为expression，如果是用逗号隔开的多个expression，则为预留多个这样的字节，并将他们的内容依次赋值。</p>
<h3 id="word"><a href="#word" class="headerlink" title=".word"></a>.word</h3><p>语法：.word expressions<br>预留两个字节，并将这两个字节的内容赋值为expression，如果是用逗号隔开的多个expression，则为预留多个这样的2个字节，并将他们的内容依次赋值。</p>
<h3 id="long"><a href="#long" class="headerlink" title=".long"></a>.long</h3><p>语法：.long expressions<br>预留4个字节，并将这4个字节的内容赋值为expression，如果是用逗号隔开的多个expression，则为预留多个这样的4个字节，并将他们的内容依次赋值。</p>
<h3 id="set"><a href="#set" class="headerlink" title=".set"></a>.set</h3><p>设定常数，就好像C程序中的#define作用一样，例如：.set mark, 0x10，这样在接下来的程序中就可以用诸如movl $mark, eam这样的指令来引用mark。<br>cli指令、sti指令<br>cli将IF置0，屏蔽掉“可屏蔽中断”，当可屏蔽中断到来时CPU不响应，继续执行原指令。<br>而sti相反，sti将IF置1，允许“可屏蔽中断”，中断到来转而处理中断。<br>cld指令、std指令<br>清除方向标志，在字符串的比较、赋值、读取等一系列和rep连用的操作中，di或si是可以自动递减的，而不需要人来加减它的值，cld即告诉程序si、di向前移动。<br>同样，std指令告诉程序si、di向后移动。</p>
<h3 id="include-lt-文件-gt"><a href="#include-lt-文件-gt" class="headerlink" title="#include &lt;文件&gt;"></a><code>#include &lt;文件&gt;</code></h3><p>导入另一个汇编文件，不同汇编器指令不同，例如MASM下是include 文件。<br>在这次内核实验中导入的指令是#include&lt;inc/mmu.h&gt;<br>inb、outb、inw、outw<br>CPU和IO端口进行通讯的指令。b表示一个字节，w表示一个字。例如：inb     $0x64,%al，outb    %al,$0x64</p>
<h3 id="test指令"><a href="#test指令" class="headerlink" title="test指令"></a>test指令</h3><p>语法：test %eax, %ebx<br>test属于逻辑运算指令。功能：执行BIT与BIT之间的逻辑运算，将两个操作数做与运算，仅修改标志位，不回送结果。接下来可以根据标志位进行条件跳转，如jz、jnz等。<br>.code16 .code32<br>这两个指令告诉汇编器接下来的指令是按照16位处理还是32位处理。例如，如果设置成.code32那么接下来的地址处理等都会按照32位进行。</p>
<h3 id="ljmp指令"><a href="#ljmp指令" class="headerlink" title="ljmp指令"></a>ljmp指令</h3><p>语法：ljmp 段选择子，段内偏移<br>ljmp是linux下AT&amp;T格式的汇编指令。表示长跳转。</p>
<h3 id="leave指令"><a href="#leave指令" class="headerlink" title="leave指令"></a>leave指令</h3><p>语法： leave<br>在16位汇编下相当于:<br>mov bp,sp<br>pop bp<br>在32位汇编下相当于:<br>mov ebp,esp<br>pop ebp</p>
<h3 id="ret指令"><a href="#ret指令" class="headerlink" title="ret指令"></a>ret指令</h3><p>pop eip，从栈中弹出返回地址并赋值给eip。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-22T02:11:51.000Z" title="2019-12-22T02:11:51.000Z">2019-12-22</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">21 minutes read (About 3183 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/22/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A05%E3%80%816%E3%80%81%E6%8C%91%E6%88%98%E7%BB%83%E4%B9%A0/">ucore-os-lab1：练习5、6、挑战练习</a></h1><div class="content"><h2 id="练习5-函数堆栈调用"><a href="#练习5-函数堆栈调用" class="headerlink" title="练习5 函数堆栈调用"></a>练习5 函数堆栈调用</h2><p>实验5需要实现函数调用堆栈，请参考ucore-os-lab的要求。</p>
<p>这里我们需要了解函数调用的堆栈变化原理才能完成该练习。函数调用的堆栈变化与两个寄存器相关，ESP和EBP：</p>
<ul>
<li>ESP是栈指针寄存器，存储了当前栈的位置</li>
<li>EBP是基址指针寄存器，存储了当前函数的栈的起始位置</li>
</ul>
<p>调用一个函数时，执行的压栈顺序如下：参数、返回地址、EBP寄存器。后面再压栈的时当前执行的函数的局部变量。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">-------- 栈的高位地址</span><br><span class="line">...</span><br><span class="line">参数3</span><br><span class="line">参数2</span><br><span class="line">参数1</span><br><span class="line">返回地址</span><br><span class="line">上一层ebp  &lt;- 当前ebp寄存器的值</span><br><span class="line">局部变量</span><br><span class="line">...</span><br><span class="line">--------</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>函数调用的汇编代码其实就是多个push（参数push）和一个CALL，CALL自动将返回地址和ebp压栈，并更新ebp的值</p>
</blockquote>
<p>了解了上述的基础知识以后，就可以进行练习的开发了。练习5需要输出ebp、返回地址和参数，并输出源代码的位置，如下例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">ebp:0x00007b28	eip:0x00100992	args:0x00010094	0x00010094	0x00007b58	0x00100096</span><br><span class="line">				kern&#x2F;debug&#x2F;kdebug.c:305:	print_stackframe+22</span><br><span class="line">ebp:0x00007b38	eip:0x00100c79	args:0x00000000	0x00000000	0x00000000	0x00007ba8</span><br><span class="line">				kern&#x2F;debug&#x2F;kmonitor.c:125:	mon_backtrace+10</span><br><span class="line">ebp:0x00007b58	eip:0x00100096	args:0x00000000	0x00007b80	0xffff0000	0x00007b84</span><br><span class="line">				kern&#x2F;init&#x2F;init.c:48:	grade_backtrace2+33</span><br><span class="line">ebp:0x00007b78	eip:0x001000bf	args:0x00000000	0xffff0000	0x00007ba4	0x00000029</span><br><span class="line">				kern&#x2F;init&#x2F;init.c:53:	grade_backtrace1+38</span><br><span class="line">ebp:0x00007b98	eip:0x001000dd	args:0x00000000	0x00100000	0xffff0000	0x0000001d</span><br><span class="line">				kern&#x2F;init&#x2F;init.c:58:	grade_backtrace0+23</span><br><span class="line">ebp:0x00007bb8	eip:0x00100102	args:0x0010353c	0x00103520	0x00001308	0x00000000</span><br><span class="line">				kern&#x2F;init&#x2F;init.c:63:	grade_backtrace+34</span><br><span class="line">ebp:0x00007be8	eip:0x00100059	args:0x00000000	0x00000000	0x00000000	0x00007c53</span><br><span class="line">				kern&#x2F;init&#x2F;init.c:28:	kern_init+88</span><br><span class="line">ebp:0x00007bf8	eip:0x00007d73	args:0xc031fcfa	0xc08ed88e	0x64e4d08e	0xfa7502a8</span><br><span class="line">&lt;unknow&gt;:	--	0x00007d72	–</span><br></pre></td></tr></table></figure></p>
<p>结合上面函数调用栈的规律，看下图：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">-------- 栈的高位地址</span><br><span class="line">    ...</span><br><span class="line"> |-&gt;上上一层ebp的地址</span><br><span class="line"> |  ...</span><br><span class="line"> |  参数3</span><br><span class="line"> |  参数2</span><br><span class="line"> |  参数1           &lt;- ebp+8</span><br><span class="line"> |  返回地址         &lt;- ebp+4，该函数调用的参数、返回地址、ebp都是4个字节</span><br><span class="line"> |---上一层ebp的地址  &lt;- 当前ebp寄存器的值是栈中的地址</span><br><span class="line">    局部变量</span><br><span class="line">    ...</span><br><span class="line">--------</span><br></pre></td></tr></table></figure><br>栈中的ebp就像一个链表，通过ebp的链接关系，我们就可以得到栈调用关系。看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span></span><br><span class="line">print_stackframe(<span class="keyword">void</span>) &#123;</span><br><span class="line">     <span class="comment">/* LAB1 YOUR CODE : STEP 1 */</span></span><br><span class="line">     <span class="comment">/* (1) call read_ebp() to get the value of ebp. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (2) call read_eip() to get the value of eip. the type is (uint32_t);</span></span><br><span class="line"><span class="comment">      * (3) from 0 .. STACKFRAME_DEPTH</span></span><br><span class="line"><span class="comment">      *    (3.1) printf value of ebp, eip</span></span><br><span class="line"><span class="comment">      *    (3.2) (uint32_t)calling arguments [0..4] = the contents in address (uint32_t)ebp +2 [0..4]</span></span><br><span class="line"><span class="comment">      *    (3.3) cprintf("\n");</span></span><br><span class="line"><span class="comment">      *    (3.4) call print_debuginfo(eip-1) to print the C calling function name and line number, etc.</span></span><br><span class="line"><span class="comment">      *    (3.5) popup a calling stackframe</span></span><br><span class="line"><span class="comment">      *           NOTICE: the calling funciton's return addr eip  = ss:[ebp+4]</span></span><br><span class="line"><span class="comment">      *                   the calling funciton's ebp = ss:[ebp]</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="keyword">uint32_t</span> ebp = read_ebp(), eip = read_eip();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(ebp &amp;&amp; j &lt; STACKFRAME_DEPTH) &#123;</span><br><span class="line">        cprintf(<span class="string">"ebp:0x%08x eip:0x%08x args:"</span>,ebp, eip);</span><br><span class="line">        <span class="keyword">uintptr_t</span> ptr = ebp+<span class="number">8</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">            cprintf(<span class="string">" 0x%08x"</span>, *((<span class="keyword">uint32_t</span>*)ptr+i));</span><br><span class="line">        &#125;</span><br><span class="line">        cprintf(<span class="string">"\n"</span>);</span><br><span class="line">        print_debuginfo(eip<span class="number">-1</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 这里取的是栈中的ebp和返回地址，所以必须先取eip</span></span><br><span class="line">        <span class="comment">// 没有重复的原因是，read_eip中取到的eip，调用read_eip函数压了一次栈</span></span><br><span class="line">        eip = *((<span class="keyword">uint32_t</span>*)ebp+<span class="number">1</span>);</span><br><span class="line">        <span class="comment">// ebp是一个整数，但是表示一个地址，(uint32_t*)ebp会将ebp的值作为地址解释</span></span><br><span class="line">        <span class="comment">// *(uint32_t*)ebp，取地址中的内容，是上一个ebp的地址</span></span><br><span class="line">        ebp = *(<span class="keyword">uint32_t</span>*)ebp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>read_ebp和read_eip其实就是两个内联汇编函数，加载ebp和[ebp+4]（返回地址）到C变量中。因为ebp存的是地址，而eip的地址相对于ebp的值，所以必须先取eip的值，再变ebp的值。<code>print_debuginfo()</code>是一个ucore-os已经提供的函数，传入地址，得到文件名和行数，实现原理是将编译器的符号表信息通过链接器加载到内核的内存中，通过查找符号表就知道对应哪一个符号、哪一个文件、哪一行。</p>
<p>eip实际上是返回地址，返回地址是函数调用的下一条指令的地址，所以这里参数传的是eip-1，就能定位到函数调用的指令中。</p>
<h2 id="练习6-完善中断初始化和处理"><a href="#练习6-完善中断初始化和处理" class="headerlink" title="练习6 完善中断初始化和处理"></a>练习6 完善中断初始化和处理</h2><p>练习6要完成下面几个目标：</p>
<ol>
<li>了解中断向量表的结构，一个表项几个字节？如何寻址中断向量表？</li>
<li>完善kern/trap/trap.c中的idt_init</li>
<li>完善trap函数，处理时钟中断，每100次时钟中断输出一个100tick</li>
</ol>
<p>这一部分需要了解中断的相关知识和ucore-os对中断的实现的知识才能顺利完成，请参考<a href="#ucore-os对中断向量表的处理">ucore-os笔记6：中断和异常</a>。</p>
<p>ucore-os提供了SETGATE宏函数，传入参数，扩展成一个门表项（可以是任务门、中断门、陷阱门、调用门，反正结构都一样），可以在代码中利用该宏。vector.S中定义了<code>__vectors.S</code>符号，其值是中断向量处理程序入口数组的起始地址。由于是全局符号，链接后能够直接在C中访问。</p>
<p>idt_init函数中要做的事情就是构造idt表项，并将idt的起始地址加载到IDTR中。要注意不同中断的权限不一样，例如T_SYSTEM可以在用户态（特权级为3调用），而其他的只能在特权级为0调用。还要注意向量的起始地址在<code>__vectors</code>中。看代码，注意注释中的细节：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将__vectors[]声明为外部变量，__vectors[]在汇编文件中定义，链接后通过extern可以访问外部文件中的符号</span></span><br><span class="line"><span class="comment">// 这里只能将__vectors声明为数组，而不能声明为指针。如果是指针会访问到数组的第一个元素，</span></span><br><span class="line"><span class="comment">// 因为将vectors当作指针的地址了，指针的值就是数组的第一项了。虽然数组和指针可以相互转化，</span></span><br><span class="line"><span class="comment">// 但是将一个地址作为指针的地址还是作为数组的地址是不一样的</span></span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">uintptr_t</span> __vectors[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 初始化中断向量表idt，处理程序的入口在__vectors[]中，__vectors[]的每一项是一个地址</span></span><br><span class="line"><span class="comment">// T_SYSCALL是trap，并且DPL是用户级3。其他的中断都是interrupt，DPL为0</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++) &#123;</span><br><span class="line">  <span class="comment">// cprintf("interrupt entry:0x%08x\n", __vectors[i]);</span></span><br><span class="line">  <span class="keyword">if</span>(i == T_SYSCALL) &#123;</span><br><span class="line">      <span class="comment">// KERNEL_CS是内核代码段的起始地址</span></span><br><span class="line">      SETGATE(idt[i],<span class="number">1</span>,KERNEL_CS,__vectors[i],<span class="number">3</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      SETGATE(idt[i],<span class="number">0</span>,KERNEL_CS,__vectors[i],<span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">lidt(&amp;idt_pd);</span><br></pre></td></tr></table></figure></p>
<h3 id="处理时钟中断"><a href="#处理时钟中断" class="headerlink" title="处理时钟中断"></a>处理时钟中断</h3><p>当中断发生时，调用链是<code>__vectors</code>中的入口地址-&gt;<code>__alltraps</code>-&gt;trap-&gt;trap_dispatch-&gt;根据中断向量号处理。</p>
<p>所以我们找到trap_dispatch中的时钟中断：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* trap_dispatch - dispatch based on what type of trap occurred */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">trap_dispatch(struct trapframe *tf) &#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (tf-&gt;tf_trapno) &#123;</span><br><span class="line">    <span class="keyword">case</span> IRQ_OFFSET + IRQ_TIMER:</span><br><span class="line">        <span class="comment">/* LAB1 YOUR CODE : STEP 3 */</span></span><br><span class="line">        <span class="comment">/* handle the timer interrupt */</span></span><br><span class="line">        <span class="comment">/* (1) After a timer interrupt, you should record this event using a global variable (increase it), such as ticks in kern/driver/clock.c</span></span><br><span class="line"><span class="comment">         * (2) Every TICK_NUM cycle, you can print some info using a funciton, such as print_ticks().</span></span><br><span class="line"><span class="comment">         * (3) Too Simple? Yes, I think so!</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        ticks++;</span><br><span class="line">        <span class="keyword">if</span>(ticks == <span class="number">100</span>) &#123;</span><br><span class="line">            print_ticks();</span><br><span class="line">            ticks = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// ...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>使用IRQ_OFFSET=32是因为中断向量的前32个被CPU保留了，像时钟中断等硬件中断都由系统设计者决定应该使用哪个中断，ucore-os设计将IRQ_TIMER作为自定义的第一个中断，值为0，所以IRQ_OFFSET+IRQ_TIMER=32，是第一个自定义的中断向量。</p>
<blockquote>
<p>这里各种中断与中断控制器有关，中断控制器的设置在操作系统初始化的时候进行，请看<a href="#">ucore-os的初始化过程</a>和<a href="#">IO和基本硬件访问</a>。IO和计算机接口技术和计算机组成原理的知识息息相关，<a href="#">ucore-os中用到的组成原理和计算机接口知识间接</a>给出大致的了解。</p>
</blockquote>
<h3 id="挑战练习1-添加syscall"><a href="#挑战练习1-添加syscall" class="headerlink" title="挑战练习1 添加syscall"></a>挑战练习1 添加syscall</h3><p>添加一个用户态函数，当内核初始完毕从内核态切换到用户态，在用户态通过syscall获取内核中的tick值，然后再从内核态切换到用户态。调用结构如图：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span>	<span class="keyword">void</span></span><br><span class="line">switch_test(<span class="keyword">void</span>)	&#123;</span><br><span class="line">   print_cur_status();										<span class="comment">//	print	当前	cs/ss/ds	等寄存器状态</span></span><br><span class="line">   cprintf(<span class="string">"+++	switch	to		user		mode	+++\n"</span>);</span><br><span class="line">   switch_to_user();												<span class="comment">//	switch	to	user	mode</span></span><br><span class="line">   print_cur_status();</span><br><span class="line">   cprintf(<span class="string">"+++	switch	to	kernel	mode	+++\n"</span>);</span><br><span class="line">   switch_to_kernel();									<span class="comment">//	switch	to	kernel	mode</span></span><br><span class="line">   print_cur_status();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>切换函数通过中断的方式实现，再trap里面完成T_SWITCH_TO*中断。完成后执行make grade能看到分数。</p>
<h4 id="答："><a href="#答：" class="headerlink" title="答："></a>答：</h4><p>这里我们需要弄清楚两部分的知识，一个是如何完成用户态到内核态的切换，另一个是添加一个系统调用获取tick。</p>
<p>添加系统的调用非常简单。就是在中断初始化时，将中断向量表的T_SYSCALL设为用户态（DPL=3，这样能够由用户态触发该中断），然后在trap_dispatch中添加T_SYSCALL的处理代码。</p>
<p>内核和用户态的切换通过中断调用进行，将用户到内核的中断设置成用户可访问，用户就能够通过中断切换到内核态，从中断返回时，会从栈中恢复cs、ds等等寄存器，用户态和内核态的区分实际上就是cs中的DPL的区分。只需要在中断处理程序中设置cs、ds等寄存器的值，即可实现用户态和内核态的切换。</p>
<p>这里需要注意，从中断返回时，如果发生了特权级的切换，会多弹出ss和esp，一定要处理这一点。例如在switch_to_user中，从内核态返回用户态，会多弹出SS和ESP，但是进入中断的时候没有发生特权级切换，所以不会压入ss和esp，这里需要手动压入（或者使用<code>subl $8, %%esp</code>预留位置，然后int后接<code>movl %%ebp, %%esp</code>恢复esp，个人不推荐这种方式，如果栈中有局部变量，这样就会出问题）。switch_to_kernel中，因为产生中断的时候是从用户态到内核态，会压入ss和esp；但是返回的时候是从内核态到内核态，所以不会弹出ss和esp，需要手动弹出。看代码：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_user(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 : TODO</span></span><br><span class="line">    <span class="comment">// esp压栈两个字节，为esp和ss留出空间</span></span><br><span class="line">    <span class="comment">// 因为从切换到用户态，执行iret时，会从内核栈中弹出esp和ss，我们在trap.c的trap函数中，改变栈中的ss，就可以切换到用户堆栈</span></span><br><span class="line">    <span class="comment">// 但是最开始时内核态到内核态，cpu不会压栈esp和ss，所以需要手动压栈</span></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    <span class="comment">// 从中断返回的时候是从内核态返回到用户态，发生了特权级的切换，所以会弹出esp和ss</span></span><br><span class="line">    <span class="comment">// 但是产生中断的时候cpu不会自动压入，所以要手动压入</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl %%esp, %%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"pushl %%ss;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"pushl %%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="comment">// "movl %%ebp,%%esp;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        :<span class="string">"i"</span>(T_SWITCH_TOU)</span></span></span><br><span class="line"><span class="function"><span class="params">        :<span class="string">"%eax"</span>)</span></span>;</span><br><span class="line">        <span class="comment">// print_stackframe();</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">lab1_switch_to_kernel(<span class="keyword">void</span>) &#123;</span><br><span class="line">    <span class="comment">//LAB1 CHALLENGE 1 :  TODO</span></span><br><span class="line">    <span class="comment">// 注意触发中断的时候压入了ss和esp，但是返回的时候并不会弹出，因为返回的时候没有发生特权级的切换</span></span><br><span class="line">    <span class="comment">// 但是这里不能直接将esp+8，因为从用户到内核态的中断使用的内核栈是一个临时栈</span></span><br><span class="line">    <span class="comment">// 正确的方式取出ss和esp，然后恢复到ss和esp寄存器中，也不能直接pop，因为pop会改变esp...</span></span><br><span class="line">    <span class="function"><span class="keyword">asm</span> <span class="title">volatile</span> <span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"int %0;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl %%esp, %%eax;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movw 4(%%eax),%%ss;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        <span class="string">"movl (%%eax),%%esp;"</span></span></span></span><br><span class="line"><span class="function"><span class="params">        :</span></span></span><br><span class="line"><span class="function"><span class="params">        :<span class="string">"i"</span>(T_SWITCH_TOK)</span></span></span><br><span class="line"><span class="function"><span class="params">        :<span class="string">"%eax"</span>)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<blockquote>
<p>lab1虽然启动的分段机制，但是在物理地址上并没有区分内核段和用户段，也没有区分数据段和代码段，GDT中所有段的基址都是0，limit都是4G，所以这里不需要考虑切换cs后物理寻址的问题。相同的偏移，分段处理后在lab1中会得到相同的物理地址。</p>
</blockquote>
<h3 id="挑战练习2-键盘实现用户模式到内核模式的切换"><a href="#挑战练习2-键盘实现用户模式到内核模式的切换" class="headerlink" title="挑战练习2 键盘实现用户模式到内核模式的切换"></a>挑战练习2 键盘实现用户模式到内核模式的切换</h3><p>使用键盘完成用户模式到内核模式的切换。</p>
<h4 id="答：-1"><a href="#答：-1" class="headerlink" title="答："></a>答：</h4><p>上一个实验已经完成了用户模式到内核模式的切换，这里只需要复用上一次实验的代码就可以了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-22T01:49:15.000Z" title="2019-12-22T01:49:15.000Z">2019-12-22</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">5 minutes read (About 728 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/22/os/ucore_os/ucore-os-lab1%EF%BC%9A%E7%BB%83%E4%B9%A03%E3%80%81%E7%BB%83%E4%B9%A04/">ucore-os-lab1：练习3、练习4</a></h1><div class="content"><p>练习三需要分析如何从实模式进入保护模式，重点是：</p>
<ul>
<li>为何开启A20以及如何开启A20？</li>
<li>如何初始化GDT表？</li>
<li>如何使能和进入保护模式？</li>
</ul>
<p>详细的解释请看<a href="#">ucore-os笔记4：bois和bootloader</a>。这里只给出简单解释：</p>
<ol>
<li>在实模式下只能访问1MB的内存，这是为了向下兼容，所以实模式下禁用了第21根地址线保证最大只能访问1MB内存。为了硬件设计成本的考虑，A20的控制放在键盘控制器中，需要设置键盘控制器内部输出端口的对应位来开启。如果不开启A20，第21根地址线就无法使用，保护模式下不能完整的访问4G内存。</li>
<li>需要将GDT表放置到内存中，表项是8字节大小，按照一定的结构存储。然后需要将GDT表的入口地址（线性地址）和大小放到GDTR寄存器中，使用lgdt指令可以设置GDTR寄存器，lgdt指令只能在特权为0的情况下使用</li>
<li>使用保护模式，需要设置CRO寄存器中的PE位来开启保护模式，然后通过ljmp设置cs寄存器，mov设置其他的段寄存器。之后的内存访问就使用分段机制了。</li>
</ol>
<p>练习4分析bootloader如何加载ELF格式的OS。这里需要了解：</p>
<ul>
<li>ELF格式的结构？</li>
<li>如何读取硬盘扇区？</li>
<li>如何加载ELF格式的OS？</li>
</ul>
<p>详细信息都在<a href="#">ucore-os笔记4：bois和bootloader</a>中。下面是简单的回答：</p>
<ol>
<li>ELF格式分成ELF header和多个段。ELF可以分成可执行、链接库等等格式，可执行中最终要的elf program header。elf header中给出了elf program header的偏移和项数，elf program header是一个数组，每一项表示一个段的偏移、大小和起始虚拟地址，通过偏移+文件大小可以知道段在elf文件中的位置，将其加载到内存中对应的虚拟地址的位置即可。（虚拟地址是由链接器决定的，在编译时就确定了在其地址空间的哪一个部分，通过设置链接器可以改变放置的虚拟地址的位置）。</li>
<li>硬盘只能按扇区对齐读取，一个扇区是512字节。通过访问硬盘控制器并设置相应的命令和参数，就可以从键盘控制器中读取到内存中。</li>
<li>分析ELF结构，从program header中知道段的数量和在磁盘中的位置，通过这些信息将其加载到内存中。</li>
</ol>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-20T04:41:13.000Z" title="2019-12-20T04:41:13.000Z">2019-12-20</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">39 minutes read (About 5858 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/20/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B07%EF%BC%9A%E5%88%86%E6%AE%B5%E5%92%8C%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6/">ucore-os笔记7：分段和分页机制</a></h1><div class="content"><p>前面我们讨论了x86的保护模式和实模式的区别，最新的处理器架构都运行在保护模式下，但是为了向下兼容都也支持实模式。这里学习的分段和分页机制都是保护模式提供的机制，通过CPU为内存提供了抽象。这篇文章详细学习分段和分页相关原理和相关硬件、软件的知识。</p>
<h2 id="地址空间"><a href="#地址空间" class="headerlink" title="地址空间"></a>地址空间</h2><p>在讨论分段和分页机制之前，首先要讨论地址空间的概念。在最早的CPU架构中，使用的都是物理地址，所有的程序都能够访问任何一处物理地址，这样在程序保护和隔离以及并发程序的内存分配存在很大的问题。</p>
<p>所以最初的设想就是能够让不同的程序地址隔离，同时能够有访问权限的区分。例如程序a的28地址和程序b的28地址是不一样的，那么就能在逻辑上实现a和b的地址空间上隔离的。但是物理地址只有已有，要让a和b的28地址得到的物理地址不同，最好的方式就是地址重定向，将a和b的28重定向到不同的物理地址。可以用软件来实现，例如在每次内存访问前重新计算地址。但是最好的方式是将这一部分提取出来，所以80386以后的x86架构CPU都内置了重定位功能，称为分段机制。</p>
<p>分段机制由段来实现<code>重定向</code>的功能，采用段+偏移这种形式，偏移是程序员可见的地址，称为逻辑地址（或虚拟地址）。在内存访问前，CPU会自动将段基址加上，分段机制计算之后的地址称为线性地址，计算方式是<code>段基址+偏移=线性地址</code>。</p>
<p>在没有开启分页机制的机器中，线性地址就等于物理地址。</p>
<p>现在实现了地址重定向，但是还有更多的问题没有解决。对于32位cpu，最多能够访问4g的内存，但是有时候物理内存没有4g，一种方式是将一部分内存交换到硬盘中，当需要使用的时候再将这一部分内容交换到RAM中。如何实现高效的交换也是一个问题，分页机制就可以实现这样的功能，分页机制以页位单位来进行内存的分配和交换，提供了对RAM和硬盘的抽象。分页机制会检查需要的数据是在内存中还是在硬盘中，如果再硬盘中会自动将数据交换到内存中。</p>
<p>地址的转化是：逻辑地址-&gt;分段机制-&gt;线性地址-&gt;分页机制-&gt;物理地址</p>
<p>逻辑地址空间、线性地址空间、物理地址空间分别是三个阶段对应的不同的地址空间，前两者都是一种抽象，从真实的物理空间上抽象出来的地址空间，通过一定的匹配将空间中的地址映射成真实的地址。</p>
<h2 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h2><p>分段机制是实现内存抽象和保护的关键，分段机制提供了4个特权级和完整的特权级检查，由此能够实现操作系统内核，关键软件，用户态程序的区分。硬件实现的特权级检查能够有效的保护系统的运行。分段机制的核心是GDTR（全局描述符表寄存器）、GDT（全局描述符表）、LDTR（局部描述符表寄存器）、LDT（局部描述符表）。分段机制与段寄存器（cs、ds、ss等）、GDTR、GDT有关。通过lgdt和sgdt指令能够操作gdtr。lldt和sldt能够操作ldtr。</p>
<p>GDTR是全局描述符表寄存器，存放GDT的起始地址和大小。GDT是全局描述符表，存放在内存中，每一个表项包含一个段的信息，包含段基址、段界限、段属性等。LDTR和LDT类似。</p>
<p>分段机制划分的段和程序编译时的代码、数据、堆栈段是相同的，区别是程序编译的很多段例如bss等会放在CPU的数据段中，不一定完全对应。</p>
<p>x86中有段寄存器cs、ds、ss、es、fs、gs，这些段寄存器用于分段机制，段寄存器中存的是选择符，选择符用于选中GDT中特定的项，项中有段的起始地址和界限等等。转换过程如下：<br><img src="/img/分段机制.png" alt="分段机制"></p>
<p>GDTR中存了GDT的基址，段寄存器中存了GDT的索引index，通过GDTR+index*8就得到段描述符的地址，从段描述符中取出基址，基址+偏移地址得到线性地址。</p>
<p>段寄存器/选择符：<br><img src="/img/段描述符.gif" alt="段寄存器"></p>
<ul>
<li>index：GDT中的段描述符</li>
<li>TI：0表示访问GDT、1表示访问LDT</li>
<li>RPL：请求特权级，在特权访问中起作用</li>
</ul>
<p>对于cs只能通过间接方式来设置，例如jmp、call等指令，其他的段寄存器能够通过mov等指令来设置。</p>
<p>GDT和LDT：<br><img src="/img/GDT和LDT访问.png" alt="ds"></p>
<p>段描述符：<br><img src="/img/段描述符.png" alt="段描述符"></p>
<ul>
<li>段基地址:规定线性地址空间中段的起始地址。在80386保护模式下,段基地址长32位。<br>因为基地址长度与寻址地址的长度相同,所以任何一个段都可以从32位线性地址空间中<br>的任何一个字节开始,而不象实方式下规定的边界必须被16整除。</li>
<li>段界限:规定段的大小。<strong>在80386保护模式下,段界限用20位表示,而且段界限可以是以<br>字节为单位或以4K字节为单位</strong>。ucore中使用的是4K，一个段的最大是4G</li>
<li>段属性:确定段的各种性质。<ul>
<li>段属性中的粒度位(Granularity),用符号G标记。G=0表示段界限以字节位位单<br>位,20位的界限可表示的范围是1字节至1M字节,增量为1字节;G=1表示段界限以<br>4K字节为单位,于是20位的界限可表示的范围是4K</li>
<li>段属性中的粒度位(Granularity),用符号G标记。G=0表示段界限以字节位位单<br>位,20位的界限可表示的范围是1字节至1M字节,增量为1字节;G=1表示段界限以<br>4K字节为单位,于是20位的界限可表示的范围是4K字节至4G字节,增量为4K字<br>节。</li>
<li>类型(TYPE):用于区别不同类型的描述符。可表示所描述的段是代码段还是数据<br>段,所描述的段是否可读/写/执行,段的扩展方向等。</li>
<li>描述符特权级(Descriptor    Privilege    Level)(DPL):用来实现保护机制。</li>
<li>段存在位(Segment-Present    bit):如果这一位为0,则此描述符为非法的,不能被<br>用来实现地址转换。如果一个非法描述符被加载进一个段寄存器,处理器会立即产<br>生异常。图5-4显示了当存在位为0时,描述符的格式。操作系统可以任意的使用被<br>标识为可用(AVAILABLE)的位。</li>
<li>已访问位(Accessed    bit):当处理器访问该段(当一个指向该段描述符的选择子被<br>加载进一个段寄存器)时,将自动设置访问位。操作系统可清除该位。</li>
</ul>
</li>
</ul>
<p>GDTR是48位寄存器，高32位是GDT/LDT的线性基地址，低16位是段描述符表的大小，以字节为单位。</p>
<h3 id="LDT"><a href="#LDT" class="headerlink" title="LDT"></a>LDT</h3><p>LDT在ucore lab中没有使用，这里做一个简单介绍。</p>
<p>LDTR和GDTR不同，LDTR是16位的，和cs等段寄存器的功能相同。当启用了LDT之后，即段寄存器中的TI=1，此时GDT对应表项的基址变成了LDT的起始地址，界限变成了LDT的界限，通过GDT中的LDT基址和LDTR来找到LDT中的段选择符。</p>
<p>LDT嵌套的GDT中，每一个任务可以有一个LDT，就可以将单个任务的代码、数据、堆栈封装在同一个LDT下。任务切换时，只需要加载LDTR。<br><img src="/img/ldt的使用.png" alt="ldt"></p>
<p>LDT的访问过程<br>当TI=1时表示段选择符在LDT中。</p>
<ol>
<li>从GDTR寄存器获取GDT基址</li>
<li>从LDTR寄存器高13位索引到GDT中的LDT的选择符</li>
<li>从得到的LDT选择符中得到LDT段基址</li>
<li>然后利用段寄存器中的高13位得到LDT中的段描述符。</li>
<li>从段描述符中读取段基址，基址加上偏移地址得到线性地址。</li>
</ol>
<h2 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h2><p>分页机制将线性地址转换成物理地址。分页机制提供了基于页的虚拟内存以及页面保护。分页机制是可选的，当且仅当CR0寄存器的PG位设置了以后分页机制才会开启，所以一般在操作系统初始化的时候设置PG位。</p>
<h3 id="页框"><a href="#页框" class="headerlink" title="页框"></a>页框</h3><p>一个页框是大小位4kb的连续物理地址。</p>
<h3 id="线性地址"><a href="#线性地址" class="headerlink" title="线性地址"></a>线性地址</h3><p>32位的线性地址在分页机制中分成三个部分，31-22位是DIR，用于索引页目录，21-12位是PAGE，用于索引页表，低12位是偏移，用于索引页框中的线性地址。如下图：<br><img src="/img/线性地址分页.gif" alt="线性地址"></p>
<h3 id="页表"><a href="#页表" class="headerlink" title="页表"></a>页表</h3><p>页表大小为4KB，页表的每一项的大小是4byte，共有1K页。页目录的大小也为4KB，其中有1K项。所以整个分页机制映射的空间是$2^{10} <em> 2^{10} </em> 2^{12} = 2^{32}$，刚好将4G的线性空间一一映射到每一个页框中的每一项。</p>
<p>页目录的物理地址存在CR3寄存器中。在操作系统初始化时，如果开启分页机制，就要设置CR3寄存器为<strong>页目录的物理地址</strong>。当MMU处理地址时，会自动使用CR3中的页目录地址来进行分页处理。</p>
<h3 id="页表项"><a href="#页表项" class="headerlink" title="页表项"></a>页表项</h3><p>页表项的大小为32位，结构如下图：<br><img src="/img/页表项.gif" alt="页表项"></p>
<p>前20位是页框地址。地址不是32位吗？为什么这里是20位呢？因为页框的大小是4KB，其起始地址肯定4KB对齐，所以低12位都是0，这里就只存了高20位，当用作地址时，CPU会自动将这20位作为地址的高20位而低12位置0。对于页目录而言，这20位就是<strong>页表的起始物理地址</strong>，对于页表而言，就是<strong>页框的起始物理地址</strong>。</p>
<p>最低位是P，表示Present Bit，如果该位为0，则表示该页表项不能用作地址翻译，CPU在分页处理时，如果遇到P=0的项，则会出现一个页异常，进入页异常的中断处理程序。<strong>该位的设置是实现虚拟内存的关键</strong>。</p>
<p>A和D为表示Access和Dirty位。在读写任意页表前，会将对应的页表项的Access位设置成1。在写入页表时会自动设置dirty位为1，页目录中dirty是未定义的。</p>
<p>如上所述，CPU会自动设置对应的位，但是不会自动清除，需要程序来清除，这个工作一般是由操作系统来负责。通过dirty和access位可以用于实现页面调度算法、缓存写回等等策略。</p>
<p>R/W和U/S位用于特权级的处理，后文说明。</p>
<h3 id="cache"><a href="#cache" class="headerlink" title="cache"></a>cache</h3><p>在操作系统原理中，为了加速页面映射的速度，会使用TLB，TLB有硬件管理和软件管理。80386使用的是硬件管理，即CPU自动缓存最近使用的页面，自动替换缓存。对于操作系统来说，要做的就是清空缓存，通过<code>MOVL %CR3, %EAX</code>设置CR3会清空缓存。或者任务切换的时候重新设置CR3也会清空缓存。</p>
<h2 id="组合分段和分页机制"><a href="#组合分段和分页机制" class="headerlink" title="组合分段和分页机制"></a>组合分段和分页机制</h2><p>通过分段和分页机制的结合，可以设计多种内存管理策略。根据系统的需求，可以直接访问物理地址，也可以添加虚拟内存，在硬件的能力上，可以做任何自己想要的内存管理设计。这就是机制和策略的区别。</p>
<p>80386不能禁用分段机制，但是可以通过设置相同的段寄存器并且不再改变其值来实现类型禁用的效果。</p>
<p>允许每一个段大于或者小于4KB（一个页面的大小）。对于段大于4KB的时候，段会被分成若干个页面，对于启用了虚拟内存的系统来说，这若干个页面可能在RAM中，也可能在硬盘中。对于段小于4KB的时候，<strong>待说明</strong></p>
<p>分段和分页机制组合：<br><img src="/img/分段和分页组合.gif" alt="分段和分页机制"></p>
<h3 id="段页对齐说明"><a href="#段页对齐说明" class="headerlink" title="段页对齐说明"></a>段页对齐说明</h3><p>80386架构并不强制要求段按照4KB对齐，所以可能出现一个页面包含一个段的结束同时也包含另一个段的开始。内存管理软件为了简单，可能会让段的分配按照页对齐，那么这样段页的分配就一致了。</p>
<h2 id="分段和分页中的保护"><a href="#分段和分页中的保护" class="headerlink" title="分段和分页中的保护"></a>分段和分页中的保护</h2><p>80386提供了内存访问及指令执行的保护，包括下面5个方面的保护：</p>
<ol>
<li>类型检查</li>
<li>界限检查</li>
<li>可寻址区域的先值</li>
<li>程序入口的限制</li>
<li>指令集的限制</li>
</ol>
<p>每次内存访问前都会进行保护检查，检查失败时将会触发一个保护异常。特权级时保护的中心概念，上面提到的3、4、5保护都基于特权级。</p>
<h3 id="分段保护"><a href="#分段保护" class="headerlink" title="分段保护"></a>分段保护</h3><p>上面提到的所有保护都应用于段处理过程中。段描述符中存了RPL，RPL占两个bit，能表示0-3四个特权级。<strong>CPU在段描述符被加载到寄存器中，以及每次段寄存器访问时进行检查</strong>。</p>
<p>描述表中的每一项中也含有DPL用于特权级的检查。段选择符对应的描述符表项会被加载到CPU中，而不是每次内存访问都去内存中找GDT，不需要担心性能问题。<br><img src="/img/段描述符表项.png" alt="段描述符表项"></p>
<p>从上图我们可以看到GDT或者LDT中的描述符分为三种，数据段描述符、可执行段、系统段描述符。三个段结构上的主要区别是type和AVL等四位的区别。type中的有可读、可写、可执行等等属性，描述一个段的特性，这些特性将会在type checking时起作用，因为不可能让不可执行的描述符加载到CS中吧？</p>
<h4 id="类型检查"><a href="#类型检查" class="headerlink" title="类型检查"></a>类型检查</h4><p>描述符中的type用于描述一个段的作用以及段的种类，可以用type来区分数据段、代码段等。type中的各位主要是设置可读、可写等等属性。描述符也可以是门描述符，<strong>此部分待补充。</strong></p>
<ul>
<li>只有可写的数据段才能向其中写入数据，例如<code>mov %eax, $123123</code>，如果当前段不是可写的，那么尝试向段中写会触发保护异常</li>
<li>只有可读的可执行段才能读取其中的指令。通过cs寄存器或者将可执行段描述符加载到ds、es、fs、gs寄存器中可读取指令</li>
</ul>
<p>可执行段只可能读而不可能写，防止了篡改代码指令的可能性。也防止程序员错误加载段导致的错误。CPU在下面两种情形下进行类型检查：</p>
<ul>
<li>描述符被加载到寄存器中时：<ul>
<li>CS只能加载可执行段的描述符。同时该段必须可读</li>
<li>只有可写的数据段能够被加载到ss</li>
</ul>
</li>
<li>指令显式或者隐式的引用段寄存器的时候：<ul>
<li>可执行段不能写</li>
<li>不可写的数据段不能写</li>
<li>不可读的可执行段不能读</li>
</ul>
</li>
</ul>
<h4 id="界限检查"><a href="#界限检查" class="headerlink" title="界限检查"></a>界限检查</h4><p>界限检查防止访问段以外的内存。界限检查的细节和B、G、E等为的设置有关，这里暂时没有看懂详细的细节，后面用到的时候补充。</p>
<p>目前只需要知道界限检查用于防止访问段以外的内存即可</p>
<h4 id="特权级检查"><a href="#特权级检查" class="headerlink" title="特权级检查"></a>特权级检查</h4><p>一共有4个特权级。段中通过下面三个来检查特权级：</p>
<ul>
<li>CPL：当前运行的代码段的特权级，是段描述符中的DPL。CS中的DPL不一定等于描述符中的DPL，例如中断处理过程中改变了CS为用户态，这时候CS就和段描述符的DPL不相同了，这时候的控制转移检查在下一小节学习。</li>
<li>DPL：目标段的特权级，在描述符中</li>
<li>RPL：请求特权级，在段寄存器中</li>
</ul>
<p>只有max(CPL, RPL) &lt;= DPL时，才能访问描述符请求的段。也就是只能访问特权级相同或者更低的段。如图：<br><img src="/img/特权检查.gif" alt="priviledge"></p>
<h4 id="限制控制转移"><a href="#限制控制转移" class="headerlink" title="限制控制转移"></a>限制控制转移</h4><p>通过JMP、CALL、RET、INT、IRET可以进行控制权的转移。</p>
<p>JMP和CALL有短调用和长调用两种方式，短调用仅仅只能够进行当前代码段中的转移；长调用可以寻址到其他段，通过使用段描述符或者调用门描述符，长调用仅能够调用相同特权级的可执行段或者C位为1并且优先级更低的段。设置了C位的段一般是共享代码库，能被多种特权级的程序调用，调用这种段是特权级不会改变，这也是唯一的CPL和当前执行段的DPL不同的情况。</p>
<p>JMP只能调转到优先级相同的段，而CALL通过调用门的方式能够访问优先级更高的段。<strong>门描述符就是系统类型的段描述符（上面有说到三种类型的段描述符：可执行、数据、系统三种类型），门描述符可能放在GDT、LDT中，也可能放在IDT中，例如调用门描述符就放在GDT/LDT中，而中断门、陷阱门、任务门描述符就放在IDT中</strong>。接下来讲调用门描述符：</p>
<h4 id="门描述符保护程序入口"><a href="#门描述符保护程序入口" class="headerlink" title="门描述符保护程序入口"></a>门描述符保护程序入口</h4><p>为了保护不同特权级之间的可执行段之间的控制权传递，提供了下面四种门描述符：</p>
<ul>
<li>调用门</li>
<li>陷阱门</li>
<li>中断门</li>
<li>任务门</li>
</ul>
<p>任务门在<a href="#">多任务切换</a>中学习，陷阱门在<img src="#" alt="中断和异常">中学习。这里只介绍调用门。调用门放在LDT/GDT中，有两个作用：</p>
<ol>
<li>定义程序的入口</li>
<li>定义入口的特权级</li>
</ol>
<p>调用门在CALL和JMP中也使用段选择符，只不过选择符选中的是调用门描述符。CPU会自动识别调用门描述符。</p>
<p>调用门的寻址过程是：段选择器的选择符-&gt;GDT中的门描述符-&gt;门描述符中的选择符和偏移-&gt;GDT中的段描述符-&gt;可执行段，如下图：<br><img src="/img/门寻址.gif" alt="门寻址"></p>
<p>这里就涉及到4个特权级：</p>
<ul>
<li>CPL</li>
<li>RPL</li>
<li>gate DPL：门的DPL</li>
<li>target DPL：门的选择符选中的描述的DPL</li>
</ul>
<p>如下图：<br><img src="/img/门权限检查.gif" alt="门权限检查"></p>
<p>对于JMP和CALL，对于门描述符的检查不同：</p>
<ul>
<li>JMP需要满足<code>MAX(CPL,RPL) &lt;= gate DPL &amp;&amp; target DPL == CPL</code></li>
<li>CALL需要满足<code>MAX(CPL,RPL) &lt;= gate DPL &amp;&amp; target DPL &lt;= CPL</code>，call可以访问优先级更高的段。</li>
</ul>
<p>这里需要注意gate DPL用于确定当前程序有没有权限访问这个门（例如该门只设计在内核下访问，那么用户态就无法访问），而target DPL确定能不能将控制权传递给目标代码段。</p>
<h4 id="任务段切换的保护"><a href="#任务段切换的保护" class="headerlink" title="任务段切换的保护"></a>任务段切换的保护</h4><p><strong>这一部分在任务切换时补充</strong></p>
<h4 id="被操作系统保留的指令"><a href="#被操作系统保留的指令" class="headerlink" title="被操作系统保留的指令"></a>被操作系统保留的指令</h4><p>有一些指令只能在特权及为0时使用，例如lgdt、lidt、ltr等等。还有一些敏感的指令例如IO指令，也只能在特权为0时访问，有关IO相关请看<a href="#">IO指令和常见硬件的访问</a></p>
<h3 id="分页保护"><a href="#分页保护" class="headerlink" title="分页保护"></a>分页保护</h3><p>分页提供两种类型的保护：</p>
<ol>
<li>内存访问的限制</li>
<li>类型检查</li>
</ol>
<h4 id="页表项中的保护位"><a href="#页表项中的保护位" class="headerlink" title="页表项中的保护位"></a>页表项中的保护位</h4><p>PDE和PTE中的页表项提供了了U/S和R/W位用来进行保护。</p>
<p>U/S=0表示管理员权限，为操作系统和其他的系统软件及相关的数据准备。U/S=1表示应用程序和数据。当CPL等于0、1、2时，认为处理器处于管理员执行模式；CPL=3时在用户态下。这意味着只有CPL=0、1、2时才能访问U/S=0的页（实际上能访问所有页），CPL=3时只能访问U/S=1的页。</p>
<p>通过R/W来进行类型检查，有两种类型：</p>
<ol>
<li>只读（R/W=0）</li>
<li>读写（R/W=1）</li>
</ol>
<p>当处理器处于管理员权限时，所有的页面都是可读的和可写的。在用户态下只有U/S=1并且R/W=1的页面可写。</p>
<p>当分页启用的时候，80386首先计算分段保护、然后处理分页保护。保护检查未通过时，将停止程序的执行并且触发一个保护异常。</p>
<p>可以创建一个很大的段，其中含有很多页，一些页是只读的，另一些页是可读可写的。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-19T01:31:58.000Z" title="2019-12-19T01:31:58.000Z">2019-12-19</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">17 minutes read (About 2617 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/19/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B06%EF%BC%9A%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E3%80%81IDT%E5%92%8CIDTR/">ucore-os笔记6：中断和异常、IDT和IDTR</a></h1><div class="content"><p>外部设备与CPU通信需要通过中断机制。例如，当按下键盘上的一个键的时候，必然要通知CPU该键被按下，一种方式是CPU一直监视键盘上有没有键按下，但是这种方式性能太低。另一种方式由设备主动通知CPU有事件发生，当键盘被按下时，键盘通知CPU有键被按下并且告知是哪一个键，这种方式就是中断方式。中断机制是系统具有响应式能力，也是进程/线程实现抢占式调度的一个重要基石（通过时钟中断）。</p>
<p>操作系统中有三种中断，分别是：</p>
<ul>
<li>外部设备引起的：IO中断、始终中断等异步产生的，与CPU的执行无关，简称为<code>中断</code></li>
<li>CPU运行中引起的：例如除0、缺页、地址越界等等，在CPU运行时CPU检测到的异常，称为<code>异常</code></li>
<li>用户调用引起的：例如系统调用，用户调用了INT指令，也是在CPU运行时检测到，称为<code>陷入</code></li>
</ul>
<p>上面的三种中断可以分为两大类，异步中断和同步中断。异步中断由外部事件产生，时间不确定。同步中断由CPU产生，可以是CPU执行时的异常，或者用户调用特定指定导致。</p>
<blockquote>
<p>中断还可以分为可屏蔽中断和不可屏蔽中断，可屏蔽中断由NMI引脚触发，不受EFLAGS寄存器中的IF影响。普通中断硬件由INTR引脚引起，可通过IF位屏蔽</p>
</blockquote>
<h2 id="中断处理过程"><a href="#中断处理过程" class="headerlink" title="中断处理过程"></a>中断处理过程</h2><p>当CPU检测到中断时，会中断当前指令的执行，调转到中断处理程序的位置执行。那如何直到中断处理程序在哪个位置呢？CPU使用IDTR和IDT和储存中断处理程序的地址。中断调用结束后会回到被中断的指令的位置继续执行，那如何直到中断前的指令的位置呢？通过堆栈来实现，CPU会自动将指令位置相关的寄存器cs、eip压入内核栈，中断结束后通过iret将栈中的数据恢复到寄存器中。</p>
<p>IDTR是中断描述符表寄存器，存了中断描述符（IDT）的起始地址和长度：<br><a href="/img/IDTR.png">IDTR</a></p>
<p>每一个中断有一个中断向量号，最多有256个中断向量号。中断向量号对应IDT中的表项，IDT是中断描述符表，里面最多有256个表项与中断向量号一一对应。寻找中断程序入口的步骤是，从IDTR找到起始地址，注意这里的起始地址就是线形地址，不需要在经过GDT转化；寻找计算对应的表项的地址，计算公式是base+interrupt number * 8，乘8是因为一个表项占8个字节。找到对应的表项之后，表项中存了中断程序的逻辑地址，就是段描述符+偏移；CPU将段描述符加载到段寄存器中，偏移加载到EIP中，然后就得到中断处理程序的线形地址，描述符表项结构：<br><a href="/img/IDT-entry.png">IDT表项</a></p>
<p>中断向量表的前32个是被CPU保留的，<code>[32,255]</code>是给用户使用的，所以ucore定义的中断都在32之后，包括IO设备中断、系统调用等等。cpu触发中断以后，会禁用中断（将EFLAGS寄存器中的IF位置0），中断处理程序中可以手动开启来实现中断嵌套，但是需要自行处理堆栈；陷入和异常不会禁用中断。</p>
<p>IDT中有三种描述符，在上图中有其格式，分别是：</p>
<ul>
<li>Task-gate descriptor</li>
<li>Interrupt-gate descriptor</li>
<li>Trap-gate descriptor</li>
</ul>
<h3 id="中断过程中硬件完成的工作"><a href="#中断过程中硬件完成的工作" class="headerlink" title="中断过程中硬件完成的工作"></a>中断过程中硬件完成的工作</h3><p>中断过程中的调转到中断程序和从中断程序都是硬件进行的：</p>
<ul>
<li>CPU在执行完每一条指令之后，都会检测中断请求，如果监测到中断请求，会从总线上读取对应的中断向量（对应计算机接口中的IO读周期）</li>
<li>用读取到的中断向量号来寻找中断向量的起始地址，通过IDT和IDTR找到描述符项</li>
<li>描述符项中有段描述符和偏移，利用它们找到GDT中的对应表项，取的中断服务程序的线形地址</li>
<li>CPU会根据CPL和中断处理程序的段描述符的DPL确定是否发生了特权级的转换。因为用户程序运行在用户态，而内核程序运行在内核态。中断会陷入内核态，如果是在用户态，则需要先切换到内核态。在用户态执行int指令，会通过TSS和TR可以取得内核栈地址，切换到内核栈然后将用户态的ss和esp压栈保存下来。如果是内核态陷入中断，则不需要这些处理，栈中也没有ss和esp</li>
<li>CPU会保存一些现场信息用于返回原程序执行，所以会压栈eflags、cs、eip、errorCode（有的中断有errorCode，有的中断没有，是CPU预置的）</li>
<li>CPU将cs、和eip切换到中断程序的地址，然后开始执行</li>
<li>执行完中断程序以后，通过iret指定恢复原有的程序。指定iret后，CPU会将eflags、cs、eip从栈中恢复到寄存器中，cpu不会自动弹出errorCode，需要手动弹出</li>
<li>如果是有特权级切换，不管是用户态还是内核态，都会弹出ss和esp。</li>
</ul>
<p>中断处理程序寻址过程：<br><a href="/img/idt表项寻址过程.png">中断处理程序寻址过程</a></p>
<p>堆栈变化：<br><a href="/img/堆栈变化.png">堆栈变化</a></p>
<p>这里需要注意堆栈变化，当有权限切换时，会压入/弹出SS和ESP，不管是从内核到用户态还是从用户态到内核态。例如，从内核触发中断的时候，没有发生切换，所以不会压栈SS和ESP，但是如果在中断程序中切换了CS到用户态的CS，那么从中断返回的时候，就会从堆栈中多弹出SS和ESP，写代码的时候要注意这一点（lab1挑战实验1）。<br><a href="/img/interrupt-stack.gif">堆栈变化1</a></p>
<h3 id="中断处理过程中的特权级转换"><a href="#中断处理过程中的特权级转换" class="headerlink" title="中断处理过程中的特权级转换"></a>中断处理过程中的特权级转换</h3><p>中断时CPU会进行特权级的检查。这个特权级的检查分成两个部分，一个是IDT中表项中的段描述符，段描述符中的DPL确定了所处段的特权级，<strong>只有段描述符的特权级高于或等于当前特权级时，检查通过</strong>；当触发中断和从中断程序返回都会检查，检查中断程序的段选择符和当前的CS，如果两者的DPL不相同，就发生特权级切换了，堆栈处理操作不同，看上一小节的堆栈图。</p>
<p>另一个是IDT表项中的DPL，如果是用户态程序触发的（例如INT n），还会检查表项中的DPL，只有当DPL更低时或相同时才通过检查，这就阻止了用户程序能够触发任意的中断，例如用户态为3，那么就只能触发DPL为3的中断。<strong>这里需要注意只有INT指令触发的中断，才会检查DPL，由硬件触发的中断不会检查DPL，所以硬件中断的代码即使位于内核段中，也能直接被调用；但是权限切换依然会被检查，如果当前是用户态执行触发了硬件中断，那么会压入ss和esp</strong></p>
<p>如果检查失败，CPU会触发一个保护异常。<br><a href="/img/idt-privilige-check.png">idt-privilige-check</a></p>
<h3 id="ucore-os对于中断的实现"><a href="#ucore-os对于中断的实现" class="headerlink" title="ucore-os对于中断的实现"></a>ucore-os对于中断的实现</h3><p>ucore-os的中断向量表定义在kern/trap/vector.S中，该文件由tools/vertor.c文件生成。vector.S文件的主要内容是定义了256个中断向量处理程序的入口，在中断时的有的会自动压入errorNumber，有的不会，vector.S中的不会自动压入errorNumber的会压入一个0，以统一结构。每一个程序再压栈errorNumber（如果CPU不会自动压栈的话）和压栈中断向量号后，同一调转到<code>__alltraps</code>执行：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">.globl __alltraps</span><br><span class="line">.globl vector0</span><br><span class="line">vector0:</span><br><span class="line">  pushl $0</span><br><span class="line">  pushl $0</span><br><span class="line">  jmp __alltraps</span><br></pre></td></tr></table></figure></p>
<p><strong>alltraps是另一个汇编文件trapentry.S中定义的全局符号，链接后会指向trapentry.S中的`</strong>alltraps`。trapentry.S的作用是构造trapframe的栈结构，并调用trap函数，trap函数返回后出栈trapframe的结构。因为涉及到特定寄存器的入栈出栈，这一部分代码用汇编语言描述最方便。</p>
<p>vector.S中定义了全局段全局符号<code>__vectors</code>，其值是一个数组的起始地址，数组的每一项是每一个入口程序的地址。因为符号<code>__vectors</code>是全局符号，所以可以在C程序中可以直接访问，因为链接后会加入到符号表中。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># vector table</span><br><span class="line">.data</span><br><span class="line">.globl __vectors</span><br><span class="line">__vectors:</span><br><span class="line">  .long vector0</span><br><span class="line">  .long vector1</span><br><span class="line">  .long vector2</span><br><span class="line">  .long vector3</span><br><span class="line">  .long vector4</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></p>
<p>再idt_init进行idt初始化的时候，要做的事情就是构造IDT表并填充表项。<code>__vectors</code>中已经有了中断处理函数的地址，只需要在设置DPL等等其他表项的内容，就能构造出来IDT表。最后将IDT表的地址使用lidt指令加载到IDTR寄存器中，我们就完成了中断向量表的初始化。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-03T03:20:50.000Z" title="2019-12-03T03:20:50.000Z">2019-12-03</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">33 minutes read (About 4944 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B04%EF%BC%9Abios%E5%92%8Cbootloader%E7%9A%84%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B/">ucore-os笔记4：bios和bootloader的启动过程</a></h1><div class="content"><p>这篇笔记学习BIOS和bootloader的执行过程，将详细分析机器加电后执行的第一条指令到操作系统的第一行代码中间经历的过程。</p>
<h2 id="BOIS的启动过程"><a href="#BOIS的启动过程" class="headerlink" title="BOIS的启动过程"></a>BOIS的启动过程</h2><p>计算机开机后并不是直接启动操作系统，而是先要执行一小部分初始化软件。在80386体系结构下由BIOS和BOOTLOADER组成。BOIS是存储在主板上ROM中的一个小程序，承担了最基础的输入输出功能（电脑没装系统时，我们也可以进入BOIS，BOIS中可以看到计算机的硬件信息，设置启动盘等等，其包括了对硬件最最基本的访问能力）。</p>
<p>计算机加电后，将BIOS加载内存中开始执行。会从一条特定的地址开始执行，该指令调转到BIOS程序的起始地址执行。BIOS会检测硬件并进行初始化，然后会选择一个启动设备。然后将该设备的第一个扇区（512字节）加载到内存的特定地址（0x7c00）。然后将控制权转交给0x7c00地址处的程序开始执行。</p>
<p>简单来说，当我们按下电脑的开机键后，CPU会进行如下的处理：</p>
<ol>
<li>BIOS被加载到内存中</li>
<li>CPU的第一条指令是调转到BIOS程序的第一条指令（1、2步都是硬件预先设计好的）</li>
<li>开始执行BIOS，BIOS会初始化显示器、检测计算机总线上连接的所有硬件；一切正常后将启动盘的第一个扇区（512个字节）加载到内存的0x7c00处，然后调转到0x7c00执行。所以我们的bootloader会放在磁盘的第一个扇区，大小小于512字节，BIOS执行完了就会执行bootloader的指令。</li>
<li>bootloader执行，切换执行模式，加载操作系统内核，将控制权交给操作系统。</li>
<li>操作系统初始化</li>
</ol>
<blockquote>
<p>BIOS初始化是硬件自动的。启动的时候，硬件会将BIOS映射到高位内存地址中，以保证向下兼容8086的启动模式。</p>
</blockquote>
<h2 id="bootloader的启动过程"><a href="#bootloader的启动过程" class="headerlink" title="bootloader的启动过程"></a>bootloader的启动过程</h2><p>BIOS读取硬件扇区到0x7c00的内存中，并调转到0x7c00执行。所以bootloader被放在0x7c00的位置开始执行。（<strong>所以在makefile中链接bootblock的时候，将代码段地址设置成0x7c00。目前不懂这里链接指定的地址有什么用？后面学会了回来该</strong>）</p>
<p>bootloader的主要工作是：</p>
<ul>
<li>切换到保护模式，启用分段机制</li>
<li>读取ELF执行文件格式ucore操作系统到内存中</li>
<li>显示字符串信息</li>
<li>把控制权交给ucore操作系统</li>
</ul>
<p>接下来我们详细分析下面两个部分：</p>
<ul>
<li>如何切换到保护模式？（如果不了解什么是保护模式，请先阅读<a href="#">实模式与保护模式</a>）</li>
<li>如何读取ELF执行文件格式？（如果不了解elf文件格式，请先阅读<a href="#">elf文件结构</a>）</li>
</ul>
<h3 id="如何从实模式切换到保护模式"><a href="#如何从实模式切换到保护模式" class="headerlink" title="如何从实模式切换到保护模式"></a>如何从实模式切换到保护模式</h3><p>从实模式切换到保护模式要经历两个步骤：</p>
<ol>
<li>开启a20 gate</li>
<li>启用80386的分段机制实现保护</li>
</ol>
<p>下面分别说明这两个部分：</p>
<ol>
<li>开启a20 gate<br>8086处理器是16位的，只能以实模式运行，最大只能访问1MB内存。但是通过segment:offset的形式，可以得到高于1MB的地址。在这种情况下，8086会将高于1MB的地址“回卷”（只取前20位，溢出的部分舍弃），变成低于1MB的地址。一些8086的软件用到了这样的特性。在80386中，最大内存是4GB，超过1MB就不会“回卷”了，这样就不向下兼容了。所以有了A20 gate（A0-A19是20根地址线），A20 gate默认是不启用的，这样实模式下就只能访问1MB的内存，<strong>保证向下兼容</strong>。</li>
</ol>
<p><strong>因为a20 gate只是控制第21根地址的开启和关闭</strong>。在80386下（大于1MB的内存），如果开启了a20 gate：</p>
<ul>
<li>实模式下就可以访问<code>ffff0+0ffff=10ffef=1088KB</code>的内存，超出的64KB也能访问；</li>
<li>保护模式下能够访问完整的4G内存</li>
</ul>
<p>如果没有开启a20 gate：</p>
<ul>
<li>实模式下只能访问1MB的内存</li>
<li>保护模式下，<strong>a20始终位0</strong>，那么只能访问奇数兆的内存0-1M，2-3M…</li>
</ul>
<p>计算机开机以后是以实模式运行，我们的操作系统是面向32位CPU设计的，所以在bootloader中要启用全部的32根地址线。从实模式切换到保护模式的第一步就是开启a20 gate。</p>
<p>a20 gate的开启和关闭使用<strong>通过键盘控制器8042来控制</strong>的（需要通过一种方式来控制a20的开启和关闭，工程师们为了<strong>节省硬件设计成本</strong>将其集成到了键盘控制器中，a20 gate和键盘没有关系），所以我们需要通过io指令向键盘控制器8042发出控制命令，启用a20。bootasm.S中相关代码如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">seta20.1:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.1</span><br><span class="line"></span><br><span class="line">    movb $0xd1, %al                                 # 0xd1 -&gt; port 0x64</span><br><span class="line">    outb %al, $0x64                                 # 0xd1 means: write data to 8042&#39;s P2 port</span><br><span class="line"></span><br><span class="line">seta20.2:</span><br><span class="line">    inb $0x64, %al                                  # Wait for not busy(8042 input buffer empty).</span><br><span class="line">    testb $0x2, %al</span><br><span class="line">    jnz seta20.2</span><br><span class="line"></span><br><span class="line">    movb $0xdf, %al                                 # 0xdf -&gt; port 0x60</span><br><span class="line">    outb %al, $0x60</span><br></pre></td></tr></table></figure><br><img src="/img/8042键盘控制器.png" alt="8042键盘控制器"><br>8042对外暴露了两个端口：0x60和0x64，下面是对8042的简单介绍：</p>
<ul>
<li>键盘控制器的端口是0x60-0x6f，但是只使用了0x60和0x64两个端口。通过这两个端口给键盘控制器发送命令或者读取状态</li>
<li><p>8042有两个寄存器，一个是状态寄存器，保存了控制器当前的状态信息（键盘使用启用，buffer中是否有数据等），另一个是控制寄存器。状态寄存器各位信息如下：<br>  | bit  | meaning  |<br>  |—|—|<br>  |0 |output    register    (60h)    中有数据|<br>  |1 |input    register    (60h/64h)    有数据|<br>  |2 |系统标志(上电复位后被置为0)|<br>  |3 |data    in    input    register    is    command    (1)    or    data    (0)|<br>  |4 |1=keyboard    enabled,    0=keyboard    disabled    (via    switch)|<br>  |5 |1=transmit    timeout    (data    transmit    not    complete|)<br>  |6 |1=receive    timeout    (data    transmit    not    complete)|<br>  |7 |1=even    parity    rec’d,    0=odd    parity    rec’d    (should    be    odd)|</p>
</li>
<li><p>0x64端口用于写入命令，读取状态信息。0x60用于写入和读取数据。在0x64端口状态信息；写0x64端口写入命令。</p>
</li>
<li>8042有两个内部端口（上图中有），这两个内部端口在内部电路中使用，程序员不可见，但是通过向0x64端口写入特定的命令可以改变这两个端口的数据。我们本次要改的a20控制就在内部输出端口的p21，这个信号控制a20的开启和关闭。</li>
</ul>
<p>设置键盘控制器的步骤是：</p>
<ol>
<li>等待8042的输入缓存为空。等待上一条IO命令结束，结束后会清空标识寄存器。因为CPU的速度远快于IO设备的速度，所以一定要加这个判断。</li>
<li>向0x64写入设置内部输出端口的命令</li>
<li>等待输入缓存为空</li>
<li>向0x60写入要设置的值</li>
</ol>
<p>在代码中，<code>inb $0x64,%al</code>和<code>testb 0x2,%al</code>用于判断键盘控制器的输入缓存是否为空。0x2=00000010，对照上面状态寄存器的第二位，1表示input register中有数据，当有数据时，重复，直到没有数据为止。</p>
<p>然后向0x64写入命令0xd1，表示写内部输出端口，然后写入0xdf(11011111)，将p21置高电平，其他的位可以不管，是键盘控制器细节相关的，我们这里只了解一下就可以了。</p>
<blockquote>
<p>计算机接口技术课程的相关知识：一个IO设备控制器一般会占用多个端口，分别是状态端口、数据端口、控制端口，一般都是通过控制端口输入控制字，控制字可以设置要对IO控制器进行的操作，如读取IO设备状态、向设备写入数据等等；控制寄存器用于写入IO设备控制器的操作命令，通过改变控制寄存器的相关位，就可以改变控制器的工作模式，例如从写数据切换到读数据。通过地址总线或者IO总线来寻址到特定设备端口，通过数据总线向控制器端口写入或者读取数据，通过控制总线发出一些特定的控制信号。一般来说IO操作的步骤是：</p>
<p>1.向IO设备控制器的控制端口写入控制字<br>2.根据控制字的设置向数据端口写入或者从数据端口读取数据</p>
<p>Intel 80386相关知识：通过out指令寻址的IO设备使用的是IO地址空间，该地址空间和内存地址空间独立。</p>
</blockquote>
<ol start="2">
<li>开启分段机制进入保护模式<blockquote>
<p>这里需要了解保护模式的知识（请学习<a href="#">GDT与保护模式</a>）</p>
</blockquote>
</li>
</ol>
<p>先看bootasm.S中的相关代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">    lgdt gdtdesc</span><br><span class="line">    movl %cr0, %eax</span><br><span class="line">    orl $CR0_PE_ON, %eax</span><br><span class="line">    movl %eax, %cr0</span><br><span class="line"></span><br><span class="line">    # Jump to next instruction, but in 32-bit code segment.</span><br><span class="line">    # Switches processor into 32-bit mode.</span><br><span class="line">    ljmp $PROT_MODE_CSEG, $protcseg</span><br><span class="line"></span><br><span class="line">.code32                                             # Assemble for 32-bit mode</span><br><span class="line">protcseg:</span><br><span class="line">    # Set up the protected-mode data segment registers</span><br><span class="line">    movw $PROT_MODE_DSEG, %ax                       # Our data segment selector</span><br><span class="line">    movw %ax, %ds                                   # -&gt; DS: Data Segment</span><br><span class="line">    movw %ax, %es                                   # -&gt; ES: Extra Segment</span><br><span class="line">    movw %ax, %fs                                   # -&gt; FS</span><br><span class="line">    movw %ax, %gs                                   # -&gt; GS</span><br><span class="line">    movw %ax, %ss                                   # -&gt; SS: Stack Segment</span><br></pre></td></tr></table></figure><br>80386及之后的CPU提供了保护模式，主要通过GDTR寄存器和GDT（全局描述符表）来实现。GDTR中存了GDT的入口地址。第一步我们将GDT的地址加载到GDTR寄存器中，使用<code>lgdt gdtdesc</code>从内存中加载GDT的大小和地址到GDTR寄存器中。注意这个时候cr0寄存器中的PE位没有打开，所以CPU还没有启用分段机制，所以此时的内存访问就不涉及到分段的问题。</p>
<p>接下来设置cr0中的PE位，开启了CPU的保护模式。这时候就要设置段寄存器的值了，因为接下来的内存访问就会从GDT中取找对应的段了。所以接下来通过ljmp设置CS寄存器的值，因为CS寄存器的值只能通过调转指令间接设置。然后通过mov指令设置其他段寄存器的值。这样我们就开启了CPU的保护模式。</p>
<h3 id="如何加载操作系统"><a href="#如何加载操作系统" class="headerlink" title="如何加载操作系统"></a>如何加载操作系统</h3><p>前面提到了操作系统的加载由bootloader来实现，bootloader是放在硬盘第一个扇区、大小小于512字节的一段程序，bootloader主要做了两部分的工作，一个是<code>从实模式切换到保护模式</code>，另一个是<code>加载操作系统到ram中并移交控制权</code>。前面我们讨论了如何从实模式切换到保护模式，这里如何加载操作系统。</p>
<p>要理解如何加载操作系统，需要直到两方面的知识，第一个是操作系统的格式细节，这里我们使用的操作系统是ELF格式；另一个如何访问硬盘。下面我们先分别介绍这两方面的知识，因为只有直到ELF文件的格式之后，才能直到如何去读取操作系统并运行。</p>
<h4 id="ELF文件格式介绍"><a href="#ELF文件格式介绍" class="headerlink" title="ELF文件格式介绍"></a>ELF文件格式介绍</h4><p>ELF(Executable    and    linking    format)文件格式是Linux系统下的一种常用目标文件(object file)格<br>式，有三种主要类型:</p>
<ul>
<li>用于执行的可执行文件(executable file),用于提供程序的进程映像,加载的内存执行。<br>这也是本实验的OS文件类型。</li>
<li>用于连接的可重定位文件(relocatable file),可与其它目标文件一起创建可执行文件和共<br>享目标文件。</li>
<li>共享目标文件(shared object file),连接器可将它与其它可重定位文件和共享目标文件连接<br>成其它的目标文件,动态连接器又可将它与可执行文件和其它共享目标文件结合起来创<br>建一个进程映像。</li>
</ul>
<blockquote>
<p>参考资料：<img src="http://www.skyfree.org/linux/references/ELF_Format.pdf" alt="ELF_format"><br>这里只介绍第一种，也就是可执行文件的格式。</p>
</blockquote>
<p><a href="/img/elf-overview.png">elf-overview</a></p>
<p>可以看到ELF文件最开始的部分是ELF header，header包含了elf文件的所有信息，包括程序的每一部分大小、位置等等。对于可执行文件，其次最重要的就是<code>program header table(pht)</code>，pht包含了如何创建一个进程映像的信息，可执行文件必须含有pht。pht并不一定就紧跟在header后面，除了elf header以外的其他部分的顺序是不确定的。</p>
<h5 id="ELF-header"><a href="#ELF-header" class="headerlink" title="ELF header"></a>ELF header</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">elfhdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_magic;     <span class="comment">// must equal ELF_MAGIC</span></span><br><span class="line">    <span class="keyword">uint8_t</span> e_elf[<span class="number">12</span>];</span><br><span class="line">    <span class="keyword">uint16_t</span> e_type;      <span class="comment">// 1=relocatable, 2=executable, 3=shared object, 4=core image</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_machine;   <span class="comment">// 3=x86, 4=68K, etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_version;   <span class="comment">// file version, always 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_entry;     <span class="comment">// entry point if executable</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_phoff;     <span class="comment">// file position of program header or 0，程序头表在文件中的字节偏移。</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_shoff;     <span class="comment">// file position of section header or 0</span></span><br><span class="line">    <span class="keyword">uint32_t</span> e_flags;     <span class="comment">// architecture-specific flags, usually 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_ehsize;    <span class="comment">// size of this elf header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phentsize; <span class="comment">// size of an entry in program header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_phnum;     <span class="comment">// number of entries in program header or 0，程序头表的项数。</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shentsize; <span class="comment">// size of an entry in section header</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shnum;     <span class="comment">// number of entries in section header or 0</span></span><br><span class="line">    <span class="keyword">uint16_t</span> e_shstrndx;  <span class="comment">// section number that contains section name strings</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>elf header的前16个字节用于标识一个elf文件，前四个字节是magic number，表示这个文件是一个elf文件，后面的12个字节表示elf文件类别，平台等等，这里没有用到，所以我们用<code>uchar elf[12]</code>表示了。其他重要的有entry——程序入口的虚拟地址、program header和phnum。</p>
<p>对于可执行文件其次最重要的是program header，program header是一个特定结构的数组，数组中的每一个元素代表一个section。结构如下：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> &#123;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_type;   <span class="comment">// loadable code or data, dynamic linking info,etc.</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_offset; <span class="comment">// file offset of segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_va;     <span class="comment">// virtual address to map segment</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_pa;     <span class="comment">// physical address, not used</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_filesz; <span class="comment">// size of segment in file</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_memsz;  <span class="comment">// size of segment in memory (bigger if contains bss）</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_flags;  <span class="comment">// read/write/execute bits</span></span><br><span class="line">    <span class="keyword">uint32_t</span> p_align;  <span class="comment">// required alignment, invariably hardware page size</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>包含section的偏移，虚拟地址、物理地址、大小等等信息。ucore-os的加载将会利用这些信息，将每一个段加载到指定的内存地址中。</p>
<blockquote>
<p>elf其他格式的解析，会结合操作系统程序的链接、加载一起学习，请看<a href="#">操作系统程序的链接、加载</a></p>
</blockquote>
<h4 id="硬盘访问概述"><a href="#硬盘访问概述" class="headerlink" title="硬盘访问概述"></a>硬盘访问概述</h4><p>当前硬盘数据是储存到硬盘扇区中,一个扇区大小为512字节。读一个扇区的流程(可参看<br>boot/bootmain.c中的readsect函数实现)大致如下:</p>
<ol>
<li>等待磁盘准备好</li>
<li>发出读取扇区的命令</li>
<li>等待磁盘准备好</li>
<li>把磁盘扇区数据读到指定内存</li>
</ol>
<p>硬盘访问的具体细节，我们在其他的文章中学习，因为涉及到计算机接口、计算机组成原理等的知识，请看<a href="#">x86下的IO访问详解</a></p>
<h4 id="操作系统加载"><a href="#操作系统加载" class="headerlink" title="操作系统加载"></a>操作系统加载</h4><p>前面我们了解了基础知识，接下来分析操作系统的加载过程，首先分析代码中：<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">void</span></span><br><span class="line">readseg(<span class="keyword">uintptr_t</span> va, <span class="keyword">uint32_t</span> count, <span class="keyword">uint32_t</span> offset) &#123;</span><br><span class="line">    <span class="keyword">uintptr_t</span> end_va = va + count;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// round down to sector boundary</span></span><br><span class="line">    va -= offset % SECTSIZE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// translate from bytes to sectors; kernel starts at sector 1</span></span><br><span class="line">    <span class="keyword">uint32_t</span> secno = (offset / SECTSIZE) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If this is too slow, we could read lots of sectors at a time.</span></span><br><span class="line">    <span class="comment">// We'd write more to memory than asked, but it doesn't matter --</span></span><br><span class="line">    <span class="comment">// we load in increasing order.</span></span><br><span class="line">    <span class="keyword">for</span> (; va &lt; end_va; va += SECTSIZE, secno ++) &#123;</span><br><span class="line">        readsect((<span class="keyword">void</span> *)va, secno);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// read the 1st page off disk</span></span><br><span class="line"><span class="comment">// 读取磁盘的第一页到内存中的ELFHRD（0x10000）位置，1页是4K，8个扇区。</span></span><br><span class="line"><span class="comment">// ELF可执行文件的ELF头在最开始的位置，这里将头读出来，然后根据头中的信息去读程序信息</span></span><br><span class="line">readseg((<span class="keyword">uintptr_t</span>)ELFHDR, SECTSIZE * <span class="number">8</span>, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// is this a valid ELF?</span></span><br><span class="line"><span class="keyword">if</span> (ELFHDR-&gt;e_magic != ELF_MAGIC) &#123;</span><br><span class="line">    <span class="keyword">goto</span> bad;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">proghdr</span> *<span class="title">ph</span>, *<span class="title">eph</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// load each program segment (ignores ph flags)</span></span><br><span class="line"><span class="comment">// ph是程序头段的开始地址</span></span><br><span class="line">ph = (struct proghdr *)((<span class="keyword">uintptr_t</span>)ELFHDR + ELFHDR-&gt;e_phoff);</span><br><span class="line"><span class="comment">// eph是程序头段的结束地址（指针+数字的值是：指针值+数据类型大小*数字）</span></span><br><span class="line">eph = ph + ELFHDR-&gt;e_phnum;</span><br><span class="line"><span class="keyword">for</span> (; ph &lt; eph; ph ++) &#123;</span><br><span class="line">    <span class="comment">// 这里p_offset按照扇区对齐去读</span></span><br><span class="line">    readseg(ph-&gt;p_va &amp; <span class="number">0xFFFFFF</span>, ph-&gt;p_memsz, ph-&gt;p_offset);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// call the entry point from the ELF header</span></span><br><span class="line"><span class="comment">// note: does not return</span></span><br><span class="line"><span class="comment">// 将ELF文件读入之后，到elf程序的开始地址执行</span></span><br><span class="line">((<span class="keyword">void</span> (*)(<span class="keyword">void</span>))(ELFHDR-&gt;e_entry &amp; <span class="number">0xFFFFFF</span>))();</span><br></pre></td></tr></table></figure><br>最开始直接将硬盘的第一页读取到设定的内核起始位置0x10000，注意这个是从第二个扇区开始读，因为第一个扇区是bootloader，所以有<code>offset / SECSIZE + 1</code>。读取的第一页中可能也包含了其他的段，但是这里我们只关心elf header，其他的段后段会再读，读的时候可能会覆盖本次读的段，这些都没有问题。事实上我们也可以按照扇区大小和header的大小向上取整读若干个扇区，但是这里为了方便就直接读一页了。</p>
<p>硬盘读取是一次读取一个扇区，所以我们的硬盘访问分为两个方面：</p>
<p>第一个是按照段来解析，从program header中读取每一个段的虚拟地址、大小和偏移，虚拟地址是加载到内存中的地址，虚拟地址+大小就能确定这个段的范围；这里要注意偏移是指段在文件中的偏移位置，不一定按照扇区对齐了，而读取硬盘却是按照一个一个扇区读取的，所以我们要按照扇区来对齐进行读取，<code>offset / SECSIZE + 1</code>就是扇区号（从1开始，因为0是bootloader），而且这里将硬盘中的内容加载到<strong>连续的内存中</strong>，offset向下取整了，所以其映射到内存位置也要向下调整，所以有<code>va -= offset % SECSIZE</code>。</p>
<p>第二个是按照扇区来读，前面我们已经得到了段的范围和偏移，由偏移可以确定起始扇区，范围可以确定扇区的个数。先按照扇区对齐，然后逐个读入扇区到内存中，就将对应的段加载到了内存中。</p>
<p>最后调用<code>((void (*)(void))(ELFHDR-&gt;e_entry &amp; 0xFFFFFF))()</code>，将入口地址作为一个没有返回值没有参数的函数指针调用，就将控制权交给了操作系统，后面执行的就是操作系统内核代码了。</p>
</div></article></div><div class="card"><article class="card-content article" role="article"><div class="article-meta size-small is-uppercase level is-mobile"><div class="level-left"><time class="level-item" dateTime="2019-12-03T01:41:03.000Z" title="2019-12-03T01:41:03.000Z">2019-12-03</time><span class="level-item"><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">操作系统</a><span> / </span><a class="link-muted" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/">ucore</a></span><span class="level-item">9 minutes read (About 1395 words)</span></div></div><h1 class="title is-3 is-size-4-mobile"><a class="link-muted" href="/2019/12/03/os/ucore_os/ucore-os%E7%AC%94%E8%AE%B03%EF%BC%9Aqemu%E5%92%8Cgdb%E8%B0%83%E8%AF%95/">ucore-os笔记4：qemu和gdb调试</a></h1><div class="content"><p>本篇笔记我们学习qemu和gdb调试，这是调试操作系统内核代码必备的技能。</p>
<p>qemu是通用开源的硬件模拟器，可以模拟完整计算机系统，包括多种CPU架构（x86、x86_61、MIPS、ARM等）、系统总线（PCI、ISA桥等）、VGA显示、PS/2键鼠、PCI和ISA网络适配器、串行端口、USB。这里我们不详细讨论所有的相关知识，只学习我们目前使用到的这一部分。</p>
<p>gdb是gnu调试工具，可以调试编译后的程序。我们在编译操作系统时，要使用GCC的-g选项生成调试信息才能使用gdb调试。gdb提供了单步调试，指令单步调试，调用栈显示等等功能。</p>
<h2 id="qemu基础知识"><a href="#qemu基础知识" class="headerlink" title="qemu基础知识"></a>qemu基础知识</h2><p>通过qemu命令就可以启动qemu模拟器，通过qemu命令的参数可以指令模拟的硬件的参数，例如指定硬盘、串行端口、CPU核心数等等。一个基础示例如下：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;</span><br></pre></td></tr></table></figure><br>该命令会启动一个PC系统模拟器，并指定了其并行端口、串行端口、和硬盘镜像。模拟器会模拟一台计算机的启动过程，从硬盘镜像中加载BIOS和bootloader，然后将控制权交给bootloader。</p>
<p>部分命令行参数说明：</p>
<ul>
<li>-no-reboot：退出不重启</li>
<li>-parallel stdio：将模拟器的并行端口重定向为stdio。stdio是unix系统下的标准输入输出，标准输入一般指键盘输入，标准输出和程序执行的进程相关，从shell启动的程序输出到控制台</li>
<li>-hda bin/ucore.img：将bin/ucore.img作为磁盘0的硬盘镜像。模拟PC启动的时候会从该镜像加载bootloader和操作系统</li>
<li>-serial null：将模拟器的串行端口重新向为null</li>
<li>-monitor stdio：将显示器重定向到stdio</li>
<li>-S：启动时不启动CPU，必须需要输入’c’才能让qemu继续工作</li>
<li>-s：-gdb::1234的缩写，等待连接到端口1234。通过-s选项启动远程调试功能，gdb连接到1234端口就可以实现gdb调试qemu中执行的操作系统。</li>
</ul>
<h2 id="gdb基础知识"><a href="#gdb基础知识" class="headerlink" title="gdb基础知识"></a>gdb基础知识</h2><p>gdb是gnu调试器，通过gdb可以调试gcc通过-g选项生成的可执行文件。</p>
<p>gdb的使用很简单，在命令行输入gdb即可进入gdb命令行。-q表示不输出copyright信息。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[bright@localhost ~]$ gdb -q</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><br>在gdb命令行中输入help，可查看可使用的gdb命令：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">(gdb) help</span><br><span class="line">List of classes of commands:</span><br><span class="line"></span><br><span class="line">aliases -- Aliases of other commands</span><br><span class="line">breakpoints -- Making program stop at certain points</span><br><span class="line">data -- Examining data</span><br><span class="line">files -- Specifying and examining files</span><br><span class="line">internals -- Maintenance commands</span><br><span class="line">obscure -- Obscure features</span><br><span class="line">running -- Running the program</span><br><span class="line">stack -- Examining the stack</span><br><span class="line">status -- Status inquiries</span><br><span class="line">support -- Support facilities</span><br><span class="line">tracepoints -- Tracing of program execution without stopping the program</span><br><span class="line">user-defined -- User-defined commands</span><br><span class="line"></span><br><span class="line">Type "help" followed by a class name for a list of commands in that class.</span><br><span class="line">Type "help all" for the list of all commands.</span><br><span class="line">Type "help" followed by command name for full documentation.</span><br><span class="line">Type "apropos word" to search for commands related to "word".</span><br><span class="line">Command name abbreviations are allowed if unambiguous.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><br>我们看到通过gdb可以设置断点、查看数据、指定文件、查看堆栈、调试源程序等等。当我们要使用某一个功能时，可以通过help来查看，例如我想看调试相关的命令，输入<code>help running</code>，就会有很多调试相关的命令。要锻炼自己看工具说明文档的能力，授人以鱼不如授人以渔。</p>
<p>下面是一些常用命令的总结：</p>
<ul>
<li>run：启动调试程序</li>
<li>break breakpoint：打断点，breakpoint可以是地址或者符号名或者文件名加行号</li>
<li>continue：执行到下一个断点</li>
<li>next：执行下一条语句，调过函数。这个是C代码级的调试，调试汇编的使用需要使用nexti或者stepi。（例如调试bootloader的时候就要用nexti或者stepi）</li>
<li>nexti：执行下一条指令</li>
<li>step：执行下一条语句，进入函数。</li>
<li>stepi</li>
<li>file filename：加载filename文件中的调试信息。这一个指令在执行远程调试的时候必须有，因为远程调试不会加载调试的符号表，需要手动加载。</li>
<li>target remote address：远程调试address，利用这个功能来调试qemu中的操作系统。</li>
</ul>
<h2 id="qemu和gdb实现操作系统源码级调试"><a href="#qemu和gdb实现操作系统源码级调试" class="headerlink" title="qemu和gdb实现操作系统源码级调试"></a>qemu和gdb实现操作系统源码级调试</h2><p>实现源码级调试我们要用到上面提供的两个功能，一个是开启qemu的远程调试端口，另一个是用gdb远程连接qemu的调试端口。</p>
<p>所以我们要做的是，在启动qemu的时候通过-s选项启动:1234端口，通过-S暂停执行（等待gdb连接后在继续执行）:<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu -S -s -parallel stdio -hda bin/ucore.img -serial null &amp;</span><br></pre></td></tr></table></figure></p>
<p>然后在gdb中加载符号表、远程连接、设置断点等：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">file bin&#x2F;kernel</span><br><span class="line">target remote :1234</span><br><span class="line">break *0x7c00</span><br><span class="line">continue</span><br></pre></td></tr></table></figure></p>
<p>接下来我们在gdb中就可以输入调试命令来调试操作系统内核了。有下面两点要注意：</p>
<ul>
<li>如果是调试bootloader，可以切换到8086调试实模式代码：<code>set arch i8086</code></li>
<li>调试汇编代码要使用stepi或者nexti</li>
</ul>
</div></article></div><nav class="pagination is-centered mt-4" role="navigation" aria-label="pagination"><div class="pagination-previous is-invisible is-hidden-mobile"><a href="/tags/ucore/page/0/">Previous</a></div><div class="pagination-next"><a href="/tags/ucore/page/2/">Next</a></div><ul class="pagination-list is-hidden-mobile"><li><a class="pagination-link is-current" href="/tags/ucore/">1</a></li><li><a class="pagination-link" href="/tags/ucore/page/2/">2</a></li></ul></nav></div><div class="column column-left is-4-tablet is-4-desktop is-3-widescreen  order-1"><div class="card widget"><div class="card-content"><nav class="level"><div class="level-item has-text-centered flex-shrink-1"><div><figure class="image is-128x128 mx-auto mb-2"><img class="avatar" src="/img/avatar.png" alt="Bright Wu"></figure><p class="title is-size-4 is-block line-height-inherit">Bright Wu</p><p class="is-size-6 is-block">working harder to be better</p><p class="is-size-6 is-flex justify-content-center"><i class="fas fa-map-marker-alt mr-1"></i><span>Beijing Chaoyang</span></p></div></div></nav><nav class="level is-mobile"><div class="level-item has-text-centered is-marginless"><div><p class="heading">Posts</p><a href="/archives"><p class="title">154</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Categories</p><a href="/categories"><p class="title">84</p></a></div></div><div class="level-item has-text-centered is-marginless"><div><p class="heading">Tags</p><a href="/tags"><p class="title">115</p></a></div></div></nav><div class="level"><a class="level-item button is-primary is-rounded" href="https://github.com/wre232114" target="_blank" rel="noopener">Follow</a></div><div class="level is-mobile"><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Github" href="https://github.com/wre232114"><i class="fab fa-github"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Facebook" href="https://facebook.com"><i class="fab fa-facebook"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Twitter" href="https://twitter.com"><i class="fab fa-twitter"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="Dribbble" href="https://dribbble.com"><i class="fab fa-dribbble"></i></a><a class="level-item button is-transparent is-marginless" target="_blank" rel="noopener" title="RSS" href="/"><i class="fas fa-rss"></i></a></div></div></div><!--!--><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Links</h3><ul class="menu-list"><li><a class="level is-mobile is-mobile" href="https://hexo.io" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Hexo</span></span><span class="level-right"><span class="level-item tag">hexo.io</span></span></a></li><li><a class="level is-mobile is-mobile" href="https://brightblog.cn" target="_blank" rel="noopener"><span class="level-left"><span class="level-item">Bulma</span></span><span class="level-right"><span class="level-item tag">brightblog.cn</span></span></a></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Categories</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/categories/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Java/spring%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">spring实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/"><span class="level-start"><span class="level-item">Open Source</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Open-Source/Huaxu/"><span class="level-start"><span class="level-item">Huaxu</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/"><span class="level-start"><span class="level-item">Webpack</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">Webpack基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">Webpack实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/css/"><span class="level-start"><span class="level-item">css</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">css基础</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/css%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">css工具</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/less/"><span class="level-start"><span class="level-item">less</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/css/sass/"><span class="level-start"><span class="level-item">sass</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/docker/"><span class="level-start"><span class="level-item">docker</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/docker/docker-swarm/"><span class="level-start"><span class="level-item">docker swarm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/docker/docker%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">docker基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/git/"><span class="level-start"><span class="level-item">git</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/hexo/"><span class="level-start"><span class="level-item">hexo</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/"><span class="level-start"><span class="level-item">html5</span></span><span class="level-end"><span class="level-item tag">8</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/html5/dom/"><span class="level-start"><span class="level-item">dom</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5-API/"><span class="level-start"><span class="level-item">html5 API</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="level-start"><span class="level-item">html5标签和属性</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/svg/"><span class="level-start"><span class="level-item">svg</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/html5/%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">实战</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/js/"><span class="level-start"><span class="level-item">js</span></span><span class="level-end"><span class="level-item tag">6</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/js/js%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">js基础</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/js/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="level-start"><span class="level-item">正则表达式</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/linux/"><span class="level-start"><span class="level-item">linux</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/linux/%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/nginx/"><span class="level-start"><span class="level-item">nginx</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/"><span class="level-start"><span class="level-item">node.js</span></span><span class="level-end"><span class="level-item tag">2</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/node-js/npm/"><span class="level-start"><span class="level-item">npm</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/node-js/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">命令行工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/php/"><span class="level-start"><span class="level-item">php</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/"><span class="level-start"><span class="level-item">spring-boot</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/spring-boot/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="level-start"><span class="level-item">开发工具</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/typescript/"><span class="level-start"><span class="level-item">typescript</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/typescript/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="level-start"><span class="level-item">踩坑指南</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/vue/"><span class="level-start"><span class="level-item">vue</span></span><span class="level-end"><span class="level-item tag">11</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/vue/cli/"><span class="level-start"><span class="level-item">cli</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/tips/"><span class="level-start"><span class="level-item">tips</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue-router/"><span class="level-start"><span class="level-item">vue-router</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E5%AE%9E%E6%88%98/"><span class="level-start"><span class="level-item">vue实战</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="level-start"><span class="level-item">vue组件开发</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/vue/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/xml/"><span class="level-start"><span class="level-item">xml</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/xml/%E5%9F%BA%E7%A1%80/"><span class="level-start"><span class="level-item">基础</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AD%A6%E4%B9%A0%E6%89%93%E5%8D%A1/"><span class="level-start"><span class="level-item">学习打卡</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/"><span class="level-start"><span class="level-item">安全</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E5%AE%89%E5%85%A8/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="level-start"><span class="level-item">密码技术</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="level-start"><span class="level-item">操作系统</span></span><span class="level-end"><span class="level-item tag">23</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/shell/"><span class="level-start"><span class="level-item">shell</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/ucore/"><span class="level-start"><span class="level-item">ucore</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="level-start"><span class="level-item">操作系统原理</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="level-start"><span class="level-item">数据库</span></span><span class="level-end"><span class="level-item tag">10</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/mysql/"><span class="level-start"><span class="level-item">mysql</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/sql%E8%AF%AD%E5%8F%A5/"><span class="level-start"><span class="level-item">sql语句</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E5%AF%BC%E8%AE%BA/"><span class="level-start"><span class="level-item">导论</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="level-start"><span class="level-item">数据库编程</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E5%BA%93/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="level-start"><span class="level-item">数据库设计</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="level-start"><span class="level-item">数据结构</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/%E5%9B%BE/"><span class="level-start"><span class="level-item">图</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="level-start"><span class="level-item">树莓派</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E6%AF%95%E8%AE%BE/"><span class="level-start"><span class="level-item">毕设</span></span><span class="level-end"><span class="level-item tag">5</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/"><span class="level-start"><span class="level-item">算法</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/leetcode/"><span class="level-start"><span class="level-item">leetcode</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="level-start"><span class="level-item">模式匹配</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%AE%97%E6%B3%95/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="level-start"><span class="level-item">深度优先搜索</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">编程语言</span></span><span class="level-end"><span class="level-item tag">20</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/"><span class="level-start"><span class="level-item">C</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C/%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">语言</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/C%E8%AF%AD%E8%A8%80/"><span class="level-start"><span class="level-item">C语言</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/Java/"><span class="level-start"><span class="level-item">Java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/java/"><span class="level-start"><span class="level-item">java</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/"><span class="level-start"><span class="level-item">英语</span></span><span class="level-end"><span class="level-item tag">1</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%8B%B1%E8%AF%AD/%E7%94%9F%E8%AF%8D/"><span class="level-start"><span class="level-item">生词</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="level-start"><span class="level-item">计算机网络</span></span><span class="level-end"><span class="level-item tag">3</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/wireshark/"><span class="level-start"><span class="level-item">wireshark</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="level-start"><span class="level-item">问题记录</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li></ul></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">设计模式</span></span><span class="level-end"><span class="level-item tag">5</span></span></a><ul class="mr-0"><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="level-start"><span class="level-item">交给子类</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="level-start"><span class="level-item">生成实例</span></span><span class="level-end"><span class="level-item tag">1</span></span></a></li><li><a class="level is-mobile is-marginless" href="/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="level-start"><span class="level-item">适应设计模式</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></li></ul></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Archives</h3><ul class="menu-list"><li><a class="level is-mobile is-marginless" href="/archives/2020/06/"><span class="level-start"><span class="level-item">June 2020</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/05/"><span class="level-start"><span class="level-item">May 2020</span></span><span class="level-end"><span class="level-item tag">10</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/03/"><span class="level-start"><span class="level-item">March 2020</span></span><span class="level-end"><span class="level-item tag">4</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/02/"><span class="level-start"><span class="level-item">February 2020</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2020/01/"><span class="level-start"><span class="level-item">January 2020</span></span><span class="level-end"><span class="level-item tag">3</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/12/"><span class="level-start"><span class="level-item">December 2019</span></span><span class="level-end"><span class="level-item tag">16</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/11/"><span class="level-start"><span class="level-item">November 2019</span></span><span class="level-end"><span class="level-item tag">29</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/10/"><span class="level-start"><span class="level-item">October 2019</span></span><span class="level-end"><span class="level-item tag">8</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/09/"><span class="level-start"><span class="level-item">September 2019</span></span><span class="level-end"><span class="level-item tag">9</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/08/"><span class="level-start"><span class="level-item">August 2019</span></span><span class="level-end"><span class="level-item tag">12</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/07/"><span class="level-start"><span class="level-item">July 2019</span></span><span class="level-end"><span class="level-item tag">17</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/06/"><span class="level-start"><span class="level-item">June 2019</span></span><span class="level-end"><span class="level-item tag">18</span></span></a></li><li><a class="level is-mobile is-marginless" href="/archives/2019/05/"><span class="level-start"><span class="level-item">May 2019</span></span><span class="level-end"><span class="level-item tag">2</span></span></a></li></ul></div></div></div><div class="column-right-shadow is-hidden-widescreen"></div></div><div class="column column-right is-4-tablet is-4-desktop is-3-widescreen is-hidden-touch is-hidden-desktop-only order-3"><div class="card widget"><div class="card-content"><h3 class="menu-label">Recent</h3><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-27T13:07:22.000Z">2020-06-27</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/27/%E6%A0%91%E8%8E%93%E6%B4%BE/%E6%A0%91%E8%8E%93%E6%B4%BE3-5%E5%AF%B8%E6%98%BE%E7%A4%BA%E5%99%A8%E5%A5%97%E8%A3%85%E5%AE%89%E8%A3%85%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">树莓派3.5寸显示器套装安装操作系统</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/%E6%A0%91%E8%8E%93%E6%B4%BE/">树莓派</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:21:47.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/opensource/%E8%B7%A8%E6%A1%86%E6%9E%B6%E3%80%81%E8%87%AA%E5%AE%9A%E4%B9%89%E4%B8%BB%E9%A2%98%E7%9A%84%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%E7%B3%BB%E7%BB%9F%E5%8E%9F%E5%9E%8B%E6%A6%82%E8%A7%88/">跨框架、自定义主题的静态博客系统原型概览</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Open-Source/">Open Source</a> / <a class="link-muted" href="/categories/Open-Source/Huaxu/">Huaxu</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-15T00:18:37.000Z">2020-06-15</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/15/webpack/webpack%E5%AE%9E%E6%88%98%EF%BC%9A%E6%89%93%E9%80%A0%E5%90%8C%E6%97%B6%E7%BC%96%E8%AF%91react%E5%92%8Cvue%E7%9A%84%E6%9E%84%E5%BB%BA%E5%BC%95%E6%93%8E/">webpack实战：打造同时编译react和vue的构建引擎</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/Webpack/">Webpack</a> / <a class="link-muted" href="/categories/Webpack/Webpack%E5%AE%9E%E6%88%98/">Webpack实战</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.142Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/php/Smarty%E5%BF%AB%E9%80%9F%E5%85%A5%E9%97%A8/">Smarty块度入门</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/php/">php</a></p></div></article><article class="media"><div class="media-content size-small"><p><time dateTime="2020-06-14T03:08:34.122Z">2020-06-14</time></p><p class="title is-6"><a class="link-muted" href="/2020/06/14/git/%E5%9C%A8centos%E4%B8%8A%E6%90%AD%E5%BB%BAgit%E6%9C%8D%E5%8A%A1%E5%99%A8%E4%BB%93%E5%BA%93/">在centos上搭建git服务器仓库</a></p><p class="is-uppercase"><a class="link-muted" href="/categories/git/">git</a></p></div></article></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Tags</h3><div class="field is-grouped is-grouped-multiline"><div class="control"><a class="tags has-addons" href="/tags/Adapter%E6%A8%A1%E5%BC%8F/"><span class="tag">Adapter模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/C%E8%AF%AD%E8%A8%80/"><span class="tag">C语言</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/GCC/"><span class="tag">GCC</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Huaxu/"><span class="tag">Huaxu</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Iterator%E6%A8%A1%E5%BC%8F/"><span class="tag">Iterator模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Java/"><span class="tag">Java</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Linux%E5%91%BD%E4%BB%A4%E8%A1%8C%E4%B8%8Eshell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B/"><span class="tag">Linux命令行与shell脚本编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Maven/"><span class="tag">Maven</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Open-Source/"><span class="tag">Open Source</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/String/"><span class="tag">String</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Template-Method%E6%A8%A1%E5%BC%8F/"><span class="tag">Template Method模式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack/"><span class="tag">Webpack</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%9F%BA%E7%A1%80/"><span class="tag">Webpack基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/Webpack%E5%AE%9E%E6%88%98/"><span class="tag">Webpack实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/autoprefixer/"><span class="tag">autoprefixer</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/browserslist/"><span class="tag">browserslist</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/centos7%E5%B7%A5%E5%85%B7/"><span class="tag">centos7工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css/"><span class="tag">css</span><span class="tag is-grey-lightest">7</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%8D%95%E4%BD%8D/"><span class="tag">css单位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%9F%BA%E7%A1%80/"><span class="tag">css基础</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B7%A5%E5%85%B7/"><span class="tag">css工具</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/css%E5%B8%83%E5%B1%80/"><span class="tag">css布局</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker/"><span class="tag">docker</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker-swarm/"><span class="tag">docker swarm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/docker%E5%9F%BA%E7%A1%80/"><span class="tag">docker基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom/"><span class="tag">dom</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/dom%E5%9F%BA%E7%A1%80/"><span class="tag">dom基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/git/"><span class="tag">git</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/hexo/"><span class="tag">hexo</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html-Permission-API/"><span class="tag">html Permission API</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5/"><span class="tag">html5</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5-API/"><span class="tag">html5 API</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/html5%E6%A0%87%E7%AD%BE%E5%92%8C%E5%B1%9E%E6%80%A7/"><span class="tag">html5标签和属性</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js/"><span class="tag">js</span><span class="tag is-grey-lightest">6</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%9F%BA%E7%A1%80/"><span class="tag">js基础</span><span class="tag is-grey-lightest">4</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1/"><span class="tag">js对象</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E5%AF%B9%E8%B1%A1%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"><span class="tag">js对象类型判断</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/js%E6%95%B0%E7%BB%84/"><span class="tag">js数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/leetcode/"><span class="tag">leetcode</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/less/"><span class="tag">less</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E5%91%BD%E4%BB%A4/"><span class="tag">linux命令</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/linux%E8%BF%9C%E7%A8%8B%E8%BF%9E%E6%8E%A5/"><span class="tag">linux远程连接</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/mysql/"><span class="tag">mysql</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/nginx/"><span class="tag">nginx</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/node-js/"><span class="tag">node.js</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/npm/"><span class="tag">npm</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/postcss/"><span class="tag">postcss</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring/"><span class="tag">spring</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring-boot/"><span class="tag">spring-boot</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/spring%E5%AE%9E%E6%88%98/"><span class="tag">spring实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/sql%E8%AF%AD%E5%8F%A5/"><span class="tag">sql语句</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ssh/"><span class="tag">ssh</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg/"><span class="tag">svg</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%9F%BA%E7%A1%80/"><span class="tag">svg基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/svg%E5%AE%9A%E4%BD%8D/"><span class="tag">svg定位</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tips/"><span class="tag">tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/tslint%E5%9F%BA%E7%A1%80/"><span class="tag">tslint基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/typescript/"><span class="tag">typescript</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore/"><span class="tag">ucore</span><span class="tag is-grey-lightest">18</span></a></div><div class="control"><a class="tags has-addons" href="/tags/ucore-os/"><span class="tag">ucore-os</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue/"><span class="tag">vue</span><span class="tag is-grey-lightest">11</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-cli/"><span class="tag">vue-cli</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-router/"><span class="tag">vue-router</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue-tips/"><span class="tag">vue-tips</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%8D%9A%E5%AE%A2%E5%90%8E%E5%8F%B0%E5%BC%80%E5%8F%91/"><span class="tag">vue博客后台开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%9F%BA%E7%A1%80/"><span class="tag">vue基础</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E5%AE%9E%E6%88%98/"><span class="tag">vue实战</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91/"><span class="tag">vue组件开发</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/vue%E8%BF%9B%E9%98%B6/"><span class="tag">vue进阶</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/wireshark/"><span class="tag">wireshark</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/xml/"><span class="tag">xml</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC-Primer%E3%80%8B/"><span class="tag">《C Primer》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8AC%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%E9%AD%94%E6%B3%95%E4%B9%A6%E3%80%8B/"><span class="tag">《C语言编程魔法书》</span><span class="tag is-grey-lightest">12</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8ALinux%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%92%8CShell%E8%84%9A%E6%9C%AC%E7%BC%96%E7%A8%8B%E3%80%8B/"><span class="tag">《Linux命令行和Shell脚本编程》</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E3%80%8A%E5%9B%BE%E8%A7%A3%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF%E3%80%8B/"><span class="tag">《图解密码技术》</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%8C%E5%8F%89%E6%A0%91/"><span class="tag">二叉树</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E4%BA%A4%E7%BB%99%E5%AD%90%E7%B1%BB/"><span class="tag">交给子类</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%88%86%E6%B2%BB/"><span class="tag">分治</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"><span class="tag">动态规划</span><span class="tag is-grey-lightest">8</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%8D%95%E8%AF%8D/"><span class="tag">单词</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/"><span class="tag">命令行工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9B%BE/"><span class="tag">图</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%9F%BA%E7%A1%80/"><span class="tag">基础</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%89%E5%85%A8/"><span class="tag">安全</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AE%9E%E6%88%98/"><span class="tag">实战</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%86%E7%A0%81%E6%8A%80%E6%9C%AF/"><span class="tag">密码技术</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%AF%BC%E8%AE%BA/"><span class="tag">导论</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"><span class="tag">开发工具</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E5%BC%82%E6%AD%A5%E7%BC%96%E7%A8%8B/"><span class="tag">异步编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tag">操作系统</span><span class="tag is-grey-lightest">22</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86/"><span class="tag">操作系统原理</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E5%AD%A6/"><span class="tag">数学</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"><span class="tag">数据库</span><span class="tag is-grey-lightest">10</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E7%BC%96%E7%A8%8B/"><span class="tag">数据库编程</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E5%BA%93%E8%AE%BE%E8%AE%A1/"><span class="tag">数据库设计</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><span class="tag">数据结构</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%95%B0%E7%BB%84/"><span class="tag">数组</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%9D%83%E9%99%90/"><span class="tag">权限</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A0%91%E8%8E%93%E6%B4%BE/"><span class="tag">树莓派</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%A8%A1%E5%BC%8F%E5%8C%B9%E9%85%8D/"><span class="tag">模式匹配</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"><span class="tag">正则表达式</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%AF%95%E8%AE%BE/"><span class="tag">毕设</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2/"><span class="tag">深度优先搜索</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%94%9F%E6%88%90%E5%AE%9E%E4%BE%8B/"><span class="tag">生成实例</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%AE%97%E6%B3%95/"><span class="tag">算法</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/"><span class="tag">编程语言</span><span class="tag is-grey-lightest">20</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%8B%B1%E8%AF%AD/"><span class="tag">英语</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/"><span class="tag">计算机网络</span><span class="tag is-grey-lightest">3</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">设计模式</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0/"><span class="tag">读书笔记</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E8%B8%A9%E5%9D%91%E6%8C%87%E5%8D%97/"><span class="tag">踩坑指南</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%80%82%E5%BA%94%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"><span class="tag">适应设计模式</span><span class="tag is-grey-lightest">2</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%93%BE%E8%A1%A8/"><span class="tag">链表</span><span class="tag is-grey-lightest">5</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95/"><span class="tag">问题记录</span><span class="tag is-grey-lightest">1</span></a></div><div class="control"><a class="tags has-addons" href="/tags/%E9%AB%98%E6%95%B01/"><span class="tag">高数1</span><span class="tag is-grey-lightest">1</span></a></div></div></div></div></div><div class="card widget"><div class="card-content"><div class="menu"><h3 class="menu-label">Subscribe to Updates</h3><form action="https://feedburner.google.com/fb/a/mailverify" method="post" target="popupwindow" onsubmit="window.open(&#039;https://feedburner.google.com/fb/a/mailverify?uri=&#039;,&#039;popupwindow&#039;,&#039;scrollbars=yes,width=550,height=520&#039;);return true"><input type="hidden" value="" name="uri"><input type="hidden" name="loc" value="en_US"><div class="field has-addons"><div class="control has-icons-left is-expanded"><input class="input" name="email" type="email" placeholder="Email"><span class="icon is-small is-left"><i class="fas fa-envelope"></i></span></div><div class="control"><input class="button is-primary" type="submit" value="Subscribe"></div></div></form></div></div></div></div></div></div></section><footer class="footer"><div class="container"><div class="level"><div class="level-start"><a class="footer-logo is-block mb-2" href="/"><img src="/img/logo.svg" alt="Bright的个人博客" height="28"></a><p class="size-small"><span>&copy; 2020 Bright</span>  Powered by <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a> &amp; <a href="https://github.com/ppoffice/hexo-theme-icarus" target="_blank" rel="noopener">Icarus</a></p></div><div class="level-end"><div class="field has-addons"><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Creative Commons" href="https://creativecommons.org/"><i class="fab fa-creative-commons"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Attribution 4.0 International" href="https://creativecommons.org/licenses/by/4.0/"><i class="fab fa-creative-commons-by"></i></a></p><p class="control"><a class="button is-transparent is-large" target="_blank" rel="noopener" title="Download on GitHub" href="https://github.com/ppoffice/hexo-theme-icarus"><i class="fab fa-github"></i></a></p></div></div></div></div></footer><script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/moment@2.22.2/min/moment-with-locales.min.js"></script><script>moment.locale("default");</script><script>var IcarusThemeSettings = {
            site: {
                url: 'https://www.brightblog.cn',
                external_link: {"enable":true,"exclude":[]}
            },
            article: {
                highlight: {
                    clipboard: true,
                    fold: 'unfolded'
                }
            }
        };</script><script src="https://cdn.jsdelivr.net/npm/clipboard@2.0.4/dist/clipboard.min.js" defer></script><script src="/js/animation.js"></script><a id="back-to-top" title="Back to Top" href="javascript:;"><i class="fas fa-chevron-up"></i></a><script src="/js/back_to_top.js" defer></script><!--!--><!--!--><script src="https://cdn.jsdelivr.net/npm/lightgallery@1.6.8/dist/js/lightgallery.min.js" defer></script><script src="https://cdn.jsdelivr.net/npm/justifiedGallery@3.7.0/dist/js/jquery.justifiedGallery.min.js" defer></script><script>window.addEventListener("load", () => {
            if (typeof $.fn.lightGallery === 'function') {
                $('.article').lightGallery({ selector: '.gallery-item' });
            }
            if (typeof $.fn.justifiedGallery === 'function') {
                if ($('.justified-gallery > p > .gallery-item').length) {
                    $('.justified-gallery > p > .gallery-item').unwrap();
                }
                $('.justified-gallery').justifiedGallery();
            }
        });</script><!--!--><!--!--><script type="text/x-mathjax-config">MathJax.Hub.Config({
            'HTML-CSS': {
                matchFontHeight: false
            },
            SVG: {
                matchFontHeight: false
            },
            CommonHTML: {
                matchFontHeight: false
            },
            tex2jax: {
                inlineMath: [
                    ['$','$'],
                    ['\\(','\\)']
                ]
            }
        });</script><script src="https://cdn.jsdelivr.net/npm/mathjax@2.7.5/unpacked/MathJax.js?config=TeX-MML-AM_CHTML" defer></script><!--!--><script src="/js/main.js" defer></script><div class="searchbox"><div class="searchbox-container"><div class="searchbox-header"><div class="searchbox-input-container"><input class="searchbox-input" type="text" placeholder="Type something..."></div><a class="searchbox-close" href="javascript:;">×</a></div><div class="searchbox-body"></div></div></div><script src="/js/insight.js" defer></script><script>document.addEventListener('DOMContentLoaded', function () {
            loadInsight({"contentUrl":"/content.json"}, {"hint":"Type something...","untitled":"(Untitled)","posts":"Posts","pages":"Pages","categories":"Categories","tags":"Tags"});
        });</script></body></html>